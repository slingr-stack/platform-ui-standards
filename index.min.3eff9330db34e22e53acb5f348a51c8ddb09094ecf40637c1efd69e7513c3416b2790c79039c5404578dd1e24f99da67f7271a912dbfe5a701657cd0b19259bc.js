var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/extensions/migrations/getting_started/",title:"Getting Started",description:"",content:""}),e.add({id:1,href:"/platform-ref/slingr-platform/platform-concepts/",title:"Main Concepts",description:`Platform Concepts # Developer Account and Portal # To work with Slingr, you will need a developer account. You can create one here. After creating an account, you can log in to the Developer Portal to manage your apps and start building something great. Within the Developer Portal, developers can manage their apps, organizations, endpoints, and account billing settings.
One developer account can have different roles in each app. There are three primary roles:`,content:`Platform Concepts # Developer Account and Portal # To work with Slingr, you will need a developer account. You can create one here. After creating an account, you can log in to the Developer Portal to manage your apps and start building something great. Within the Developer Portal, developers can manage their apps, organizations, endpoints, and account billing settings.
One developer account can have different roles in each app. There are three primary roles:
Developer: Developers have access to work on the app. Permissions are given per environment, so a developer could have access to the development environment but not the production one. Admin: Admins can change app settings like the plan, database settings, environments, and more. They can also grant permissions to new developers or remove an environment that is no longer used. Owner: An app can have many admins, but only one can be the owner. Usually, the owner is the user who created the app. However, ownership can be transferred. Owners have all the privileges of an admin and more. You can check the difference between an admin and an owner here. Environments and Components # As shown in the diagram, each app in Slingr has environments. Currently, Slingr supports up to three environments: development, staging, and production. Each environment consists of the following components:
Runtime: This component is responsible for taking the configurations done in the builder and generating the app. Monitor: The monitor allows you to see what&rsquo;s going on in the app during execution. See more information about the app monitor here. Builder: This component is where developers create the app by defining the data model, business logic, and integrations. See more information about the development of apps here. Environment Isolation # Environments in Slingr are fully isolated from each other to ensure stability and security:
Dedicated Memory and CPU: Each environment has its own instance for the runtime, monitor, and builder, with memory and CPU allocated for them. This allows you to work in your development environments without worrying about the production environment. Isolated Endpoints: Endpoints are independent execution processes with their memory and CPU allocation. If an endpoint experiences problems, your app will keep working. Additionally, each environment has its own endpoint instances, so issues in development won&rsquo;t propagate to production. Database: Each environment has its own database, which can be on shared or dedicated servers based on your needs. There is also a Slingr Free plan where instances are shared. Those are not meant for production. `}),e.add({id:2,href:"/dev-reference/overview/",title:"Overview",description:"",content:""}),e.add({id:3,href:"/dev-reference/overview/overview/",title:"Understanding the Slingr Platform",description:`Introduction # As described in What&rsquo;s Slingr?, Slingr is a platform designed for crafting cloud applications that seamlessly integrate with a range of SaaS solutions and internal apps. Its core purpose is to enhance developer productivity by enabling them to concentrate on solving business challenges, rather than grappling with technical intricacies.
Slingr&rsquo;s methodology revolves around defining your application&rsquo;s data model and business rules. This definition, termed as the app&rsquo;s metadata, serves as the foundation that powers your app&rsquo;s execution.`,content:`Introduction # As described in What&rsquo;s Slingr?, Slingr is a platform designed for crafting cloud applications that seamlessly integrate with a range of SaaS solutions and internal apps. Its core purpose is to enhance developer productivity by enabling them to concentrate on solving business challenges, rather than grappling with technical intricacies.
Slingr&rsquo;s methodology revolves around defining your application&rsquo;s data model and business rules. This definition, termed as the app&rsquo;s metadata, serves as the foundation that powers your app&rsquo;s execution. You can modify this metadata using the app builder.
Understanding app metadata # In the succeeding sections, we will delve into the essential components of app metadata that are crucial for creating applications in Slingr. To gain insight into metadata deployment and execution, refer to the documentation on Pushing and Syncing Changes, which also explains the process of making app alterations.
Model # A clear demarcation exists between the app&rsquo;s model and its user interface. The former encapsulates the app&rsquo;s data structure and behavior, while the latter dictates how this information is presented visually.
Slingr strives to follow a model-driven approach as much as possible. This means that the UI derives significant information from the model itself. Consequently, the UI is nearly auto-generated, with developers needing to specify only a few additional settings that can&rsquo;t be inferred from the model or that require customization.
The model essentially comprises entities, listeners, libraries, and legacy services, which are comprehensively described in the following sections.
Entities # Entities represent the cornerstone of app metadata. Think of them as an advanced version of database tables. In entities, you define the structure of the data you intend to persist within your app. However, entities offer features that elevate them far beyond traditional database tables:
Complex Data Models: Unlike conventional tables, entities support intricate data structures with multiple nesting levels and multi-valued fields. This approach reduces the necessity for a high number of entities, enhancing the cleanliness and comprehensibility of your app. Field Settings: Fields boast a multitude of settings beyond just their names and data types. These settings encompass requirements, read-only or editable statuses, calculated fields, default display preferences (thus eliminating repetitive UI definitions), permissions, validation rules, and more. While defining fields in entities, you concurrently configure numerous app settings that profoundly impact execution and rendering. Diverse Data Types: Each data type possesses its unique settings and display options. For instance, the text type allows you to set parameters like minimum or maximum length and choose between input methods such as text boxes or text areas. Slingr provides a broad spectrum of data types, each equipped with extensive settings, enabling you to furnish comprehensive information for each field in your entities. Actions: In addition to the standard actions of creating, reading, updating, and deleting records within an entity, you can define custom behaviors through actions. For instance, imagine an entity for tasks within a CRM app. This entity could include a custom action named &ldquo;Reject.&rdquo; When executed via the UI, this action prompts users to input a reason for rejection. The task is subsequently reopened, assigned to the relevant personnel, and the reason for rejection is stored as a note within the task. Such actions empower entities with custom behaviors, facilitating the creation of intricate execution workflows within your apps. Listeners: While listeners can serve a broader range of events, certain listeners are specifically designed for data events, aligning with entities. These listeners allow you to trigger actions when specific events occur within records, such as the creation of a new record, deletion of a record, or execution of an action. Permissions: You can define access privileges for entities, specifying which operations (create, edit, delete, actions, etc.) can be performed by different roles. Furthermore, granular permissions can be established at the field level. Entities encapsulate numerous aspects of your app. Consequently, when embarking on the creation of a new app, it&rsquo;s advisable to begin by defining the most pivotal entities.
For more in-depth information about entities, refer to this section.
Listeners # Listeners serve as hooks for various app events. For instance, you can trigger actions whenever a new record is created in a specific entity or respond to events originating from legacy services (e.g., creating a new record upon the creation of a contact in Google Contacts).
To explore listeners in greater detail, consult this section.
Libraries # Libraries comprise reusable JavaScript code snippets that can be employed across different sections of your app. For example, if you possess a Base64 encoding function that&rsquo;s utilized by multiple app actions, you can encapsulate this function in a library, making it easily accessible for actions that require it.
For comprehensive insights into libraries, visit this section.
Legacy services # Endpoints extend the capabilities of the platform, primarily facilitating seamless integration with various SaaS solutions like Slack, Google Calendar, SparkPost, and more. Nevertheless, legacy services aren&rsquo;t confined to integration purposes alone; they can also be harnessed for diverse use cases. For instance, let&rsquo;s assume you possess a Java library for file encryption that you intend to utilize within your app. In this scenario, you can create an legacy service integrating this Java library and subsequently leverage it within your app.
Feel free to incorporate multiple legacy services into your app, with each legacy service enhancing its functionalities. For information on existing legacy services or creating custom ones, refer to the relevant sections!
For comprehensive insights into legacy services usage, explore this section.
Permissions # Permissions empower you to define user capabilities within the app. Slingr offers highly granular permission control:
Entities: Permissions cover actions like creation, access, editing, deletion, and history tracking. Conditions can also be defined within entity permissions. For example, you can stipulate that a record can only be edited if the &ldquo;assignee&rdquo; field matches the current user. Fields: Permissions can be configured for each field, dictating whether it&rsquo;s read-only, read/write, or inaccessible. Actions: Permissions extend to actions, defining who can execute them and the parameters that can be passed to these actions. Views: Permissions encompass view accessibility. Permissions are organized within groups, and users can be assigned to one or multiple groups, resulting in permissions being dictated by the group configurations.
Although permissions are structured in groups, streamlining configuration, they can also be edited from the specific elements they govern (entities, fields, actions, and views).
Enforcement of permissions is evident both in the UI (e.g., users without permission to access an entity field won&rsquo;t see it) and in the REST API.
Workflows # With the amalgamation of entities, actions, listeners, legacy services, and permissions, robust and intricate workflows can be constructed to meet diverse requirements. Although the platform doesn&rsquo;t inherently possess a distinct &ldquo;workflow&rdquo; concept, combining these elements offers substantial flexibility for organizing your app.
User interface # Despite Slingr&rsquo;s capability to derive a wealth of information from the app model, the user interface (UI) is still customizable to cater to your preferences.
The UI of your app is structured as follows:
Header: Positioned at the top, it displays the app name and logo, which you can configure. Main Menu: This menu functions as the primary navigational tool, providing access to various sections of your app. Clicking menu items opens corresponding views in the main content area. Secondary Menu: Designed for view-associated items, this menu adds further items that are rendered in the main content area. User Menu: This menu encompasses system operations like &ldquo;My Profile&rdquo; or &ldquo;Logout,&rdquo; alongside items linked to app views, displayed within the main content area. Main Content: This region is dedicated to rendering the app&rsquo;s views. For customization of these UI components, refer to the User Interface section in the app builder. Typically, your journey starts with creating views for your entities and subsequently integrating them into the menus for seamless navigation.
Views and navigation # Views form the bedrock of your app&rsquo;s UI. A view essentially represents a visual rendering within the app&rsquo;s interface. While views can encompass diverse data representations and functionalities, most views are linked to app data, enabling diverse ways of presenting and interacting with this data.
For instance, you might establish a grid view associated with an entity representing companies. This view would list companies within your app, and its configuration would determine whether you can view details, edit records, or create new ones.
For a deeper exploration of views, refer to this section.
Navigation structures the path users take through your app. For instance, the configuration of the main menu, which dictates the content within the main content area, is determined by the navigation settings.
For more insights into navigation, refer to this section.
Field types display options # Most views present data originating from records defined in entities. Each field within these entities corresponds to a specific type, each of which possesses unique display options. For example, a choice field could be displayed as a dropdown menu or a switch.
While these type-specific rendering instructions are primarily configured at the entity level and serve as defaults, views can override these defaults to offer enhanced flexibility.
`}),e.add({id:4,href:"/getting-started/getting/where-to-start/",title:"Where to start",description:"Doks is a Hugo theme for building secure, fast, and SEO-ready documentation websites, which you can easily update and customize.",content:`
Welcome to Slingr! On this page, we will guide you through the process of getting started with our platform.
First of all, you might be wondering, what exactly is Slingr? Slingr is a cloud app creation platform that seamlessly integrates with other SaaS solutions available. You can learn more about Slingr here. Additionally, if you want to understand how our platform works, you can take a look here.
Once you have a better understanding of what Slingr is, the next step is to create a developer account. By doing so, you can begin creating apps and experimenting with our platform, which is the best way to learn how to use it. To create a developer account, simply visit the Developer Portal sign-up page.
After you have created your account, we highly recommend that you follow these tutorials, which will guide you through the most important features and steps of creating apps in Slingr. As you work through these tutorials, be sure to reference the Developer’s Reference to get more detailed information about the various features available.
To gain a solid understanding of the basics of app development with Slingr, we strongly encourage you to read through the following pages:
App Development Overview Pushing and Syncing Changes Development Process Automatic Refactorings For more information on how to manage your apps, take a look at our Managing Apps page.
If you have any questions or issues, feel free to post them on Stack Overflow with the tag slingr. We will get back to you as soon as possible!
`}),e.add({id:5,href:"/dev-reference/metadata-management/development-process/",title:"Development process",description:`In this document, we present recommendations for creating a new app in Slingr. While you&rsquo;re free to follow your own approach, we suggest going through this guide initially to grasp the fundamental path. You can then adapt these guidelines to your specific needs.
The process # At Slingr, we embrace agile methodologies for software development. The platform is designed to facilitate agile implementation while building apps. This means you can swiftly set up a basic app, and gradually evolve and enhance it over time.`,content:`In this document, we present recommendations for creating a new app in Slingr. While you&rsquo;re free to follow your own approach, we suggest going through this guide initially to grasp the fundamental path. You can then adapt these guidelines to your specific needs.
The process # At Slingr, we embrace agile methodologies for software development. The platform is designed to facilitate agile implementation while building apps. This means you can swiftly set up a basic app, and gradually evolve and enhance it over time.
Following agile principles, we encourage developers to work in small iterations when creating apps. Start with a simple version that provides some value and can be used by people. Then, gradually add more features and make adjustments as needed.
The iterative cycle typically looks like this:
Model Your Entities: Begin by defining your app&rsquo;s entities, capturing the key aspects of your domain. Start by outlining the structure of fields and a few settings. You&rsquo;ll refine these settings over time as needed. Add Business Logic: Incorporate elements like actions, listeners, legacy services integrations, scripts for calculated values, and aggregations. These additions will transform your app from a mere record repository into a dynamic system. Create Views: Establish views for your entities. If you&rsquo;ve introduced new entities, create at least a grid view to support basic CRUD operations. If you already had views, adapt them to match changes in your model. Configure Permissions: Ensure that newly added or modified features are accessible by the appropriate user groups. Define Navigation: Integrate views into menus to enable user-friendly access to app features. Test Your App: Once you&rsquo;ve established the basics, push the changes and observe your app in action. Seeing your app function provides clarity on the next steps. Iterate to Your Ideal State: Go through this cycle iteratively until you reach a point where you&rsquo;re satisfied with the results. Slingr supports your journey with features like Automatic Refactorings, auto-generated UI, and the REST API. Remember, you don&rsquo;t need to follow all these steps in each iteration. Depending on the changes, some iterations might only affect action scripts, leaving views and permissions unchanged. This is meant as a flexible guideline.
Iterations can be very brief, lasting only a few hours or even minutes, especially in your development environment. However, for syncing to production, consider longer cycles that include well-tested changes.
Best practices # Start light # Avoid attempting to create everything in your initial iteration. Focus on the most critical use cases and establish the fundamentals. Share this version with your users and make improvements based on their feedback. This incremental approach reduces uncertainty and yields an app that aligns closely with user expectations.
Optimize your development environment # Ensure that your development environment provides access to all features, and that they function optimally. For instance, if your app integrates with Slack, create a dedicated Slack team for your development environment to test Slack integrations. Avoid testing in the production environment whenever possible.
Enable comprehensive testing in your development environment. Create accounts for integrated services dedicated to your development environment, allowing developers to access and interact with these services. Having sufficient data in your development environment for various use cases will significantly accelerate development.
Prioritize versioning # When pushing changes, consider creating a backup of your app&rsquo;s metadata. This safeguard enables you to revert to a previous version if unintended issues arise.
Although you might not want to create version backups after every change, doing so when completing a significant task is wise. Include detailed notes describing the changes made in each version to facilitate future reference.
Handle production sync with care # During synchronization to the production environment, remember that your app will be briefly stopped, changes applied, and then the app restarted. This means your app won&rsquo;t be accessible to users during this time.
In many cases, downtime could be just a few seconds and won&rsquo;t impact users. However, extensive changes affecting numerous records, such as field renaming or removal, might extend the downtime. Keep this in mind when planning your synchronization to the production environment.
`}),e.add({id:6,href:"/extensions/migrations/getting_started/overview/",title:"Overview",description:`What are legacy services? # Endpoints are crucial components that extend the functionality of the Slingr platform.
👉 An legacy service is essentially a piece of software that operates alongside your app, providing additional features and capabilities. For instance, you can implement an legacy service that offers cryptographic algorithms, enabling your app to utilize them securely.
Seamless app integration # One of the primary use cases for legacy services is seamless integration with other applications, especially cloud-based services.`,content:`What are legacy services? # Endpoints are crucial components that extend the functionality of the Slingr platform.
👉 An legacy service is essentially a piece of software that operates alongside your app, providing additional features and capabilities. For instance, you can implement an legacy service that offers cryptographic algorithms, enabling your app to utilize them securely.
Seamless app integration # One of the primary use cases for legacy services is seamless integration with other applications, especially cloud-based services. Slingr offers an official legacy services registry, which houses various legacy services designed to facilitate smooth integration with popular services such as Slack, Google Calendar, or SparkPost.
As shown in the diagram above, apps can use the API provided by the legacy service to send messages to another app. For example, it could be a method to retrieve available calendars from an external calendar service:
var calendars = app.endpoints.calendarEndpoint.findCalendars(); sys.logs.info('Calendars: '+ JSON.stringify(calendars)); When an legacy service is added to an app, its API will be accessible through functions defined in the scripts under the namespace app.endpoints.&lt;endpointName&gt;, as shown in the example above. To understand the API details, refer to the documentation for each specific legacy service.
Another aspect of the legacy service&rsquo;s API is the handling of events, which are messages sent from the endpoint to the app. These events can be captured by legacy service listeners , allowing you to take specific actions upon their arrival. For instance, you can create a listener to capture an event when a new contact is created on Google Contacts and perform actions accordingly.
sys.logs.info('New contact: '+ JSON.stringify(event.data)); app.contacts.createContactInApp(event.data); So, legacy services extend the platform in two ways: A new API under the namespace app.endpoints.&lt;endpointName&gt; that can be accessed through scripts. Events that can be caught using legacy service listeners. Some legacy services will also provide a webhook URL where you can receive an asynchronous response from your endpoint. These can be handled using legacy service listeners so the app can act upon a received response. You can find more information on how to use legacy services here.
Legacy service configuration # Legacy services can be added to an app in the app builder, in the Model &gt; Legacy services section. Here, you can set the configuration of legacy services, which basically consists of the type of legacy service, name, and some legacy-service-specific settings like API keys, users, passwords, etc.
By default, the latest version of the legacy service will be selected, and if the legacy service is updated, it will always deploy the latest version. If you select a specific version of the legacy service, you can choose the upgrade policy to automatically upgrade to compatible versions or to fix the version you previously selected.
You can find more information about the configuration of legacy services here.
Legacy service lifecycle # When you add a new legacy service in the app builder, you are just defining its configuration. To deploy the legacy service, you need to push changes (it will be deployed only if the initial status is Deployed). When that happens, the legacy service will be deployed, and from there, the status of the legacy service should be handled from the app monitor.
In the app monitor, in the legacy services section, you will be able to restart, undeploy, and deploy legacy services. The lifecycle of legacy services is independent of the app. This means that when you restart an endpoint, your app keeps working, and vice versa. If events happened in the middle, operations will be retried so no events are lost.
If you no longer need an legacy service, you can remove it from the app builder, and the legacy service will be deleted when changes are pushed. Remember to manually delete usages of an legacy service in scripts if you are going to delete it.
Create your own legacy services # Finally, it is possible to create your own legacy services to extend what the platform can do and connect to other services that aren&rsquo;t included in the official legacy services. Learn more about that here.
`}),e.add({id:7,href:"/platform-ref/slingr-dev-portal/dev-portal-overview/",title:"Overview",description:`The Developer Portal is a key component and the entry point of the Slingr Platform.
Slingr Developers can use the Developer Portal to:
👉 Manage their Apps: Create and configure general settings for their apps. Developers can define basic settings (label, name, logo, and description) as well as settings specific to each app environment, including instances (size and number), database, and custom domain.
👉 Manage Accesses: Configure the accounts that have developer or admin permissions for a specific app.`,content:`
The Developer Portal is a key component and the entry point of the Slingr Platform.
Slingr Developers can use the Developer Portal to:
👉 Manage their Apps: Create and configure general settings for their apps. Developers can define basic settings (label, name, logo, and description) as well as settings specific to each app environment, including instances (size and number), database, and custom domain.
👉 Manage Accesses: Configure the accounts that have developer or admin permissions for a specific app.
👉 Register Endpoints: Allows developers to register and manage the custom app services that will be available for app building.
👉 Manage Billing: Configure payment settings and access billing information for the account.
To start using the Slingr Platform, you need to sign up here.
`}),e.add({id:8,href:"/getting-started/getting/what_is_slingr/",title:"What's Slingr",description:`Slingr is a platform for creating cloud apps that seamlessly integrate with other SaaS solutions.
The approach followed by Slingr is to have you describe your data model and business rules, which will then be used to create your application. The idea behind this approach is to allow you to focus on solving business problems rather than dealing with technical issues that often arise when using more low-level tools like Java or .`,content:`Slingr is a platform for creating cloud apps that seamlessly integrate with other SaaS solutions.
The approach followed by Slingr is to have you describe your data model and business rules, which will then be used to create your application. The idea behind this approach is to allow you to focus on solving business problems rather than dealing with technical issues that often arise when using more low-level tools like Java or .Net.
Our goal is to significantly increase productivity when creating apps.
On the other hand, we acknowledge that many SaaS solutions are purpose-built and highly efficient for specific problems. Attempting to replicate them within Slingr would be counterproductive. Therefore, our approach is to provide tools that enable easy integration of existing cloud apps, freeing you to concentrate on creating custom workflows tailored to your business needs.
This means you define the business rules and data model, and in return, you automatically get a working app with a user interface and a REST API that allows your app to be used by other applications. Slingr offers a wide range of features to help you model your business requirements effectively. It is designed to create real-world apps, not just trivial prototypes.
As every developer knows, businesses evolve, and apps must evolve with them. Slingr provides mechanisms that enable you to quickly and cost-effectively evolve your apps with minimal risk. When you make changes to your app, it is automatically refactored to reflect those modifications, simplifying the evolution process.
Additionally, Slingr provides tools to monitor your apps, ensure data security, and maintain control at all times.
Finally, everything happens on the cloud, eliminating the need for you to set up or maintain any servers, configure development environments, or worry about user terminals.
Slingr offers an end-to-end cloud solution.
Highlights # - Focus on solving business problems instead of technical issues. - Increase your productivity to create cloud apps. - Integrate with existing cloud apps. - Define your data model and business rules while the UI is generated. - Auto-generated REST API to easily integrate your app. - Easily evolve your apps as your business does. - End-to-end cloud solution, from development to your end users. How It Works # As explained before, you need to define your data model and business rules in the builder. The app runtime will then use this definition to execute the specified actions and conditions.
To provide a simplified example of how it works, let&rsquo;s consider an entity called &ldquo;Companies&rdquo; with a few properties. This entity defines your data model. Additionally, you might have actions and conditions to activate/deactivate a company, along with some rules that trigger when a company changes its status, resulting in the owner being notified by email.
Below, you can observe the data model definition and the resulting app displayed in a web browser:
Apart from the UI, the following REST API will be generated:
POST /data/companies GET /data/companies/{id} GET /data/companies PUT /data/companies/{id} DELETE /data/companies/{id} PUT /data/companies/{id}/activate PUT /data/companies/{id}/deactivate The idea is that you only need to take care of the problems you need to solve, instead of worrying about which database to use, which technologies for the backend and frontend, or spending time setting up servers and development environments, etc. You just need to focus on your business requirements, and we&rsquo;ll take care of the rest :)
This is a highly simplified example to demonstrate the basics of how Slingr works, but you can achieve much more powerful functionalities with it. In the next section, we will describe a few use cases.
Use Cases # Create an app to support your business # In this scenario, you need an application to support your main business processes, and you want to integrate it with specific systems such as email and payment gateways. With Slingr, you can easily create this application by defining your business rules, permissions for different users, and more. Next, you should configure endpoints for the integrations you require and set up the integration points.
Glue your existing apps # In this case, you are already using various cloud apps. You can leverage Slingr to coordinate workflows in your business, breaking silos between different departments. Here are some use cases for the schema described above:
Custom support will utilize Zendesk. Some information will flow into Slingr, such as log types of issues, resolutions, surveys from customers, or escalated issues to different departments. For example, if there&rsquo;s an issue that requires developer attention, the customer support representative will escalate the issue to development, creating an issue on the Slingr app, which in turn, will trigger the creation of a ticket in JIRA. Managers and executives will have the ability to monitor ongoing activities using SLNGR. There&rsquo;s no need to log into each specific app to obtain information about the state of the business. After running billing processes, charges are moved to QuickBooks, where accountants can handle them. When a developer closes a ticket on JIRA that was previously escalated by support, an email is sent to customer support, notifying them that the problem has been resolved. There is a mobile app that utilizes the REST API to extract and insert information into the app on Slingr. This mobile app has a highly customized UI and only exposes a limited set of functionalities that are relevant to the user. Customize a template app # In this case, instead of creating an app from scratch on Slingr, you can take one of the template apps and adapt them to your business needs.
This can apply also to your own apps. Let&rsquo;s suppose you build an app for lawyers, and you want to sell it to different companies, but each company has its own requirements. In this case, you can have a template app, and then for each company, you can customize what they need without affecting other apps.
Use it as a backend for mobile apps # Due to the exceptional REST API automatically generated for your app, it becomes incredibly easy to develop mobile apps tailored to specific purposes. These mobile apps can effortlessly pull and push data to the Slingr app, effectively acting as a backend. As long as the mobile app can access the Slingr API, it can be either native or use HTML5.
In the diagram example above, employees utilize the app on Slingr, whereas customers interact with mobile apps featuring enhanced user interfaces adapted for specific purposes.
`}),e.add({id:9,href:"/dev-reference/metadata-management/metadata-editor/app-resources/",title:"App resources",description:`Navigation tree # On the left side of the app builder, you&rsquo;ll discover a panel housing the navigation tree. This tree serves as the primary means of navigating through all your app&rsquo;s metadata. It consists of nodes, folders, and sub-nodes that represent the various resources within your app.
✅ Quickly expand or collapse the left panel with app resources using the keyboard shortcut Alt + Left Arrow. Interacting with the navigation tree # With the exception of root nodes, clicking on any node in the tree will display a view in the builder&rsquo;s central panel.`,content:`Navigation tree # On the left side of the app builder, you&rsquo;ll discover a panel housing the navigation tree. This tree serves as the primary means of navigating through all your app&rsquo;s metadata. It consists of nodes, folders, and sub-nodes that represent the various resources within your app.
✅ Quickly expand or collapse the left panel with app resources using the keyboard shortcut Alt + Left Arrow. Interacting with the navigation tree # With the exception of root nodes, clicking on any node in the tree will display a view in the builder&rsquo;s central panel. This view contains the details and properties associated with that specific resource. Whenever you create a new resource from the central panel or update/delete an existing one, the navigation tree will automatically create, update, or delete corresponding nodes.
&#x26A0;&#xFE0F; Keep in mind that certain resources cannot be deleted. Basic structure # The navigation tree boasts five root nodes that serve as containers for all other resources:
App Environment Settings Model Security User Interface Each of these nodes is comprehensively explained in a dedicated section of this documentation.
`}),e.add({id:10,href:"/extensions/migrations/endpoints/",title:"Legacy services ",description:"",content:""}),e.add({id:11,href:"/platform-ref/slingr-dev-portal/managing-apps/",title:"Managing apps",description:`Apps can be managed in the Slingr Developer Portal. From there, you will be able to manage apps, endpoints, organizations, handle developer permissions, set up billing, and view invoices, etc.
App Creation # 👉 To create a new app, simply click the Create app from scratch button located in the Home section of Slingr.
👉 You can also create new apps from the Apps section by clicking the + Create Apps button`,content:`Apps can be managed in the Slingr Developer Portal. From there, you will be able to manage apps, endpoints, organizations, handle developer permissions, set up billing, and view invoices, etc.
App Creation # 👉 To create a new app, simply click the Create app from scratch button located in the Home section of Slingr.
👉 You can also create new apps from the Apps section by clicking the + Create Apps button
Then, you will be asked to complete the following fields:
Label: This is a human-friendly name for your app. It can contain spaces and special characters. The label will be used in your app in different places, like the header or the title of the browser.
Name: This is the internal name of your app. It&rsquo;s required and cannot contain spaces or special characters, and it must be unique. It will be used as the subdomain of your app: &lt;app-name&gt;.slingrs.io.
&#x26A0;&#xFE0F; You won&rsquo;t be able to change the name of your app later. App owner: You can choose to be the owner of the app or select an organization that you belong to.
Plan: This is the plan your app will run on. You can choose between three different plans depending on your needs:
Slingr Free: This plan is free and is useful to understand the platform and learn how to use it, however, it is not suited for complex or production apps. Slingr Dev: This is an isolated environment with a fixed price that allows developers to have personal apps for a reasonable price. It has some limitations. Slingr Pro: This is a usage-based plan meant for applications in production environments that need dedicated resources and outstanding performance. There are no limitations with the Slingr Pro plan. You can see the full comparison in Pricing and Billing.
Template: You can choose to start from scratch, with an empty app, or you can choose one of the available templates. Here you will find global templates created by other people, or you can also create your own templates. See App templates for more information.
When you select a template, you might decide to make it linked by setting the flag Linked, which is only available if you select Slingr Pro as the plan. If this flag is set, the new app will be linked to the template. This means that the new app will only have a production environment, and when changes are synced in the template app, those changes will be applied to this new app as well. If you don&rsquo;t set this flag, only a development environment will be created using the app template, but it will be completely independent from the original app, which means new changes in the template won&rsquo;t affect the new app, and vice versa.
By default, when you create a new app, only the development environment (unless you have set the Linked flag) is created with the selected plan.
✅ You can add a production environment later or change the plan if needed. Additionally, your developer account will be set as the admin, owner, and developer for the new app.
App settings # Once an app is created, you will see the following options:
Label: This is a user-friendly name of your app that was provided during the creation process. You can change the app&rsquo;s label at any time.
Description: This is an internal description of your app. This field is for internal use or, if the app is a template, it will be used as the template&rsquo;s description.
App logos: These are the logos, favicon, and background of the app. They will be displayed in different places, such as the Developer portal, your app&rsquo;s header, the browser&rsquo;s title, etc. We recommend using a transparent background, but you are free to choose any.
Any changes you make to these settings will be applied immediately.
App Environment Settings # Apps can have three different environments:
Development: This is the main environment that developers will use to make their changes. It&rsquo;s the default environment.
Staging: This environment can be used as a buffer between development and production. Additionally, when you are in production and you need to fix something, this environment is ideal to apply hotfixes in Production without syncing all the changes in Development.
Production: This is the production environment your users will access. This environment does not have the builder component because you should never change your app directly in production.
👉 By default, a new app will only have the Development environment, but you can easily add new ones as you need them.
👉 Each app environment has the following settings:
Status: Indicates in which status the environment is. If the value is different than Deployed, it could be that some maintenance work is going on (for example, the platform is being upgraded) or there is a problem, and you should contact support.
Version: This is the current version your app is running on. We periodically release new updates to the platform, and we automatically update apps when that&rsquo;s possible. If your app is behind, you will be able to manually trigger an update when you find it more convenient.
Instances: This is the number of runtime instances for this environment. The more instances you have, the more requests and work your environment can handle, so this is a good way to scale your app. Keep in mind that more instances also mean more usage, so be sure you understand how Pricing and Billing work in your plan. It could be that not all instances are available at all times, for example, when you just added them, or there is some maintenance work. In that case, it will be shown how many instances are deployed and running out of the desired number of instances. Apart from the number of instances, you can also configure the size of each instance. You will need bigger instances as your app gets more complex. Don&rsquo;t worry; we will notify you if your instances are running out of resources. Here you should consider upgrading the size of your instance. The available sizes are:
Small (1GB): This is the default size for apps. It is meant for small apps. Medium (2GB): This is for medium apps. Large (4GB): This is for big apps when there are many entities, views, listeners, endpoints, etc. Database: Just adding more instances might not work to scale your app as there is a point where the database will be the bottleneck. When you reach that point (usually we try to size the database based on data size so you know when to switch), you should update the database of the app environment from here. Please take a look at Pricing and Billing to understand how this will impact your invoice.
Custom domain: By default, your app will be available at &lt;appname&gt;.slingrs.io; however, you can use your domain as well, for example, myapp.com. To do that, you need to own the domain and have a valid SSL certificate. Just click on Set your domain, and you will be asked to enter the domain and SSL certificate information.
There are a few cases that need changes in settings that deserve more attention:
Scaling Up and Down Your App # The way to scale your app is by adding more instances. How many instances you need depends on your app and the load it has, so it is hard to say how many users or API requests an instance can handle.
What we recommend is to watch out for the response time of your app and add more instances when you see it goes above your maximum desired value or when you see that the waiting time of background jobs is growing. You can check those things in the app monitor.
Also, keep in mind that adding more instances might not help if the database is the bottleneck. In this case, you should upgrade your database to take advantage of the additional instances. You can check the slow queries report in the app monitor to see if the database is the bottleneck.
The same way you can add instances, you can remove them. When you do that, some instances will be gracefully stopped and undeployed until the desired number of instances is met.
Changing the Database # 🚨 Depending on the source and the target database type, changing the database could cause a downtime of your app. If you are upgrading from a shared database to another shared database, in most cases, it won&rsquo;t mean any downtime, and the data size limit will be updated immediately. If it happens that we need to do some migrations, we will notify you, and you should confirm before proceeding.
If you are upgrading from a database in shared servers to one in dedicated servers, a migration will be needed, and your app will be down during that time.
If you are upgrading from a database in dedicated servers to another database in dedicated servers, migration can be done without any downtime.
Keep in mind that you will only be able to downgrade your database if the data size fits in the new database type.
Manage Developers and Admins # When you create an app, you automatically become the admin owner and a developer for it. However, you can add permissions to other developers to work in your app or give them admin permissions.
Developers # In the Developers section of the app details, you can add more developers by entering the email associated with their developer accounts. Once you add a developer, you can choose which environments they will have access to.
When you give access to one environment, the developer will be able to use all components in it, such as runtime, builder, and monitor. Additionally, a user will be created in the environment for that developer. So, if you go to the screen to manage users in that environment, you will see the developer listed as a user. These users will belong to the Developers group and cannot be modified (you can only assign new groups, but cannot change the password, name, etc.). They will be automatically managed and synced. For example, if the developer changes their password, it will be updated in all apps.
One important thing about developer users is that permissions defined in the app won’t affect developers as they always have permissions for everything. The exception is when you assign groups to the developer in that app. If you do so, the developer user will use those groups’ permissions by default.
If you need to test permissions while developing your app, you should create other regular users, assign groups to your developer user in that app, or use the &quot;Switch groups&quot; option available in the user menu of the app runtime.
Admins # ℹ️ Admins are not allowed to use the app. If you want to, the admin should also be a developer. 👉 In the Admins section of the app details, you can indicate which developer accounts will have admin permissions over the app.
👉 Admins can perform the following actions:
Add/remove developers Change general settings of the app Change settings of the app environment 👉 Furthermore, there is only one admin who is also the owner of the app (by default the creator of the app). The owner can perform the following actions:
Add/remove admins Transfer ownership to another admin Put the app to sleep or wake it up Delete the app 👉 Ownership can be transferred by adding a new admin and then, after selecting that admin, clicking on the button Transfer ownership to this admin.
Sleeping and Wake Up # If your app is not going to be used for a period, you can put it to Sleep. This way you can avoid charges while still keeping your app. Later, if you need it again, you can wake it up and continue using it as usual.
This can be done by clicking the buttons Sleep app and Wake up app.
ℹ️ This action can only be performed by the app owner. Adding New Environments # When an app is created, by default, it only has a Development environment. We recommend keeping only the development environment until you see the need for another environment.
Production Environment # If you need a Production environment, you can easily add it by clicking the Add production environment button.
When you add a production environment, it will be created based on your current development environment. However, keep in mind that data won&rsquo;t be copied. You should export and import records from Development to Production if you need to do so.
Also, if you want developers to access the production environment, you will need to explicitly set permissions, even if they already had permissions for the development environment.
Staging Environment # Once you have a development and a production environment, you might see the need for an additional environment to work as a buffer between development and production. This is the Staging environment, and you can add it by clicking the Add staging environment button.
This environment is very useful for doing QA and also for performing hotfixes of issues that show up in production.
Unlink app # If you created the app from a template with the Linked flag, the app will only have a production environment, and you won&rsquo;t be able to make changes. Instead, changes are made in the template app and synced to the clones.
If, at some point, you need to make changes to the app, you will need to unlink the app first. You can do that by clicking on the Unlink button in the app&rsquo;s details. When the app is unlinked, a Development environment is added to the app.
&#x26A0;&#xFE0F; You won&rsquo;t be able to link it again to the template, and the apps will become independent from each other. Development environment in linked apps # There are cases where you need to make some changes to a linked app, but you don&rsquo;t want to unlink it because you still want to get updates from the master app.
In these cases, you can add a development environment by clicking on Add development environment. When you do this, how changes are synced will be altered. Please check the section Pushing and Syncing changes for more details.
Delete App # If you no longer need an app, you can delete it. This will remove all instances as well as the database, which means all data will be lost.
🚨 This operation cannot be undone, so please be careful. ℹ️ Only the app owner can perform this action. App Templates # If you want to turn an app into a template, you can do so by enabling the Make this app a template flag. Once this option is enabled, your app will appear in the list of templates when creating new apps (inside your account only).
Cloning Apps # You can create a clone of your app by clicking the Clone App button. This will create a new app using the same plan as the current app with the selected environment. Please note that data will also be copied (up to 1,000 records per entity).
✅ Cloning your apps is useful when you want to test some changes in your app without affecting the original version. `}),e.add({id:12,href:"/dev-reference/metadata-management/",title:"Metadata management",description:"",content:""}),e.add({id:13,href:"/getting-started/getting/first-steps/main/",title:"Tutorials",description:`The best way to learn how to use Slingr is to build something. Fortunately, we have made some tutorials to help you get started. In these tutorials, we won’t go through all the features of the platform. The goal is that you get a general idea of how it works, and then you can start building something great by yourself.
In these tutorials, we are going to assume you already have a developer account.`,content:`The best way to learn how to use Slingr is to build something. Fortunately, we have made some tutorials to help you get started. In these tutorials, we won’t go through all the features of the platform. The goal is that you get a general idea of how it works, and then you can start building something great by yourself.
In these tutorials, we are going to assume you already have a developer account. If not, go ahead and create one here Available tutorials # Working with Event Planner In this tutorial we are going to make some improvements to the Event Planner App. The estimated time of completion is 15 minutes.
Start Now Working with Task Manager App In this app, users will be able to create tasks, assign them to other users, move them through different columns and send notifications to Slack channels. Estimated time: 40'
Start Now If you wish to explore the resulting apps without going through the entire process, we have provided some as templates for your convenience.
You can easily create an app here and select the desired template from the available options. However, please keep in mind that if you choose to start the Task Manager App from a template, you&rsquo;ll need to configure the Slack integration as detailed in the &ldquo;Integration with Slack&rdquo; section of the Task Manager tutorial.
`}),e.add({id:14,href:"/dev-reference/metadata-management/metadata-editor/metadata-edition/",title:"Metadata edition",description:`General description # Upon clicking on a node within the navigation tree, a corresponding view will appear in the central panel of the app builder. Depending on the resources associated, this view may either present a table showcasing details about sub-items or an editable form featuring labels and values that reflect the various settings tied to the selected resource.
Central panel view # In each of these views, you&rsquo;ll immediately notice a top header containing specific elements.`,content:`General description # Upon clicking on a node within the navigation tree, a corresponding view will appear in the central panel of the app builder. Depending on the resources associated, this view may either present a table showcasing details about sub-items or an editable form featuring labels and values that reflect the various settings tied to the selected resource.
Central panel view # In each of these views, you&rsquo;ll immediately notice a top header containing specific elements. On the left side of this header, the breadcrumb navigation displays the current context path within the metadata tree, along with links to each parent node&rsquo;s view. On the right side, a set of buttons enables various operations related to the particular resource. Common operations include: cancel, reset, delete, apply, save, show history, and find usages.
Action buttons # Cancel: Closes the current form and redirects to the parent metadata node. Reset: Restores the form and all associated setting values to the previously saved state. Delete: Removes the current resource and redirects to the parent metadata node. Apply: Attempts to save the form and all current settings of the specific resource. It won&rsquo;t redirect to another URL afterward. Save: Tries to save the form and all current settings of a resource. After saving changes, it will redirect you to the parent node of that resource. Show History: Located within the tools button. Clicking this action displays a view in the central panel featuring a table that outlines the history of changes connected to the present resource. Find more information about this view here. Find Usages: Within the tools button, clicking this action reveals the right panel in the usages tab. It presents a list of all locations where the current resource has been utilized. `}),e.add({id:15,href:"/dev-reference/metadata-management/metadata-editor/",title:"Metadata editor",description:"",content:""}),e.add({id:16,href:"/extensions/migrations/endpoints/official_endpoints/",title:"Official legacy services",description:`Here you can find the list of our officially-supported legacy services:
AWS Connect AWS Lex AWS Simple Email Service AWS Simple Notification Service Ethereum FTP Google Calendar Google Contacts Google Drive Google Recaptcha Google Slides HTTP MailChimp Mandrill PandaDoc PDF Generator Plaid Proxy QR Code QuickChart Salesforce ShipEngine Slack Slack - Team per user Slingr App Slingr Webhook SQL Squarespace Stripe `,content:`Here you can find the list of our officially-supported legacy services:
AWS Connect AWS Lex AWS Simple Email Service AWS Simple Notification Service Ethereum FTP Google Calendar Google Contacts Google Drive Google Recaptcha Google Slides HTTP MailChimp Mandrill PandaDoc PDF Generator Plaid Proxy QR Code QuickChart Salesforce ShipEngine Slack Slack - Team per user Slingr App Slingr Webhook SQL Squarespace Stripe `}),e.add({id:17,href:"/platform-ref/slingr-dev-portal/pricing-and-billing/",title:"Pricing and billing",description:`Pricing of the platform is based on apps. Each app will have a corresponding subscription, which can be associated with any of the three products we offer:
👉 Slingr Free: These apps are free and won&rsquo;t incur any charges.
👉 Slingr Dev: These apps have a fixed monthly fee. You can check the pricing here.
👉 Slingr Pro: These apps will be charged based on usage. The more environments, instances, endpoints, etc.`,content:`Pricing of the platform is based on apps. Each app will have a corresponding subscription, which can be associated with any of the three products we offer:
👉 Slingr Free: These apps are free and won&rsquo;t incur any charges.
👉 Slingr Dev: These apps have a fixed monthly fee. You can check the pricing here.
👉 Slingr Pro: These apps will be charged based on usage. The more environments, instances, endpoints, etc., you use, the more you will pay. Please check the pricing here for more details.
It&rsquo;s essential to note that although you see monthly prices on our website, we bill hourly. This means that your end-of-month payment may not be exact, but it will be similar. This benefits you because you only pay for what you use. For example, if you need to spin up an app for testing purposes, you can create one, perform the necessary tests, and then delete it, and you will be charged only for the time you used it.
Keep in mind that Slingr offers additional services like support and professional services that are not part of the platform billing scope. You can find more information about them on the Slingr website.
`}),e.add({id:18,href:"/dev-reference/metadata-management/metadata-editor/app-explorer/",title:"App explorer",description:`App explorer panel # Located on the right side of the app builder, the App Explorer panel provides quick access to different aspects of your app&rsquo;s metadata. The panel consists of four tabs:
Structure (default selection) Find Usages Help ✅ Use the keyboard shortcut alt + right arrow to expand or collapse the right panel with the App Explorer. Structure tab # When the Structure tab is active, an interactive tree resembling the navigation tree on the left panel is displayed.`,content:`App explorer panel # Located on the right side of the app builder, the App Explorer panel provides quick access to different aspects of your app&rsquo;s metadata. The panel consists of four tabs:
Structure (default selection) Find Usages Help ✅ Use the keyboard shortcut alt + right arrow to expand or collapse the right panel with the App Explorer. Structure tab # When the Structure tab is active, an interactive tree resembling the navigation tree on the left panel is displayed. This tree is a simplified version of the navigation tree, primarily focusing on resources within the Model node and an additional User Interface node. It provides a cleaner view of your app&rsquo;s metadata structure.
Clicking on nodes within the explorer tree will populate a table in the lower section with essential information and settings related to the selected node.
✅ Use this feature to quickly review fields or properties of a particular resource while keeping the form of another resource open. The table also includes links to the view of each resource, allowing seamless navigation. Find tab # With the Find tab active, a search box appears below the tabs. This search box enables you to search for specific text within your app&rsquo;s metadata. The search scans for matches in name, label, or text within entities, fields, actions, listeners, views, libraries, and legacy services. After a search, a list of matching results with clear paths will be presented. Clicking on an item redirects you to the view of that resource.
✅ Use this feature when your app&rsquo;s metadata has grown extensively, and you need to locate a particular resource without recalling its position in the navigation tree. Usages tab # For the Usages tab, you can activate it by using the Find Usages action from the central panel header. This tab displays a list of all instances where the current resource is utilized. Clicking on an item within the list redirects you to the resource where the current resource is being used.
✅ Use this feature when your app&rsquo;s complexity makes it challenging to track all the places where a particular resource is employed. Help tab # With the Help tab active, an embedded view of the documentation section relevant to the selected resource in the navigation tree is presented. This view automatically updates as you change the selected resource in the central panel.
✅ Utilize this feature to conveniently consult documentation without switching between tabs whenever you require information. `}),e.add({id:19,href:"/extensions/migrations/endpoints/community_endpoints/",title:"Community legacy services",description:`Here you can find the list of the community legacy services:
Apidaze Authorize.Net Autotask Autotask - Per user Autotask - Endpoint management Bombora Coinbase Coinbase Pro User Dendi LIS Endicia Eversign Fama FedEx FullContact GitHub App import.io QuickBooks QuickBooks Payments Shippo SparkPost Spoitify SurveyGizmo SwiftDil Tracers TSheets Twilio Twitter UPS USAePAY USPS `,content:`Here you can find the list of the community legacy services:
Apidaze Authorize.Net Autotask Autotask - Per user Autotask - Endpoint management Bombora Coinbase Coinbase Pro User Dendi LIS Endicia Eversign Fama FedEx FullContact GitHub App import.io QuickBooks QuickBooks Payments Shippo SparkPost Spoitify SurveyGizmo SwiftDil Tracers TSheets Twilio Twitter UPS USAePAY USPS `}),e.add({id:20,href:"/platform-ref/slingr-dev-portal/partner-rest-api/",title:"Partner REST API",description:`This API is for partners that need to create accounts or apps on the Slingr platform on behalf of other people.
You can access the API at the following endpoint:
https://developer-portal.slingrs.io/api Notice that you always have to use HTTPS. Trying to access out API using HTTP will return an error.
Additionally, all calls should have the following headers:
Content-Type: application/json Accept: application/json token: &lt;token received after login&gt; General error codes # Here are some general error descriptions.`,content:`This API is for partners that need to create accounts or apps on the Slingr platform on behalf of other people.
You can access the API at the following endpoint:
https://developer-portal.slingrs.io/api Notice that you always have to use HTTPS. Trying to access out API using HTTP will return an error.
Additionally, all calls should have the following headers:
Content-Type: application/json Accept: application/json token: &lt;token received after login&gt; General error codes # Here are some general error descriptions. Then on each method you will see a better description to some of the errors that can show up.
HTTP Status Code Description 200 Everything went fine. No errors. 400 Request is not valid. This can be due to validation errors in the data you are sending or because the operation you are trying to do is not valid. 401 Unauthorized. You need to log in or the provided token is not valid. 403 Forbidden. You have credentials, but you are trying to access data or execute an operation you don’t have permissions. 404 Not found. The resource you are trying to access does not exist. 409 Optimistic locking exception. This happens when two users tries to update the same record at the same time. The once that enters in the second place will get this error. 500 Internal error. This happens when something went wrong and was not expected. If you get this type of errors please contact support. 503 Service unavailable. This is when the application is under maintenance. Authorization # In order to call methods in this API you will need a partner token. You need to request this token to the Platform team support (support@slingr.io). So for all request you will need to send the header token with the partner token.
Create an account # POST /accounts Creates a new account in the platform. This account will be associated to the partner that created it.
Request # POST /accounts &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;firstName&quot;: &quot;first name&quot;, &quot;lastName&quot;: &quot;last name&quot;, &quot;email&quot;: &quot;name@company.com&quot;, &quot;password&quot;: &quot;abcd1234&quot; } Path Description firstName First name of the owner of the account. lastName Last name of the owner of the account. email Email of the owner of the account. password Password to set this this account. Response # The created account in JSON format.
POST /accounts &lt; Content-Type: application/json { &quot;id&quot;: &quot;asdw432j4bu9bdf92323&quot;, &quot;firstName&quot;: &quot;first name&quot;, &quot;lastName&quot;: &quot;last name&quot;, &quot;email&quot;: &quot;name@company.com&quot;, &quot;status&quot;: &quot;ACTIVE&quot;, &quot;timeZoneMode&quot;: &quot;AUTO&quot; } Error code HTTP Status Code Description validationErrors 400 If there are validation errors. When this happens you will get the details of the errors in the body: { "code": "validationErrors", "message": "There are validation errors", "errors": [ { "field": "firstName", "fieldLabel": null, "code": "required", "message": "First name cannot be empty", "additionalInfo": null } ] } forbidden 403 You don’t have permissions to create an account. You should check the token. Samples # creates a new account POST /accounts &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;firstName&quot;: &quot;first name&quot;, &quot;lastName&quot;: &quot;last name&quot;, &quot;email&quot;: &quot;name@company.com&quot;, &quot;password&quot;: &quot;abcd1234&quot; } POST /accounts &lt; Content-Type: application/json { &quot;id&quot;: &quot;asdw432j4bu9bdf92323&quot;, &quot;firstName&quot;: &quot;first name&quot;, &quot;lastName&quot;: &quot;last name&quot;, &quot;email&quot;: &quot;name@company.com&quot;, &quot;status&quot;: &quot;ACTIVE&quot;, &quot;timeZoneMode&quot;: &quot;AUTO&quot; } Check app name # GET /utils/checkAppName Checks if an app name is available.
Request # GET /utils/checkAppName &gt; Accept: application/json &gt; token: token Parameter Required Default Description appName yes - This is the app name to check availability. Response # The response indicating if the app name is available.
GET /utils/checkAppName &lt; Content-Type: application/json { &quot;status&quot;: &quot;available&quot; } Path Description status Indicates if it is available. Values could be: Status Description available App name is available. notUnique There is another app with the same name. invalid The name is not valid. For notUnique and invalid you will also get a field message with more details about the problem. message yes Possible errors # Error code HTTP status code Description Unathorized 401 You are not authenticated or credentials are invalid. Samples # checks a name that is available GET /utils/checkAppName?appName=uniqueAndValidName &gt; Accept: application/json &gt; token: token GET /utils/checkAppName?appName=uniqueAndValidName &lt; Content-Type: application/json { &quot;status&quot;: &quot;available&quot; } checks a name that is not unique GET /utils/checkAppName?appName=notUniqueName &gt; Accept: application/json &gt; token: token GET /utils/checkAppName?appName=notUniqueName &lt; Content-Type: application/json { &quot;status&quot;: &quot;notUnique&quot;, &quot;message&quot;: &quot;Code is already in use.&quot; } checks an invalid name GET /utils/checkAppName?appName=$invalid# &gt; Accept: application/json &gt; token: token GET /utils/checkAppName?appName=$invalid# &lt; Content-Type: application/json { &quot;status&quot;: &quot;invalid&quot;, &quot;message&quot;: &quot;Only lowercase letters and numbers are allowed. The first character must be a letter.&quot; } `}),e.add({id:21,href:"/dev-reference/metadata-management/metadata-editor/console/",title:"Console",description:"Console panel # Situated at the bottom of the app builder is the console panel. By clicking on it, you can expand this panel. Within the console, you have the ability to execute scripts using the Javascript API of the platform. The results of these script executions will be displayed on the right side of this panel. This feature proves highly valuable for testing scripts prior to implementing them in other parts of your app.",content:`Console panel # Situated at the bottom of the app builder is the console panel. By clicking on it, you can expand this panel. Within the console, you have the ability to execute scripts using the Javascript API of the platform. The results of these script executions will be displayed on the right side of this panel. This feature proves highly valuable for testing scripts prior to implementing them in other parts of your app.
✅ Utilize the keyboard shortcut alt + down arrow to expand or collapse the console panel. ✅ Pressing ctrl + enter allows you to execute scripts directly in the console. `}),e.add({id:22,href:"/extensions/migrations/official-ui-plugins/",title:"Official UI Plugins",description:"",content:""}),e.add({id:23,href:"/dev-reference/metadata-management/metadata-common/",title:"Metadata common",description:"",content:""}),e.add({id:24,href:"/dev-reference/metadata-management/metadata-common/navigate-metadata/",title:"Navigate metadata",description:"Metadata navigation pop-up # To swiftly navigate through your metadata within the builder, press the key combination ctrl + shift + f. This action will open the metadata navigation pop-up. Inside this pop-up, you&rsquo;ll encounter an input search box designed to seek out labels across all metadata in the application. The pop-up will then display a comprehensive list of matches found. Clicking on any of these search results will automatically redirect you to the view of the selected resource.",content:`Metadata navigation pop-up # To swiftly navigate through your metadata within the builder, press the key combination ctrl + shift + f. This action will open the metadata navigation pop-up. Inside this pop-up, you&rsquo;ll encounter an input search box designed to seek out labels across all metadata in the application. The pop-up will then display a comprehensive list of matches found. Clicking on any of these search results will automatically redirect you to the view of the selected resource.
✅ This feature proves incredibly handy for swiftly moving between various resources within your application. `}),e.add({id:25,href:"/extensions/migrations/official-ui-plugins/overview/",title:"Overview",description:`Here is the list of our officially-supported plugins:
Metamask Plaid Scandit Slaask Stripe `,content:`Here is the list of our officially-supported plugins:
Metamask Plaid Scandit Slaask Stripe `}),e.add({id:26,href:"/dev-reference/metadata-management/metadata-common/metadata-history/",title:"Metadata history",description:`Metadata changes # Review changes # To review the changes made to a specific metadata resource, follow these steps:
👉 Navigate to the particular resource through the navigation tree or employ the navigate metadata feature.
👉 Once the view of the resource is open in the central panel, you will spot a tools button in the header. Click on this button to reveal two potential actions: show history and find usages.`,content:`Metadata changes # Review changes # To review the changes made to a specific metadata resource, follow these steps:
👉 Navigate to the particular resource through the navigation tree or employ the navigate metadata feature.
👉 Once the view of the resource is open in the central panel, you will spot a tools button in the header. Click on this button to reveal two potential actions: show history and find usages.
👉 Select the show history option. This will open a history view in the central panel displaying the chronological record of changes associated with that specific resource.
History view # The history view comprises two primary sections:
Top Section: A table at the top that lists all the various changes made to the resource, organized by timestamp. Additional information such as the user, change type, and path of the metadata are also displayed. Clicking on any of these entries will unveil another table in the bottom section. Bottom Section (1st Tab): In this section, you can peruse a comprehensive list of every property altered during the selected timestamp. Bottom Section (2nd Tab): Switching to this tab, you can inspect an in-depth list of properties that have undergone automatic changes during the timestamp. These alterations are the outcome of platform-applied refactoring rules. For instance, creating a new field in an entity with existing record views will result in an automatic creation of the new field in those record views. `}),e.add({id:27,href:"/extensions/migrations/official-ui-plugins/metamask/",title:"Metamask",description:`This plugin allows users to sign transactions using the MetaMask browser extension.
Quick start # sys.ui.sendMessage({ scope: 'plugin:metamask', name: 'sendTransaction', data: {gas: ..., data: ..., ...}, // this is the tx data callbacks: { approved: function(msg, res) { sys.logs.debug(&quot;tx hash: &quot;+res.txHash); sys.logs.debug(&quot;original msg: &quot;+JSON.stringify(msg)); }, declined: function(msg, res) { sys.logs.debug(&quot;declined: &quot;+res.error); sys.logs.debug(&quot;original msg: &quot;+JSON.stringify(msg)); }, error: function(msg, res) { sys.logs.debug(&quot;error code: &quot;+res.errorCode); sys.logs.debug(&quot;error: &quot;+res.error); sys.logs.debug(&quot;original msg: &quot;+JSON.stringify(msg)); } } }); This script sends a transaction to MetaMask (in the data field) that needs to be confirmed by the user.`,content:`This plugin allows users to sign transactions using the MetaMask browser extension.
Quick start # sys.ui.sendMessage({ scope: 'plugin:metamask', name: 'sendTransaction', data: {gas: ..., data: ..., ...}, // this is the tx data callbacks: { approved: function(msg, res) { sys.logs.debug(&quot;tx hash: &quot;+res.txHash); sys.logs.debug(&quot;original msg: &quot;+JSON.stringify(msg)); }, declined: function(msg, res) { sys.logs.debug(&quot;declined: &quot;+res.error); sys.logs.debug(&quot;original msg: &quot;+JSON.stringify(msg)); }, error: function(msg, res) { sys.logs.debug(&quot;error code: &quot;+res.errorCode); sys.logs.debug(&quot;error: &quot;+res.error); sys.logs.debug(&quot;original msg: &quot;+JSON.stringify(msg)); } } }); This script sends a transaction to MetaMask (in the data field) that needs to be confirmed by the user. If the user confirms the transaction, the approved callback gets executed. Otherwise, if the user declines the transaction or there is an error, the declined callback is executed.
If there are other errors, the error callback will be called. For example, if the account is not configured in MetaMask, an 'invalidAccount' error will be returned, or 'invalidNetwork' if the network MetaMask is connected to is different from the network requested.
Configuration # There is no configuration required for this plugin. However, the app must be running in a browser with the MetaMask extension, and there must be an account logged in.
Inbound events # Send transaction # sys.ui.sendMessage({ scope: 'plugin:metamask', name: 'sendTransaction', data: {gas: ..., data: ..., ...}, // this is the tx data callbacks: { approved: function(msg, res) { sys.logs.debug(&quot;tx hash: &quot;+res.txHash); sys.logs.debug(&quot;original msg: &quot;+JSON.stringify(msg)); }, declined: function(msg, res) { sys.logs.debug(&quot;error: &quot;+res.error); sys.logs.debug(&quot;original msg: &quot;+JSON.stringify(msg)); } } }); Sends a transaction to be signed and sent to the network using the MetaMask plugin. The tx data should be in the &lsquo;data&rsquo; field (see eth.sendTransaction for more information), while you can pass two callbacks:
approved: the user approved the transaction, and it was submitted to the network. You should check the status of the transaction to see if it was confirmed. Parameter 'msg' contains the original message sent to the plugin (where you can add more fields if you need them in the callback) while 'res' contains the tx object and txHash. declined: the user didn&rsquo;t approve the transaction, or there was a problem, and the tx could not be submitted to the network. 'msg' contains the original message sent to the plugin, and you could find the error in 'res.error'. Additionally, there is an 'error' callback for handling account or network-related errors. These are the possible error codes:
'invalidAccount': if the account to sign the transaction is not configured in MetaMask. 'invalidNetwork': if the network MetaMask is connected to is different from the network requested. Sign data # sys.ui.sendMessage({ scope: 'plugin:metamask', name: 'signData', data: '0x000......', // this is the tx data callbacks: { approved: function(msg, res) { sys.logs.debug(&quot;signed: &quot;+res.signedData); sys.logs.debug(&quot;original msg: &quot;+JSON.stringify(msg)); }, declined: function(msg, res) { sys.logs.debug(&quot;error: &quot;+res.error); sys.logs.debug(&quot;original msg: &quot;+JSON.stringify(msg)); } } }); Signs data using the MetaMask plugin. The data to sign should be in the &lsquo;data&rsquo; field while you can pass two callbacks:
approved: the user approved the transaction, and it was signed. You can find the signed data in 'res.signedData'. declined: the user didn&rsquo;t approve the transaction, or there was a problem signing the data. You can find the error in &lsquo;res.error&rsquo;. There are also errors related to the account, and the possible error code is:
'invalidAccount': if the account to sign the transaction is not configured in MetaMask. Get config # sys.ui.sendMessage({ scope: 'plugin:metamask', name: 'getConfig', callbacks: { response: function(msg, res) { sys.logs.debug(&quot;config: &quot;+JSON.stringify(res)); sys.logs.debug(&quot;original msg: &quot;+JSON.stringify(msg)); } } }); Returns the configuration of MetaMask. This is useful if you want to check configured accounts or the network MetaMask is currently configured to. It supports the following callback:
response: the config is sent in the &lsquo;res&rsquo; parameter. This parameter has the following structure: { &quot;netId&quot;: 1, &quot;defaultAccount&quot;: &quot;0x1...&quot;, &quot;accounts&quot;: [&quot;0x1...&quot;, &quot;0x2...&quot;] } Outbound events # This plugin does not have outbound events.
`}),e.add({id:28,href:"/dev-reference/metadata-management/metadata-common/expressions/",title:"Building expressions",description:`Expressions in Slingr # Expressions in Slingr consist of sets of conditions that can be grouped using AND and OR operators. These expressions can be evaluated against a record, resulting in a true value if the record matches the expression, and false if it doesn&rsquo;t.
Moreover, these expressions can be easily translated into database queries, making them particularly useful when you need to retrieve all records that match a specific expression.`,content:`Expressions in Slingr # Expressions in Slingr consist of sets of conditions that can be grouped using AND and OR operators. These expressions can be evaluated against a record, resulting in a true value if the record matches the expression, and false if it doesn&rsquo;t.
Moreover, these expressions can be easily translated into database queries, making them particularly useful when you need to retrieve all records that match a specific expression.
While in many cases, expressions can be replaced by scripts (with that option being available when applicable), it is recommended to define your conditions using expressions for several reasons:
Maintainability: Expressions are automatically refactored whenever fields are modified, eliminating the need for manual adjustments in most instances. Usability: Expressions can be created using the UI, offering a more intuitive and user-friendly experience. Database queries: For many scenarios, expressions can be directly applied to the database. In cases where queries are necessary, you won&rsquo;t be able to use scripts (such as for access permissions). Expressions are associated with a target entity, which contains the records against which the expression is evaluated. They comprise a set of conditions that can be organized using AND and OR groups.
Each filter within an expression has the following attributes:
Target field: This refers to a field in the target entity that will be filtered, except in cases of By user value. Operator: Used to filter the field (available operators depend on the field type). Value: The filtering value, which can be hard-coded (By value or By user value), obtained from a field in a record (By record field), or taken from a field in the user extended fields record (By user field). Complex expressions can be built by combining groups and conditions. For instance, an example expression could look like this:
- AND - By value: type = 'a' - OR - By value: state = 'inactive' - By value: name like 'test' Expressions are a versatile concept used in various contexts within the app definition. Paying close attention to the context is essential to understand the target entity and the potential source entity (in conditions of type By record field).
For instance, consider the following scenarios:
In a By value condition for read/write access in an entity field, the target entity will be the entity housing the field. If the condition is of type By record field in the filter of a relationship field, the target entity will be the entity that the relationship points to, while the source entity will be the entity with the relationship field. Groups # AND # All elements within an AND group must evaluate to true for the group itself to evaluate to true. If one or more elements within the group evaluate to false, the entire group will be considered false. It&rsquo;s possible to have nested OR groups inside an AND group.
OR # For an OR group to evaluate to true, at least one element within the group must evaluate to true. If all elements within the group evaluate to false, the group will be evaluated as false. Similar to AND groups, it&rsquo;s possible to have nested AND groups inside an OR group.
Conditions # Conditions within expressions have the following structure:
Target Field - Operator - Value For example:
type - Equals - 'a' The different types of conditions are distinguished by how the \`Value\` is set. It can be: - Hard-coded (\`By value\` or \`By user value\`) - Obtained from a field in a record (\`By record field\`) - Obtained from a field in the user extended fields record (\`By user field\`) Understanding how these conditions work with multi-valued fields or many values is crucial.
When the target field is single-valued and there are multiple values, if any of the values match the value of the target field, the condition evaluates to true. When the target field is multi-valued and there&rsquo;s only one value, if that value matches any of the values of the target field, the condition evaluates to true. When the target field is multi-valued and there are multiple values, if any value matches any of the values in the target field, the condition evaluates to true. By value # In this condition type, the value is hard-coded. Depending on the selected operator, you can specify one or more values.
By record field # Here, the value is obtained from a field in a record (the Source field).
For instance, in configuring filters for a relationship field, you might filter records of the target entity based on the type field, which should equal the value of the companyType field in the source record. This dynamic filtering ensures that the results differ from record to record.
By user field # User conditions rely on the User extended fields feature, which must be enabled in the app before using this condition type.
In this case, the value is obtained from the field in the user extended record (the Source field) of the current user. Thus, these conditions work when there&rsquo;s a current user with an associated user extended fields record; otherwise, the condition evaluates to false.
For example, the companies field in the user extended fields entity could indicate the companies users work for. With a tasks entity featuring a company field, you could ensure that users only see tasks for companies they work for by applying a By user field condition in the permissions.
By user value # This filter combines the characteristics of By user field and By value. The value is hard-coded as By value, but the Target field belongs to an entity configured in the User extended fields.
Operators # The operation determines how the field is filtered. Available operations depend on the field type defined in field. Possible operations include:
equals: Equivalent to an any condition, tests if any element of the current value is in the filter value. notEquals: Equivalent to a not in condition, tests if the current value is not in the filter value. like: Similar to equals, but matches partial values. between: Specifies a range where the current value should lie. greater: Equivalent to the math operator for number types. greaterOrEquals: Equivalent to the math operator for number types. less: Equivalent to the math operator for number types. lessOrEquals: Equivalent to the math operator for number types. empty: The current value must be null or an empty list. notEmpty: The current value must not be null and not an empty list. Query format # Expressions can also be represented in query language, which is useful when passing expressions in scripts. For instance:
// this is a simple query expression where field 'company' should be equals to 'GOOGLE' { company: 'GOOGLE' } // this query expression is to filter by companies with 'type' in 'a' or 'b', // or with 'numberOfPeople' greater or equals to 100 { _or: { type: ['a', 'b'], numberOfPeople: 'greaterOrEquals(100)' } } // this query expression is to filter companies by the related company to the logged user { name: 'currentUserField(company.name)' } The way to map filters is by utilizing the field name and the value to filter for. Within the value section, an operation can be specified. The available operations are contingent on the field type defined in field. These include:
equals notEquals like between greater greaterOrEquals less lessOrEquals empty notEmpty currentUserField For a deeper understanding of the query language and the valid operators, please refer to the documentation on Complex Query Language.
`}),e.add({id:29,href:"/extensions/migrations/official-ui-plugins/plaid/",title:"Plaid Link",description:`Overview # Plaid Link is a drop-in module that provides a secure, elegant authentication flow for each institution that Plaid supports. Link makes it secure and easy for users to connect their bank accounts to Plaid.
Configuration # The following settings needs to be set:
Property Information Property Client name Displayed once a user has successfully linked their Item clientName. Product A list of Plaid product(s) you wish to use product Public key The public_key associated with your account key Environment The Plaid API environment on which to create user accounts.`,content:`Overview # Plaid Link is a drop-in module that provides a secure, elegant authentication flow for each institution that Plaid supports. Link makes it secure and easy for users to connect their bank accounts to Plaid.
Configuration # The following settings needs to be set:
Property Information Property Client name Displayed once a user has successfully linked their Item clientName. Product A list of Plaid product(s) you wish to use product Public key The public_key associated with your account key Environment The Plaid API environment on which to create user accounts. For Development and Sandbox, use development or sandbox, respectively. For Production use, use production. env Language Epecify a Plaid-supported language to localize Link. English will be used by default. language Country codes Optional. Specify a comma separated list of Plaid-supported country codes using the ISO-3166-1 alpha-2 country code standard. countryCodes User legal name Optional. Specify a userLegalName to enable all Auth features. Note that userEmailAddress must also be set. userEmailAddress User email address Optional. Specify a userEmailAddress to enable all Auth features. Note that userLegalName must also be set. userLegalName Link customization name Optional. Specify the name of a Link customization created in the Dashboard. The default customization is used if none is provided. linkCustomizationName Inbound events # Open Link dialog # sys.ui.sendMessage({ scope: 'plugin:plaid', name: 'open', data: { clientName: 'Client 1', key: 'public_key', product: ['transactions'], env: 'sandbox' }, callbacks: { onSuccess: function(originalMessage, callbackData) { sys.logs.debug(&quot;Here is the original message for onSuccess&quot;); sys.logs.debug(JSON.stringify(originalMessage)); sys.logs.debug(&quot;Here is the callback data for onSuccess&quot;); sys.logs.debug(JSON.stringify(callbackData)); }, onExit: function(originalMessage, callbackData) { sys.logs.debug(&quot;Here is the original message for onExit&quot;); sys.logs.debug(JSON.stringify(originalMessage)); sys.logs.debug(&quot;Here is the callback data for onExit&quot;); sys.logs.debug(JSON.stringify(callbackData)); }, onEvent: function(originalMessage, callbackData) { sys.logs.debug(&quot;Here is the original message for onEvent&quot;); sys.logs.debug(JSON.stringify(originalMessage)); sys.logs.debug(&quot;Here is the callback data for onEvent&quot;); sys.logs.debug(JSON.stringify(callbackData)); } } }); This script opens the dialog to perform bank authorization that allows end users to connect their bank accounts to Plaid.
In data you can override dynamically settings defined at creation time of the plugin.
The following callbacks can be defined:
onSuccess: A function that is called when a user has successfully signed up into an account. You will be receiving the public_token and a metadata object. onExit: A function that is called when a user has specifically exited the Link flow. You might receive the error and the metadata associated to it. onEvent: A function that is called when a user reaches certain points in the Link flow. You will receive the event name and the metadata associated to it. Outbound events # This plugin does not have outbound events.
`}),e.add({id:30,href:"/getting-started/getting/first-steps/event-planner/understanding/",title:"About - Event Planner",description:`In this comprehensive tutorial, we will be working with the default app provided to all Slingr developers - the &ldquo;Event Planner&rdquo; app. Our goal is to empower you with the full potential of Slingr and guide you through your initial steps with the platform. If you haven&rsquo;t created a Slingr account yet, you can easily create one here.
What is the &ldquo;Event Planner&rdquo; App? # The &ldquo;Event Planner&rdquo; app is a powerful application that comes pre-built with your new Slingr account.`,content:`In this comprehensive tutorial, we will be working with the default app provided to all Slingr developers - the &ldquo;Event Planner&rdquo; app. Our goal is to empower you with the full potential of Slingr and guide you through your initial steps with the platform. If you haven&rsquo;t created a Slingr account yet, you can easily create one here.
What is the &ldquo;Event Planner&rdquo; App? # The &ldquo;Event Planner&rdquo; app is a powerful application that comes pre-built with your new Slingr account. It serves as an excellent starting point for new users, showcasing the capabilities of the Slingr platform. In this tutorial, we will enhance the functionality of the &ldquo;Event Planner&rdquo; app step by step.
App Features # The Event Planner app is tailored to assist companies in organizing events effectively. It offers a rich set of features, including:
Event Management: Create, edit, and delete events, all viewable in either a table or a calendar format, providing you with a comprehensive overview.
Tasks Management: Enjoy the convenience of a To-Do board that aids your staff in organizing their tasks for each event, ensuring nothing is overlooked.
Services Management: A dedicated section to upload and manage services that can be utilized across all your events, streamlining your planning process.
Administration Features: Empowering you with administrative capabilities, allowing the smooth upload of customer and staff data, ensuring your team stays organized.
Metrics and Insights: Gain valuable insights and metrics about past events and customers, enabling you to make data-driven decisions and improve future events.
Excited to Get Started? # We&rsquo;re thrilled to embark on this journey with you to enhance the &ldquo;Event Planner&rdquo; app together! Let&rsquo;s dive into the next section where we&rsquo;ll make the first set of exciting changes to our app.
Next Section: First Changes
With your dedication and our guidance, the &ldquo;Event Planner&rdquo; app will become even more remarkable! Let&rsquo;s get started!
`}),e.add({id:31,href:"/dev-reference/metadata-management/metadata-common/data-events/",title:"Data events",description:`You can define multiple rules. If at least one rule matches the event, the event will be considered matched.
All rules are applied to a single entity, indicated in the Entity field.
Each rule includes the following settings:
Event Types # This represents the type of event the rule will match. Possible values include:
On Record Created: Triggered when a record is created. On Record Changed: Triggered when a record is updated.`,content:`You can define multiple rules. If at least one rule matches the event, the event will be considered matched.
All rules are applied to a single entity, indicated in the Entity field.
Each rule includes the following settings:
Event Types # This represents the type of event the rule will match. Possible values include:
On Record Created: Triggered when a record is created. On Record Changed: Triggered when a record is updated. Keep in mind that a record can be updated by various means, such as through the UI, an external app via the REST API, a background script, etc. Be cautious, as any change to the record triggers this event. On Record Deleted: Triggered when a record is deleted. On Action Performed: Triggered when an action is executed on a record. On Condition Met: Triggered when a record is changed in a way that satisfies the specified condition (see below), and this condition wasn&rsquo;t met before the record update. For instance, if the condition is that the type field must be a, when a record is updated and the type field changes from a different value to a, the event will be matched. However, if the record already had a in the type field, and it&rsquo;s updated without changing the value, the event won&rsquo;t be matched because the condition was already met in the previous version of the record. Condition # In addition to the event, you can define a set of conditions that must be met for the event to match. Options include:
None: No conditions, so as long as the event is triggered, the rule will match. Expression: Define an expression that must evaluate to true for the event to match. For more information, refer to the Expressions Documentation. Script: Provide a script that must evaluate to true for the event to match. Please replace the corresponding sections in your documentation with this corrected version. This is the context: Parameters # Name Type Description record sys.data.Record This is the current record affected by the event. oldRecord sys.data.Record If the event is of type On record change, On action performed or On condition met, this variable will hold the version of the record before the event happened. Returns # boolean - Return true to execute the action, and false otherwise.
Samples # // only match the event if the field 'type' was modifed return record.field('type').val() != oldRecord.field('type').val(); Actions # If the Event is set to On Action Performed, you can select a list of actions that can be matched.
Please note that only actions of type One Record can be chosen. Actions of type Many Records are not tied to any specific record and therefore cannot be used in this context.
`}),e.add({id:32,href:"/extensions/migrations/official-ui-plugins/scandit/",title:"Scandit",description:`Overview # Scandit is mobile computer vision software enables barcode scanning.
Configuration # The following settings needs to be set:
Check SDK documentation for more information.
License key # Before starting with adding a capture mode, make sure that you have a valid Scandit Data Capture SDK license key and that you added the necessary dependencies. If you have not done that yet, check out this guide. The web license is required.`,content:`Overview # Scandit is mobile computer vision software enables barcode scanning.
Configuration # The following settings needs to be set:
Check SDK documentation for more information.
License key # Before starting with adding a capture mode, make sure that you have a valid Scandit Data Capture SDK license key and that you added the necessary dependencies. If you have not done that yet, check out this guide. The web license is required.
Scan settings # Key Type Default value Info codeDuplicateFilter number 0 The duplicate filter specifying how often a code can be scanned. When the filter is set to -1, each unique code is only scanned once. When set to 0, duplicate filtering is disabled. Otherwise the duplicate filter specifies an interval in milliseconds. When the same code (data/symbology) is scanned within the specified interval it is filtered out as a duplicate. enabledSymbologies array [&ldquo;ean13&rdquo;, &ldquo;upca&rdquo;, &ldquo;upce&rdquo;, &ldquo;code128&rdquo;, &ldquo;code39&rdquo;, &ldquo;data-matrix&rdquo;, &ldquo;qr&rdquo;] The single symbology or list/set of symbologies that should be initialized as enabled for recognition. maxNumberOfCodesPerFrame number 1 The maximum number of barcodes to be recognized every frame. searchArea object - The area of the image in which barcodes are searched. colorInvertedEnabled boolean false Whether color-inverted decoding for all symbologies is enabled. Modal settings # modalSettings Name Key Type Possible values Default value Close after scan closeAfterScan boolean - false Size size number - 80 Position position string top | bottom top Margin top marginTop number - 50 Margin bottom marginBottom number - 50 Alignment alignment string left | center | right center Margin left marginLeft number - 50 Margin right marginRight number - 50 Play sound on scan playSoundOnScan boolean - true Vibrate on scan vibrateOnScan boolean - true Inbound events # Send Messages from Custom views # sys.ui.sendPluginMessage({ plugin: 'scandit', name: 'openScan', data: { field: 'firstName', scanSettings: { codeDuplicateFilter: 0, enabledSymbologies: [&quot;ean13&quot;, &quot;upca&quot;, &quot;upce&quot;, &quot;code128&quot;, &quot;code39&quot;, &quot;data-matrix&quot;, &quot;qr&quot;], maxNumberOfCodesPerFrame: 1, searchArea: {height: 1, width: 1, x: 0, y: 0} }, modalSettings: { size: 50, marginTop: 30, position: 'top', alignment: 'right', marginRight: 30, closeAfterScan: true, playSoundOnScan: true, vibrateOnScan: true } }, callbacks: { onScan: function(originalMessage, callbackData) { console.info(&quot;&gt;&gt; code: &quot;, callbackData.code); console.info(&quot;&gt;&gt; callbackData: &quot;, callbackData); }, onFail: function(originalMessage, callbackData) { console.info(&quot;&gt;&gt;&quot;, callbackData); } } }); Send UI messages # sys.ui.sendMessage({ scope: 'plugin:scandit', name: 'openScan', data: { field: 'firstName', scanSettings: { codeDuplicateFilter: 0, enabledSymbologies: [&quot;ean13&quot;, &quot;upca&quot;, &quot;upce&quot;, &quot;code128&quot;, &quot;code39&quot;, &quot;data-matrix&quot;, &quot;qr&quot;], maxNumberOfCodesPerFrame: 1, searchArea: {height: 1, width: 1, x: 0, y: 0} }, modalSettings: { size: 50, marginTop: 30, position: 'top', alignment: 'right', marginRight: 30, closeAfterScan: true, playSoundOnScan: true, vibrateOnScan: true } }, callbacks: { onScan: function(originalMessage, callbackData) { sys.logs.info(&quot;&gt;&gt; code: &quot;, callbackData.code); sys.logs.info(&quot;&gt;&gt; callbackData: &quot;, callbackData); }, onFail: function(originalMessage, callbackData) { sys.logs.info(&quot;&gt;&gt;&quot;, callbackData); } } }); This script opens the modal scan.
In data you can override dynamically settings defined at creation time of the plugin.
The following callbacks can be defined:
callback: A function that is called scan successfully. Outbound events # Outbound events send context as ui if it&rsquo;s called from UI messages otherwise is plugin.
onScanSuccess: Event when scan success.
onScanFail: Event when scan fails.
`}),e.add({id:33,href:"/platform-ref/slingr-platform/",title:"Slingr platform",description:"",content:""}),e.add({id:34,href:"/dev-reference/metadata-management/pushing-and-syncing/",title:"Pushing and syncing changes",description:`As described in the Overview, the configuration of your data model, business rules, scripts, views, permissions, etc., is collectively referred to as the metadata of your app.
To make changes to the metadata, you must use the app builder, which is accessible only in the development and staging environments. The production environment does not allow direct changes; instead, you need to synchronize changes (see below). However, you can adjust environment settings from the app monitor to customize behavior (more on environment settings below).`,content:`As described in the Overview, the configuration of your data model, business rules, scripts, views, permissions, etc., is collectively referred to as the metadata of your app.
To make changes to the metadata, you must use the app builder, which is accessible only in the development and staging environments. The production environment does not allow direct changes; instead, you need to synchronize changes (see below). However, you can adjust environment settings from the app monitor to customize behavior (more on environment settings below).
Next, we will outline the process for implementing changes to your apps and synchronizing those changes to the production environment.
Making changes to your app # You can modify your app&rsquo;s metadata through the app builder. Here, you can view your app&rsquo;s definition and implement necessary changes. Note that these changes won&rsquo;t take effect immediately; they need to be pushed to the app runtime, where they will be applied. For instance, if you add a new field using the app builder, you won&rsquo;t see it in the app immediately after saving. First, you need to push the changes, and once this is done, the new field will appear in the app runtime of the development environment.
You can push changes from the app builder using the Push changes action in the secondary menu (a shortcut is also available with Ctrl + P). When changes are pushed, you&rsquo;ll see a summary of the changes that will be pushed, and you&rsquo;ll have the option to create a backup and provide an explanation for the changes.
Enabling the backup flag creates a version that can be restored later. Typically, you wouldn&rsquo;t create a backup with every push; rather, you&rsquo;d do so when you need a restore point.
Importantly, understand the impact of pushing changes:
The app will be halted in the development environment (production remains unaffected). Metadata changes are transferred to the app runtime. If metadata changes affect data, necessary data adjustments are made. For instance, if a field is deleted, all records of that entity will be updated to remove the field. Changes to legacy services are deployed, removed, or redeployed. The app is restarted. Synchronizing changes to production # Once you&rsquo;ve tested all changes in the development environment, if you have a production environment in your app, you can sync these changes from development to production.
From the app builder, use the Sync changes to prod action in the secondary menu to synchronize changes. During this process, you&rsquo;ll see a summary of the changes that will be moved to production. It&rsquo;s important to note that only changes that have been pushed will be synced. Any changes made in the app builder but not yet pushed won&rsquo;t be synchronized.
When syncing changes, the following steps occur:
App metadata is exported from the development environment. The production environment is halted. App metadata is imported into the production environment. Data refactorings are carried out. Legacy services are synchronized. The production app is restarted. Depending on the nature of changes and any required data refactorings, this process might take some time. Ensure you understand the implications of potential data refactorings (see Automatic Refactorings) and sync changes at a time that minimally impacts operations.
Additionally, keep in mind that if your app is linked to others, changes will also be synced across linked apps, following the same process described above.
Automated Issue Resolution # Before initiating the sync process, the application metadata undergoes validation. If validation uncovers errors, a tool to automatically resolve these issues will be available.
Incorporating a staging environment # A staging environment can be added as an intermediary between development and production. Some use cases include:
Hotfixes: Your staging environment can mirror your production version. In the event of a production issue, you can fix it in staging and then sync the fix to production, avoiding unintended changes from development. QA: After completing a development iteration, instead of syncing directly to production, you can sync to staging, perform regression testing, and then sync to production once testing is complete. When a staging environment is present, changes made in development are synced to staging first, and then you can proceed to sync them to production.
Pulling Changes # The pull process involves two stages:
Fetch Changes: Obtain changes from the source environment you want to merge with. Merge Changes: Apply changes from the source environment into your development environment. The source could be staging or a parent app. If changes are made in the staging environment, you won&rsquo;t be able to directly sync changes from development to staging. Instead, you need to first pull changes from staging. This requires accessing the app builder in your development environment and executing the Pull changes action from the secondary menu.
This operation merges changes from staging into the development environment, allowing you to subsequently sync them to staging.
Pulling changes in linked apps # For apps created from a template with the Linked flag set, updates from the master app are received automatically. However, if you&rsquo;ve added a development environment to your linked app, changes in the master app won&rsquo;t be applied automatically to production. Instead, you&rsquo;ll need to go to your development environment and pull the changes made in the template.
This step is necessary to handle potential conflicts between changes in the master app and your linked app. After pulling changes, you can then incorporate them into your app.
Environment settings # You may have noticed that there is no app builder available in the production environment. This is because making direct changes in the production environment is discouraged. Changes should be made in the development or staging environment, tested, and then synced to production.
However, your production environment might require slightly different behavior than your development or staging environments. This could involve using a different API key, an alternative alerts policy, or even a distinct theme for easy differentiation between production and development.
This is where environment settings come into play. These settings can be customized per environment and, combined with metadata, influence how your app operates.
You can modify environment settings from the app builder in the development or staging environment. For the production environment, these settings can be adjusted using the app monitor.
For more information on different environment settings, refer to the following documentation:
Environment Variables UI Settings Logs and Alerts Localization `}),e.add({id:35,href:"/extensions/migrations/official-ui-plugins/slaask/",title:"Slaask",description:`Overview # This plugins allows to add the Slaask bot in your app.
Quick start # You just need to configure the plugin and the Slaask bot will show up in your app.
Configuration # First you will need to have a Slaask account. Then you can add the plugin and configure it.
Token # This token is the one in your Slaask account.
Inbound events # This plugin does not have inbound event.`,content:`Overview # This plugins allows to add the Slaask bot in your app.
Quick start # You just need to configure the plugin and the Slaask bot will show up in your app.
Configuration # First you will need to have a Slaask account. Then you can add the plugin and configure it.
Token # This token is the one in your Slaask account.
Inbound events # This plugin does not have inbound event.
Outbound events # This plugin does not have outbound events.
`}),e.add({id:36,href:"/dev-reference/metadata-management/automatic-refactorings/",title:"Automatic refactorings",description:`As detailed in the Development Process, Slingr simplifies the adoption of agile methodologies for app development. Automatic refactorings are an instrumental feature in this regard, greatly facilitating the evolution of your app.
When you introduce changes to your app, we strive to propagate these changes systematically, minimizing the need for manual adjustments across multiple areas. The following are examples of automatic refactorings:
Field Addition: If you add a new field to an entity, the field will be automatically integrated into all managed views.`,content:`As detailed in the Development Process, Slingr simplifies the adoption of agile methodologies for app development. Automatic refactorings are an instrumental feature in this regard, greatly facilitating the evolution of your app.
When you introduce changes to your app, we strive to propagate these changes systematically, minimizing the need for manual adjustments across multiple areas. The following are examples of automatic refactorings:
Field Addition: If you add a new field to an entity, the field will be automatically integrated into all managed views. Field Deletion: When a field is deleted, it will be seamlessly removed from all views and actions. Field Renaming: Should you rename a field, the change will be applied universally, including the database. Field Sorting: Sorting fields within an entity will trigger the same sorting in managed views. The primary objective of these automatic refactorings is to expedite development by reducing the need for manual adjustments.
It&rsquo;s essential to note that not all aspects can be refactored automatically. For instance, scripts are not currently included in these automatic refactorings, although this is on our roadmap for future development.
Refactorings can be classified into two categories: metadata refactorings and data refactorings, which are elucidated further in the subsequent sections.
Metadata refactorings # Metadata refactorings encompass changes that exclusively influence the metadata of the app. For instance, if fields are reordered within an entity, managed views will be automatically adjusted to match the new field order.
These refactorings take effect immediately after changes are made in the app builder (although they won&rsquo;t be visible until changes are pushed). Following the aforementioned example, once the fields are reordered, the views will be automatically reconfigured. Consequently, upon opening the views in the app builder, the new field arrangement will be evident.
Data refactorings # Conversely, data refactorings result in modifications to the app&rsquo;s data. For example, if an entity is deleted, all records associated with that entity will be purged from the database.
Since changes are only accessible at runtime, data refactorings occur during the process of pushing or synchronizing changes.
It&rsquo;s crucial to be aware that certain changes can trigger both metadata and data refactorings simultaneously. Deleting a field, for instance, will prompt the refactoring of metadata references to that field, as well as the adjustment of records to remove the deleted field.
Here is a list of changes that trigger data refactorings:
Adding a required field with a default value Introducing a calculated field Renaming a field (changing the name, not the label) Deleting a field Modifying copied fields within a relationship field Adjustments to type rules that impact stored data Altering field calculation logic Deleting an entity Renaming an entity Setting a field as unique or indexable (leading to index creation) Removing the unique or indexable flag from a field (resulting in index removal) Adding, modifying, or removing an index If these changes are applied to entities with substantial record counts, be aware that the process may take some time and your app will be temporarily unavailable during this period.
`}),e.add({id:37,href:"/extensions/migrations/official-ui-plugins/stripe/",title:"Stripe",description:`Overview # The primary integration path through Stripe.js is with Elements, which enables you to collect sensitive payment information using UI components.
Configuration # This plugins allows to add the Stripe elements in your app.
Inbound events # Collect payment information # Collect card information on the client with Stripe.
var setupIntent = app.endpoints.stripe.coreResources.setupIntents.post(); var publicKey = app.endpoints.stripe._configuration.publishableKey; sys.ui.sendMessage({ scope: 'plugin:stripe', name: 'collectPaymentInformation', data: { publicKey: publicKey, title: 'Card Information', dataSecret: setupIntent, elementType: 'card', elementOptions: null }, callbacks: { onSuccess: function(originalMessage, callbackData) { sys.`,content:`Overview # The primary integration path through Stripe.js is with Elements, which enables you to collect sensitive payment information using UI components.
Configuration # This plugins allows to add the Stripe elements in your app.
Inbound events # Collect payment information # Collect card information on the client with Stripe.
var setupIntent = app.endpoints.stripe.coreResources.setupIntents.post(); var publicKey = app.endpoints.stripe._configuration.publishableKey; sys.ui.sendMessage({ scope: 'plugin:stripe', name: 'collectPaymentInformation', data: { publicKey: publicKey, title: 'Card Information', dataSecret: setupIntent, elementType: 'card', elementOptions: null }, callbacks: { onSuccess: function(originalMessage, callbackData) { sys.logs.debug(&quot;Here is the original message for onSuccess&quot;); sys.logs.debug(JSON.stringify(originalMessage)); sys.logs.debug(&quot;Here is the callback data for onSuccess&quot;); sys.logs.debug(JSON.stringify(callbackData)); }, onFail: function(originalMessage, callbackData) { sys.logs.debug(&quot;Here is the original message for onFail&quot;); sys.logs.debug(JSON.stringify(originalMessage)); sys.logs.debug(&quot;Here is the callback data for onFail&quot;); sys.logs.debug(JSON.stringify(callbackData)); } } }); This script opens the a modal to collect the payment information.
publickKey The public key can be generated in the dashboard of your Stripe app.
title The title to be displayed in modal header.
dataSecret is an object that represents your intent to set up a customer’s card for future payments.
elementType The type of element you are creating.
elementOptions Options for updating given type element.
The following callbacks can be defined:
onSuccess: The PaymentMethod was successfully setup.
onFail: Error when try to setup a PaymentMethod.
Handle card action # Handle Card Action is manual confirmation flow to handle a PaymentIntent with the requires action status. It will throw an error if the PaymentIntent has a different status.
var clientSecret = '....'; sys.ui.sendMessage({ scope: 'plugin:stripe', name: 'handleCardAction', data: { publicKey: publicKey, clientSecret: clientSecret }, callbacks: { cardActionCallback: function(originalMessage, callbackData) { sys.logs.debug(&quot;Here is the original message for cardActionCallback&quot;); sys.logs.debug(JSON.stringify(originalMessage)); sys.logs.debug(&quot;Here is the callback data for cardActionCallback&quot;); sys.logs.debug(JSON.stringify(callbackData)); } } }); publickKey The public key can be generated in the dashboard of your Stripe app.
clientSecret The client secret of the PaymentIntent to handle.
The following callbacks can be defined:
onSuccess: The message with result object:
result.paymentIntent: a PaymentIntent with the requires_confirmation status to confirm server-side. result.error: an error. Refer to the API reference for all possible errors. Outbound events # This plugin does not have outbound events.
`}),e.add({id:38,href:"/dev-reference/app/",title:"App",description:"",content:""}),e.add({id:39,href:"/dev-reference/app/settings/",title:"App settings",description:`These are global settings of the app found in the app builder under App &gt; Settings.
Notifications # In this section, you can customize notifications for welcome and password reset emails.
Customize welcome email # If this flag is set, you will be able to customize the template that will be used to build emails sent to users when they sign up for the app (keep in mind that notifications could be avoided).`,content:`These are global settings of the app found in the app builder under App &gt; Settings.
Notifications # In this section, you can customize notifications for welcome and password reset emails.
Customize welcome email # If this flag is set, you will be able to customize the template that will be used to build emails sent to users when they sign up for the app (keep in mind that notifications could be avoided).
The template is essentially an HTML file that supports Freemarker directives, and you have the following variables available in the template:
appLabel: the label of the app. appUrl: URL to the app runtime. firstName: the first name of the user who signed up. lastName: the last name of the user who signed up. fullName: the full name of the user who signed up. email: the email address of the user who signed up. plainPassword: this is the password generated for the user. This password is temporary. Using the Freemarker syntax, you can merge these variables into the template like this:
&lt;h3&gt;Welcome \${fullName}!&lt;/h3&gt; &lt;p&gt;To login to \${appLabel} go to \${appUrl} and login with your credentials.&lt;/p&gt; Additionally, you can configure the From name, which is the sender&rsquo;s name users will see in their email clients.
Customize password reset email # If this flag is set, you will be able to customize the template that will be used to build emails sent to users when they reset their password.
The template is basically an HTML file that supports Freemarker directives, and you have the following variables available in the template:
appLabel: the label of the app. appUrl: URL to the app runtime. firstName: first name of the user who signed up. lastName: last name of the user who signed up. fullName: full name of the user who signed up. email: the email of the user who signed up. plainPassword: this is the password generated for the user. This password is temporary. Using Freemarker syntax, you can merge these variables in the template like this:
&lt;h3&gt;Hi \${fullName}!&lt;/h3&gt; &lt;p&gt;Your password has been reset to \${plainPassword}. This is a temporal password you can use to login at \${appUrl}&lt;/p&gt; Furthermore, you have the option to configure the From name, which dictates the sender&rsquo;s name that users will observe in their email clients.
Other settings # Initialization script # An initialization script is executed during the start-up process and after each cache clearance in the runtime. This script has access to the entire JS API; however, it operates independently (calling functions defined here is not possible).
The primary purpose of this feature is to enable the invocation of functions during the initialization of the metadata process in the runtime. For more comprehensive information on scripting using our API, refer to this resource.
`}),e.add({id:40,href:"/extensions/migrations/extending-platform/",title:"Extending the platform ",description:"",content:""}),e.add({id:41,href:"/extensions/migrations/extending-platform/create_your_own/",title:"Create your own legacy services",description:`You have the ability to create your own custom endpoints and seamlessly integrate them into your apps, enhancing the capabilities of Slingr according to your specific requirements. This is particularly useful for integrating with applications not covered by the official endpoints, utilizing existing libraries, and more.
The process of creating a new endpoint involves three fundamental steps:
Endpoint Creation: Design and set up your new endpoint. Testing via Proxy Endpoint: Thoroughly test your endpoint using the proxy endpoint.`,content:`You have the ability to create your own custom endpoints and seamlessly integrate them into your apps, enhancing the capabilities of Slingr according to your specific requirements. This is particularly useful for integrating with applications not covered by the official endpoints, utilizing existing libraries, and more.
The process of creating a new endpoint involves three fundamental steps:
Endpoint Creation: Design and set up your new endpoint. Testing via Proxy Endpoint: Thoroughly test your endpoint using the proxy endpoint. Endpoint Registration: Register your developed endpoint within the Slingr developer portal. Endpoint creation # To get started, you need to create a new endpoint. We recommend following one of these guides based on your preferred programming language:
Java SDK Node SDK Testing via proxy endpoint # Overview # For developing and testing your custom endpoints, there&rsquo;s a dedicated endpoint designed to assist you—the Proxy Endpoint:
When you initiate the creation of a new endpoint in the app builder, you will find the option for the Proxy Endpoint in the list of available endpoints. This particular endpoint is designed to proxy the one running on your local machine, as depicted in the diagram above.
Please be aware that communication between the proxy endpoint and your local endpoint might occur over HTTP instead of HTTPS. In such cases, refrain from transmitting sensitive information to ensure security. Proxy purposes # The proxy endpoint serves the following purposes:
When your app invokes a function on the endpoint&rsquo;s API, the proxy endpoint initiates a call to your local endpoint. This local endpoint then processes the request and forwards the response back to the proxy endpoint. Whenever an event occurs in your local endpoint, it is transmitted to the proxy endpoint, which subsequently relays it to your app. Upon loading the metadata of the endpoint (such as the endpoint.json definition file), the app retrieves this information from your locally running endpoint. This setup enables you to run and test your endpoint locally, facilitate debugging, and observe its behavior within your app ecosystem, all without any additional requirements.
For a comprehensive understanding of the proxy endpoint&rsquo;s functionality, refer to the documentation page.
Endpoint registration # Once your endpoint implementation is complete, it&rsquo;s essential to register it on the platform to make it accessible to your apps. Alternatively, you can choose to make it publicly available for others to use.
Within the Developer Portal and under the Endpoints section, developers can view and manage the endpoints under their purview. This section allows you to register new endpoints, update existing ones, or disable them as needed.
When registering a new endpoint, you&rsquo;ll need to provide the following information:
Label: A user-friendly name for the endpoint. Name: A unique name for the endpoint, which must match the name used in the endpoint.json definition file. Note that the name cannot be modified later. Repository: The Git URL of the repository containing the endpoint&rsquo;s code. The repository must be public. If it&rsquo;s private, we currently support only GitHub repositories, and you&rsquo;ll need to grant read access to the user slingr-builder. The URL should be in SSH format, like git@github.com:workspace_id/repo_name.git. Folder: Optional field for specifying the location of the endpoint within a specific folder. Type: Choose between Java and Node.js to indicate the endpoint&rsquo;s programming language. Visibility: Select either private or public. For public visibility, any app can utilize the endpoint. For private visibility, you can specify which apps can access the endpoint. Upon registration, the endpoint is associated with the developer who registers it. However, if necessary, ownership of the endpoint can be transferred to another account using a tool available in the endpoint editing section.
After registration, the platform will automatically detect new versions of the endpoint (identified by tags with the format v1.15.1, for example). These versions are visible when viewing endpoint details, where you can perform version management tasks:
Trigger a search for new versions: Refreshes the list of available versions for the endpoint. Build a specific version: Initiates the build process for a particular version. Set a version as the latest/default: Designates a specific version as the latest or default choice. Additionally, you can change the endpoint&rsquo;s icon within its details. The icon should be in PNG format and have a size of 48x48px.
Please note that endpoints cannot be deleted; however, you can disable them, preventing their usage in any app.
Summary # To summarize, here&rsquo;s what you need to start developing your endpoint:
Begin by creating your local endpoint using either the Java SDK or the Node SDK. Next, create a proxy endpoint in your app. Configure the proxy endpoint to connect both to your local endpoint and vice versa. Develop, utilize, and test your endpoint within your app! Explore the available options for your endpoints here. Once it&rsquo;s functioning effectively, register it and generate a version of your endpoint. Integrate your endpoint into your apps! `}),e.add({id:42,href:"/dev-reference/app/global-type/",title:"Global settings",description:`In the app builder, under the App &gt; Types section, you have the capability to employ predefined type rules and display options. This proves advantageous when you wish to maintain a consistent configuration across multiple fields in the app while managing it centrally in a single location.
By default, upon creating a new app, default display options are generated for all types. Consequently, when you create a new field, the type display options for that field are automatically configured to reference the default type display options.`,content:`In the app builder, under the App &gt; Types section, you have the capability to employ predefined type rules and display options. This proves advantageous when you wish to maintain a consistent configuration across multiple fields in the app while managing it centrally in a single location.
By default, upon creating a new app, default display options are generated for all types. Consequently, when you create a new field, the type display options for that field are automatically configured to reference the default type display options. This approach permits subsequent modifications to the display options of all fields in one central location.
For instance, consider a scenario where your app incorporates numerous date-type fields. You decide to display the date in a distinct format. If all date fields&rsquo; display options reference the global defaults, altering the format in a single location suffices, as opposed to navigating field by field for adjustments.
It&rsquo;s worth noting that no default rules are established for type rules by default. Generally, sharing rules across all fields in the app isn&rsquo;t the norm.
Refer to the configuration of type rules and display options within fields to understand how you can link to the predefined configurations established here.
In the event that you delete a predefined configuration that is in use by other fields, the configuration for those fields will transition to Custom. Although the settings will persist, they will no longer be interconnected.
`}),e.add({id:43,href:"/extensions/migrations/extending-platform/common/",title:"Common features",description:`👉 Endpoints, whether they are implemented in Java, Node.js, or another technology, share common elements such as:
- Descriptor File - Basic Settings - Deployment Settings - Stores - Functions - Events - Configuration - Scripts - Listeners - Flow Steps Descriptor file settings # The descriptor file, named endpoint.json, should be located at the root of your project. It contains the definition of your endpoint, including details like the name, type of endpoint, resources, functions, events, and configuration.`,content:`👉 Endpoints, whether they are implemented in Java, Node.js, or another technology, share common elements such as:
- Descriptor File - Basic Settings - Deployment Settings - Stores - Functions - Events - Configuration - Scripts - Listeners - Flow Steps Descriptor file settings # The descriptor file, named endpoint.json, should be located at the root of your project. It contains the definition of your endpoint, including details like the name, type of endpoint, resources, functions, events, and configuration.
Basic settings # ... &quot;label&quot;: &quot;Sample&quot;, &quot;name&quot;: &quot;sample&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;configurationType&quot;: &quot;GLOBAL&quot;, &quot;configurationHelpUrl&quot;: &quot;https://slingr-stack.github.io/platform/app_development_model_endpoints.html&quot;, ... These settings form the foundation of the endpoint configuration. Below, you&rsquo;ll find a comprehensive explanation of each setting:
label: This represents the visible name assigned to the endpoint. name: The internal identifier of the endpoint, determining its endpoint type. Typically in lowercase with hyphens. apiVersion: Specifies the API version for communication with the Slingr Platform. Currently, the only valid value is v1. configurationType: Indicates whether the configuration applies per app or at the user-level. The following options are available: GLOBAL: Select this option if the endpoint configuration is exclusive to the app level (within the app builder). PER_USER: Opt for this option if, in addition to the global configuration, each user requires specific settings to establish a connection to the endpoint. For instance, this scenario applies to the Google Calendar endpoint, where users need to authorize the endpoint individually using OAuth. configurationHelpUrl: An optional URL providing documentation related to endpoint configuration. Deployment settings # ... &quot;deployment&quot;: { &quot;profiles&quot;:[ { &quot;name&quot;: &quot;default&quot;, &quot;label&quot;: &quot;Default&quot;, &quot;memory&quot;: 512, &quot;offHeapMinFactor&quot;: 1.5, &quot;description&quot;: &quot;Default configuration&quot; } ], &quot;type&quot;: &quot;java&quot;, &quot;allowMultipleInstances&quot;: true }, ... The deployment section allows you to adjust technical options for running the component.
Within this section, you can define different profiles for a single endpoint. Essentially, a profile determines the memory allocation for the endpoint (with CPU adjustment happening automatically). The following settings are available for each profile:
name: The internal name of the endpoint. It must not contain spaces or special characters. label: The visible name of the profile, displayed to users in the app builder. memory: The amount of memory required by the endpoint. This represents the total memory utilized by the process. offHeapMinFactor (optional, exclusive to Java endpoints): This indicates the factor for non-heap memory allocation. If your endpoint requires more native memory, you might need to increase this value. The default value is at a minimum of 1. description: A description of the profile shown to developers. It should provide useful information to aid in selecting the appropriate profile. In addition to these settings, there are other configuration options available for the endpoint&rsquo;s deployment:
allowMultipleInstances: This can be set to true or false. When set to true, multiple instances of the endpoint can be configured. Requests will be distributed among instances, so the endpoint should not maintain any instance-specific state. For greater reliability, consider setting this to false, enabling it only when scaling is necessary and when instance statelessness is ensured. type: Indicates the technology used for the endpoint. This information enables the platform to perform the appropriate build for the endpoint. Possible values include: java, java8, java11, and nodejs. Descriptor file stores # ... &quot;stores&quot;: [ { &quot;name&quot;: &quot;test_data_store&quot;, &quot;indexes&quot;: [ {&quot;fieldA&quot;: 1}, {&quot;fieldB&quot;: 1, &quot;fieldC&quot;: -1} ] } ], ... If your endpoint needs to store data persistently, you will need to define &ldquo;stores.&rdquo; In these stores, you can save JSON documents, search for them using keys, update, or remove them. It&rsquo;s similar to a simple database that you can utilize within your endpoints.
For each store, you need to define the following settings:
name: the name of the store. It cannot contain spaces or special characters. indexes: if the store is going to contain many documents, it&rsquo;s beneficial to add indexes to optimize how you access the data. You can define several indexes. For each index, you need to specify the field(s) included in the index and the direction. Use 1 for ascending and -1 for descending. Descriptor file functions # ... &quot;functions&quot;: [ { &quot;label&quot;: &quot;Random number generator&quot;, &quot;name&quot;: &quot;randomNumber&quot;, &quot;description&quot;: &quot;Generates a random integer&quot; }, { &quot;label&quot;: &quot;Ping&quot;, &quot;name&quot;: &quot;ping&quot;, &quot;description&quot;: &quot;The service returns the sent value for the Pong event&quot;, &quot;callbacks&quot;: [ { &quot;name&quot;: &quot;pong&quot;, &quot;maxWaitingTime&quot;: 60000, &quot;maxExpectedResponses&quot;: 1 } ] }, ... ], ... Functions are fundamental for interacting with endpoints, as they can be invoked from the app using scripts. A set of parameters is sent to the function, which is then received by the endpoint. The function can return a result. For more detailed information on how functions work, refer to the documentation.
In this scenario, you do not need to specify any parameters explicitly. The function&rsquo;s implementation will receive a JSON and should utilize the necessary parameters.
Here are the settings for a function:
label: This is the human-friendly name of the function.
name: The function&rsquo;s name. This name will be used to call the function and must match the name defined in your implementation.
description: A description of the function&rsquo;s purpose. This field is optional.
callbacks: When a function&rsquo;s execution might take a considerable amount of time, rather than blocking the caller, you can define callbacks. These callbacks will be triggered once the results are ready or when an event related to the function call occurs. Note that these callbacks need to be defined as events too, as they are essentially events tied to a function call. Refer to the documentation on endpoint callbacks for a comprehensive understanding of how they are utilized within apps.
Callbacks possess the following properties:
name: This is the callback&rsquo;s designated name to be used in the code. It should also match the event&rsquo;s name defined in the endpoint (refer to the events section below). maxWaitingTime: This indicates the maximum expected duration for the callback to be invoked since the function is triggered. Setting a reasonable waiting time is crucial, as resources will only be released after this timeout or after the callback is called (refer to the next property as well). maxExpectedResponses: By default, once the callback is called, resources are released and it won&rsquo;t be called again. However, there are situations where the callback might be triggered multiple times by a single function execution. In such cases, you should specify the maximum number of times this callback can be invoked. Descriptor file events # ... &quot;events&quot;: [ { &quot;label&quot;: &quot;Inbound Event&quot;, &quot;name&quot;: &quot;inboundEvent&quot;, &quot;description&quot;: &quot;Event send for the endpoint each time that a POST request to the root path of the web service.&quot; }, { &quot;label&quot;: &quot;Pong&quot;, &quot;name&quot;: &quot;pong&quot;, &quot;description&quot;: &quot;Callback event for the Ping function&quot; }, ... ], ... Events originate at endpoints and are sent to the app, where they can be processed through listeners. For detailed instructions on how to process events from endpoints, refer to the documentation here.
An event&rsquo;s definition contains a few key properties. The content of the event is defined by the endpoint, and the app receives it as JSON. However, there&rsquo;s no need to define the structure here.
These are the properties of events:
label: This is the name developers will see in the app builder. name: This is the internal name of the event used for identification in the code. description: A concise explanation of what triggers this event and when it is triggered. Descriptor file configuration # Endpoints can be configured within the app builder. Typically, developers will need to enter API keys and other required settings for the endpoint to function.
There are two types of configurations that an endpoint can have:
Global configuration: This configuration is applied when you access the endpoint in the app builder. All endpoints can have this type of configuration. User configuration: Users will encounter this configuration when they navigate to My Integrations in the secondary menu of the app runtime. This configuration is specific to individual users and is only available for endpoints where the configurationType setting is defined as PER_USER. Configurations are defined at the root of the descriptor using the following structure:
... &quot;configuration&quot;:[ ... ], &quot;userConfiguration&quot;:[ ... ] Each configuration is described by a set of fields, which follow the structure outlined below:
{ &quot;label&quot;: &quot;Field&quot;, &quot;name&quot;: &quot;field&quot;, &quot;type&quot;: &quot;password&quot;, &quot;multiplicity&quot;: &quot;one&quot;, &quot;required&quot;: true, &quot;visibility&quot;: @config.otherField, &quot;showLabel&quot;: true, &quot;defaultValue&quot;: &quot;12345678&quot;, &quot;typeOptions&quot;: {} } Here is a brief description of each property:
label: This is the label displayed on the left side of the field. It is required if showLabel is set to true (default value). name: Represents the key under which the value will be stored in the configuration. This key is also accessible through the config global variable. type: The type of the field. This determines the typeOptions field. More information about types is provided below. multiplicity: There are two possible values: one (default value) or many. The many value allows defining multiple values for this field (as an array). required: Indicates whether the field is mandatory. It can be represented with a boolean value (true or false), a reference like @config.otherField, or an expression such as config.otherField &amp;&amp; utils.isPlaceHolder(config.anotherValue). visibility: Indicates if the field is visible in the UI. It can be represented with a boolean value (true or false), a reference like @config.otherField, or an expression like config.otherField &amp;&amp; utils.isPlaceHolder(config.anotherValue). showLabel: If set to false, the label will not be displayed, and the field will use the entire available width. It is represented with a boolean value (true or false). defaultValue: The value set by default if a value has not been set by the user. typeOptions: Only valid for some types; please refer to the next section for more details. Next, we will describe the available field types:
Label # Type: label
A label represents a read-only value that will not be stored as part of the configuration. It serves as informational content for users and developers.
{ &quot;label&quot;: &quot;Simple&quot;, &quot;name&quot;: &quot;simpleLabel&quot;, &quot;type&quot;: &quot;label&quot;, &quot;value&quot;: &quot;Sample Complex endpoint&quot; } This field type has no options.
Information # Type: info
This type enables the display of an alert that accommodates the insertion of HTML code.
{ &quot;label&quot;: &quot;Information&quot;, &quot;name&quot;: &quot;information&quot;, &quot;type&quot;: &quot;info&quot;, &quot;typeOptions&quot;: { &quot;alertType&quot;: &quot;warning&quot; }, &quot;value&quot;: &quot;Follow these points to generate a new credentials:&lt;ul&gt;&lt;li&gt;Access to the Dev Console&lt;/li&gt;&lt;li&gt;Create a new project. Copy the 'Project Name' in the configuration form.&lt;/li&gt;&lt;li&gt;...&lt;/li&gt;&lt;/ul&gt;&quot; } Options:
alertType: Describes the color or format for display. Valid values include: info, success, warning, and danger. Fields group # Type: fieldsGroup
This special type of field enables nesting other fields within it, providing a structured way to organize and group fields.
{ &quot;label&quot;: &quot;Labels&quot;, &quot;name&quot;: &quot;labels&quot;, &quot;type&quot;: &quot;fieldsGroup&quot;, &quot;typeOptions&quot;: { &quot;fields&quot;:[ { &quot;label&quot;: &quot;Simple&quot;, &quot;name&quot;: &quot;simpleLabel&quot;, &quot;type&quot;: &quot;label&quot;, &quot;value&quot;: &quot;Sample Complex endpoint&quot; }, { &quot;label&quot;: &quot;Concatenation&quot;, &quot;name&quot;: &quot;concatenation&quot;, &quot;type&quot;: &quot;label&quot;, &quot;value&quot;: &quot;'Prefix ['+(config.entity ? config.entity : 'No entity') +'] &gt; ['+(config.entityField ? config.entityField : 'No field')+'] &gt; ['+(config.entityAction ? config.entityAction : 'No action')+']'&quot; }, { &quot;label&quot;: &quot;Multi&quot;, &quot;name&quot;: &quot;multiLabel&quot;, &quot;type&quot;: &quot;label&quot;, &quot;multiplicity&quot;: &quot;many&quot;, &quot;value&quot;: [ &quot;config.entity ? config.entity : 'No entity'&quot;, &quot;config.entityField ? config.entityField : 'No field'&quot;, &quot;config.entityAction ? config.entityAction : 'No action'&quot; ] } ] } } Options:
fields: The structure of this field must adhere to that of configuration or userConfiguration. Essentially, it is an array of fields. While it supports any number of levels, it&rsquo;s not recommended to go beyond two levels due to limited available UI space. Text # Type: text
This input represents a standard text field where the value is stored as a simple string. It can include validations set through type options.
{ &quot;label&quot;: &quot;Email&quot;, &quot;name&quot;: &quot;email&quot;, &quot;type&quot;: &quot;text&quot;, &quot;required&quot;: true, &quot;typeOptions&quot;: { &quot;validation&quot;: &quot;email&quot; } } { &quot;label&quot;: &quot;Description&quot;, &quot;name&quot;: &quot;description&quot;, &quot;type&quot;: &quot;text&quot;, &quot;typeOptions&quot;: { &quot;representation&quot;: &quot;textArea&quot;, &quot;numberOfRows&quot;: 4 } } Options:
validation: Available validations include: email, number, and url. All these validations allow placeholders. representation: This determines the component used to represent the field. Valid options are: inputText (default) and textArea. numberOfRows: If the selected representation is textArea, you can specify the number of rows to be displayed. Password # Type: password
This field is represented by a password input. The value will not be visible to the developer and will be stored as a plain string. Note that all endpoint settings are encrypted, as sensitive information is typically involved.
{ &quot;label&quot;: &quot;Password&quot;, &quot;name&quot;: &quot;password&quot;, &quot;type&quot;: &quot;password&quot;, &quot;required&quot;: true } This field type has no options.
Toggle # Type: toggle
Creates a toggle widget and will store a boolean value.
{ &quot;label&quot;: &quot;Sync Automatically&quot;, &quot;name&quot;: &quot;syncAutomatically&quot;, &quot;multiplicity&quot;: &quot;one&quot;, &quot;type&quot;: &quot;toggle&quot; } This field type has no options.
Script # Type: script
This field can store a script (JavaScript) that can be utilized later in the app.
{ &quot;label&quot;: &quot;Action Script&quot;, &quot;name&quot;: &quot;actionScript&quot;, &quot;type&quot;: &quot;script&quot;, &quot;multiplicity&quot;: &quot;one&quot;, &quot;typeOptions&quot;: { &quot;parameters&quot;: [&quot;day&quot;, &quot;amount&quot;] } } You can invoke this script during runtime using the following approach:
app.endpoints.sampleEndpoint.config.actionScript({day: '2019-02-15', amount: 5}); Options:
params: A list of parameters that this function will accept. Only these parameters will be passed to the function when it is executed. Button # Type: button
This component allows the execution of an action when clicked. No information is stored as value of this field. This component does not allow multiplicity equals to many.
{ &quot;label&quot;: &quot;Set email&quot;, &quot;name&quot;: &quot;setEmail&quot;, &quot;type&quot;: &quot;button&quot;, &quot;typeOptions&quot;: { &quot;color&quot;: &quot;info&quot;, &quot;action&quot;: &quot;if (!config.inputs.email) { config.inputs.email = 'test1@slingr.io'; }&quot; } } Options:
color: The available values are info, default, primary, success, warning, and danger. action: This is an expression that will be parsed and executed as a JavaScript function on the client side. Some interesting examples can be found in the official endpoints. For instance, the Google Calendar endpoint uses buttons to trigger the OAuth process. Buttons group # Type: buttonsGroup
This component creates a group of buttons. If multiplicity is set to true, multiple values can be selected.
{ &quot;label&quot;: &quot;Multi&quot;, &quot;name&quot;: &quot;multiSwitcher&quot;, &quot;type&quot;: &quot;buttonsGroup&quot;, &quot;multiplicity&quot;: &quot;many&quot;, &quot;required&quot;: true, &quot;defaultValue&quot;: [&quot;danger&quot;, &quot;info&quot;], &quot;typeOptions&quot;: { &quot;possibleValues&quot;:[ { &quot;label&quot;:&quot;Danger&quot;, &quot;name&quot;:&quot;danger&quot; }, { &quot;label&quot;:&quot;Warning&quot;, &quot;name&quot;:&quot;warn&quot; }, { &quot;label&quot;:&quot;Information&quot;, &quot;name&quot;:&quot;info&quot; } ], &quot;allowCustom&quot;: true } } Options:
possibleValues: This is an array of elements with label (text shown as options) and name (string stored as value). These elements constitute the available options. allowCustom: Indicates whether a placeholder can be set as a value, creating an input right next to the buttons for selection. This feature is important if the value of this field might need to vary across different environments of your app. Drop-down # Type: dropDown
This component creates a combo box. In the case of multiplicity being set to many, more than one value can be selected.
{ &quot;label&quot;: &quot;Multi Custom&quot;, &quot;name&quot;: &quot;multiCustomDropDown&quot;, &quot;type&quot;: &quot;dropDown&quot;, &quot;multiplicity&quot;: &quot;many&quot;, &quot;defaultValue&quot;: [&quot;\${TEST2}&quot;, &quot;CA&quot;], &quot;typeOptions&quot;: { &quot;allowCustom&quot;: true, &quot;possibleValues&quot;:[ { &quot;label&quot;:&quot;New York&quot;, &quot;name&quot;:&quot;NY&quot; }, { &quot;label&quot;:&quot;Arizona&quot;, &quot;name&quot;:&quot;AZ&quot; }, { &quot;label&quot;:&quot;California&quot;, &quot;name&quot;:&quot;CA&quot; } ] } } Options:
possibleValues: This is an array of elements with label (text shown as options) and name (string stored as value). These elements constitute the available options. allowCustom: Indicates whether a placeholder can be set as a value, creating an input next to buttons for selection. This feature is important if the value of this field might need to change between different environments of your app. Entity # Type: entity
This component allows the selection of an existing entity defined within the app. The value will be stored as a reference to metadata and will be updated accordingly when changes occur. For instance, if the entity&rsquo;s name changes, the configuration of the endpoint will be automatically updated. Similarly, if the entity is deleted, the value will be cleared.
{ &quot;label&quot;: &quot;Entity&quot;, &quot;name&quot;: &quot;entity&quot;, &quot;type&quot;: &quot;entity&quot; } This field type has no options.
Entity field # Type: entityField
Allows to select an existing entity field. The value will be stored as a reference to metadata, being refactored in the same way when changes happen. For example, if the entity field&rsquo;s name changes, the configuration of the endpoint will be updated, or if the field gets deleted, the value will be cleared.
{ &quot;label&quot;: &quot;Field&quot;, &quot;name&quot;: &quot;entityField&quot;, &quot;type&quot;: &quot;entityField&quot;, &quot;visibility&quot;: &quot;@config.entity&quot;, &quot;required&quot;: &quot;@config.entity&quot;, &quot;typeOptions&quot;: { &quot;entity&quot;: &quot;@config.entity&quot;, &quot;filterTypes&quot;: [&quot;user&quot;, &quot;choice&quot;] } } Options:
entity: This option specifies the entity to which the field should belong. Valid values include the entity name or ID, or a direct reference like @config.entity. filterTypes: This option accepts a list of valid entity field types (in camel case) to filter the types of fields listed in the selector. Entity action # Type: entityAction
Allows the selection of an existing entity action. The value will be stored as a metadata reference, which will be updated in the same way when changes occur. For instance, if the entity action&rsquo;s name is modified, the configuration of the endpoint will be updated accordingly. Similarly, if the action is deleted, the value will be cleared.
{ &quot;label&quot;: &quot;Action&quot;, &quot;name&quot;: &quot;entityAction&quot;, &quot;type&quot;: &quot;entityAction&quot;, &quot;visibility&quot;: &quot;@config.entity&quot;, &quot;defaultValue&quot;: &quot;addANote&quot;, &quot;typeOptions&quot;: { &quot;entity&quot;: &quot;@config.entity&quot; } } Options:
entity: This option specifies the entity to which the action should belong. Valid values include the entity name or ID, or a direct reference like @config.entity. Entity filters # Type: entityFilters
Allows developers to define an entity filter while configuring the endpoint. The value will be stored as metadata, meaning it will be updated if fields involved in this filter are renamed or deleted.
{ &quot;label&quot;: &quot;Filters&quot;, &quot;name&quot;: &quot;entityFilters&quot;, &quot;type&quot;: &quot;entityFilters&quot;, &quot;typeOptions&quot;: { &quot;entity&quot;: &quot;@config.entity&quot; }, &quot;value&quot;: { &quot;_or&quot;: { &quot;companyType&quot;:&quot;Self&quot;, &quot;name&quot;:&quot;notEmpty()&quot; }, &quot;entity&quot;:&quot;companies&quot; } } The value is represented as complex queries. For more information, please refer to the documentation on expressions to understand how it works and how to use it in a query.
Options:
entity: This option specifies the entity associated with the filter. Valid values include the entity name or ID, or a direct reference like @config.entity. Entity events # Type: entityEvents
Allows the developer to define an entity event while configuring the endpoint. The value will be stored as metadata, which means it will be refactored, for example, if fields involved in this event are renamed or deleted.
{ &quot;label&quot;: &quot;Events&quot;, &quot;name&quot;: &quot;entityEvents&quot;, &quot;type&quot;: &quot;entityEvents&quot;, &quot;typeOptions&quot;: { &quot;entity&quot;: &quot;@config.entity&quot; }, &quot;value&quot;: { &quot;events&quot;: [ { &quot;id&quot;:&quot;59b029ad57abd274c50074c6&quot;, &quot;conditionType&quot;:&quot;none&quot;, &quot;type&quot;:&quot;recordCreated&quot;, &quot;sourceEvents&quot;: [ &quot;userEvents&quot;, &quot;systemEvents&quot; ] }, { &quot;id&quot;:&quot;59b02a604b31a11b77001b78&quot;, &quot;conditionType&quot;:&quot;expression&quot;, &quot;expression&quot;: { &quot;filters&quot;: [ { &quot;type&quot;:&quot;byValue&quot;, &quot;operation&quot;:&quot;notEmpty&quot;, &quot;field&quot;:&quot;companyLinks.link&quot;, &quot;values&quot;:[] } ], &quot;entity&quot;:&quot;companies&quot; }, &quot;type&quot;:&quot;conditionMet&quot;, &quot;sourceEvents&quot;: [ &quot;userEvents&quot;, &quot;systemEvents&quot; ] }, { &quot;id&quot;:&quot;59b02bf7bdcf466302006303&quot;, &quot;conditionType&quot;:&quot;script&quot;, &quot;script&quot;: &quot;1 == '1'&quot;, &quot;type&quot;:&quot;actionPerformed&quot;, &quot;actions&quot;: [ &quot;assignCompanyType&quot;, &quot;addANote&quot; ], &quot;sourceEvents&quot;: [ &quot;scriptEvents&quot;, &quot;systemEvents&quot; ] } ] } } This events can be used later to define listeners.
Options:
entity: this is the entity the event is associated with. Valid values are the entity name or id, or a direct reference like @config.entity. Entity mapper # Type: entityMapper
The entity mapper field type assists in defining a mapping between the app and the endpoint. For instance, consider a scenario where the endpoint integrates with a service that holds information about companies. Instead of requiring users to manually establish a mapping between the companies in the external service and the entities in the app, the entity mapper can be utilized to configure the mapping process. Subsequently, the endpoint will utilize this configured information to automate the mapping procedure.
{ &quot;label&quot;: &quot;Accounts&quot;, &quot;name&quot;: &quot;accounts&quot;, &quot;type&quot;: &quot;entityMapper&quot;, &quot;typeOptions&quot;: { &quot;allowToCreateEntity&quot;: true, &quot;allowToSelectDirection&quot;: true, &quot;recordNameField&quot;: &quot;name&quot;, &quot;fields&quot;: [ { &quot;label&quot;: &quot;Name&quot;, &quot;name&quot;: &quot;name&quot;, &quot;type&quot;: &quot;text&quot;, &quot;multiplicity&quot;: &quot;one&quot; }, { &quot;label&quot;: &quot;Type&quot;, &quot;name&quot;: &quot;type&quot;, &quot;type&quot;: &quot;choice&quot;, &quot;multiplicity&quot;: &quot;one&quot;, &quot;options&quot;: { &quot;possibleValues&quot;: [ {&quot;label&quot;: &quot;Client&quot;, &quot;name&quot;: &quot;client&quot;}, {&quot;label&quot;: &quot;Prospect&quot;, &quot;name&quot;: &quot;prospect&quot;}, {&quot;label&quot;: &quot;Other&quot;, &quot;name&quot;: &quot;other&quot;} ] } }, { &quot;label&quot;: &quot;Relationship&quot;, &quot;name&quot;: &quot;relation&quot;, &quot;type&quot;: &quot;relationship&quot;, &quot;multiplicity&quot;: &quot;one&quot;, &quot;options&quot;: { &quot;entity&quot;: &quot;@config.entity&quot; } }, { &quot;label&quot;: &quot;Address&quot;, &quot;name&quot;: &quot;address&quot;, &quot;type&quot;: &quot;nestedFields&quot;, &quot;multiplicity&quot;: &quot;one&quot;, &quot;options&quot;: { &quot;nestedFields&quot;: [ { &quot;label&quot;: &quot;Streets&quot;, &quot;name&quot;: &quot;streets&quot;, &quot;type&quot;: &quot;text&quot;, &quot;multiplicity&quot;: &quot;many&quot; }, { &quot;label&quot;: &quot;State&quot;, &quot;name&quot;: &quot;state&quot;, &quot;type&quot;: &quot;choice&quot;, &quot;multiplicity&quot;: &quot;one&quot;, &quot;options&quot;: { &quot;possibleValues&quot;: [ {&quot;label&quot;: &quot;Arizona&quot;, &quot;name&quot;: &quot;AZ&quot;}, {&quot;label&quot;: &quot;New York&quot;, &quot;name&quot;: &quot;NY&quot;}, {&quot;label&quot;: &quot;California&quot;, &quot;name&quot;: &quot;CA&quot;} ] } }, { &quot;label&quot;: &quot;Contact&quot;, &quot;name&quot;: &quot;contact&quot;, &quot;type&quot;: &quot;nestedFields&quot;, &quot;multiplicity&quot;: &quot;many&quot;, &quot;options&quot;: { &quot;nestedFields&quot;: [ { &quot;label&quot;: &quot;Name&quot;, &quot;name&quot;: &quot;name&quot;, &quot;type&quot;: &quot;text&quot;, &quot;multiplicity&quot;: &quot;one&quot; }, { &quot;label&quot;: &quot;Phones&quot;, &quot;name&quot;: &quot;phones&quot;, &quot;type&quot;: &quot;phone&quot;, &quot;multiplicity&quot;: &quot;many&quot; } ] } } ] } } ], &quot;hooks&quot;: [ { &quot;label&quot;: &quot;Syncing to app&quot;, &quot;name&quot;: &quot;syncingToApp&quot;, &quot;params&quot;: [&quot;record&quot;, &quot;oldRecord&quot;, &quot;data&quot;] }, { &quot;label&quot;: &quot;Syncing to Endpoint&quot;, &quot;name&quot;: &quot;syncingEndpoint&quot;, &quot;params&quot;: [&quot;record&quot;, &quot;data&quot;, &quot;other&quot;] }, { &quot;label&quot;: &quot;Other script&quot;, &quot;name&quot;: &quot;otherScript&quot; } ] } } Options:
allowToCreateEntity: If set to true, a Create entity button will appear, allowing developers to create an entity with the configuration described in the mapper. A popup will be displayed to insert label and name. If the process completes successfully, the popup will close, and the configuration will be automatically populated with entity information. This feature greatly speeds up the integration process. For instance, a Google Calendar endpoint could have a mapper for events. Instead of manually creating the entity, users could click on Create entity to automatically generate the entity and configure it to sync with events in Google Calendar.
WARNING: If the configuration has dependencies on other fields, such as relationship fields pointing to an entity, and these dependencies are not set at the moment of triggering the create operation, the creation process will fail, showing a validation error. allowToSelectDirection: If set to true, a button group will be displayed, allowing the selection of one of three possible values:
App to Endpoint: Changes in the app are synchronized to the endpoint. Endpoint to App: Changes on the endpoint side must be synced to the Slingr app. Both: If allowToSelectDirection is false, the defaultDirection field is required. defaultDirection: This field indicates the default synchronization direction. It can be set to appTolegacyService, endpointToApp, or both.
recordNameField: Specifies which of the root fields will be used in the entity as the record name. This value is only used when clicking the Create entity button.
fields: This list includes the fields that can be mapped. Mandatory fields are label, name, and type. The multiplicity is optional, with a default value of one.
For types choice, relationship, and nestedFields, the options object is required to specify possibleValues, entity, and nestedFields, respectively. All these configurations are necessary for entity creation. Furthermore, they function as filters when an entity is selected through a combo-box, filtering valid fields for each configuration. Values are stored as references to entities and will be sent to the endpoint as paths of fields. hooks: Hooks mainly consist of script fields that will be available for endpoints. Here, users can describe function headers and the behavior when mapping alone is insufficient to convert fields from one side to the other.
Scripts # You need to configure scripts in the descriptor file:
... &quot;scripts&quot;:[ &quot;sample.js&quot;, &quot;other.js&quot; ], ... Scripts should be placed in the scripts folder of your endpoint, and the names of the files need to match the ones in the descriptor.
These scripts are provided by the endpoint and are executed in the context of the app, similar to other scripts. For instance, they are similar to scripts in libraries. These scripts serve to streamline the usage of the endpoint or offer certain features that should be executed on the app side.
Here are some common usages of scripts in endpoints:
Wrappers for endpoints functions: For instance, wrappers can be used to simplify the exposure of functions. These wrappers may perform actions to present the function in a more straightforward manner. Look at this sample: endpoint.wrapperFunc = function(a, b, c) { endpoint.func({a: a, b: b, c: c}); } In the example provided above, the user is not required to send a map when calling the function, but can directly pass the parameters. Access to app data: In cases where you need to automate a process requiring access to app data, execution on the app side is necessary. This is because querying app data is not possible from within the endpoint. A script file will look like this:
var s = function(a, b){ return a+b; }; endpoint.sum = s; endpoint.rnd = function(){ return Math.random(); }; endpoint.PI_VALUE = Math.PI; endpoint.rndSum = function(){ return this.sum(this.rnd(), this.PI_VALUE); }; endpoint.showConfig = function(){ sys.logs.info(&quot;Endpoint: &quot;+this._name); sys.logs.info(&quot; - Token: &quot;+this._configuration.token); // check that the variable 'endpoint' is isolated on the context sys.logs.info(&quot; - Token (by ref): &quot;+endpoint._configuration.token); }; In this context, there is a special variable called endpoint. You can add properties to this object to make them accessible within the endpoint. For instance, in the example mentioned above, you could invoke the function rnd by using the syntax app.endpoints.sample.rnd() (assuming your endpoint&rsquo;s name is sample).
It&rsquo;s also important to note the following elements:
endpoint._name: This represents the name of the endpoint configured in the app. endpoint._configuration: This is a map containing the configuration of the endpoint. Listeners # Listeners need to be defined in the descriptor file:
... &quot;listeners&quot;:[ &quot;dataListener.js&quot;, &quot;jobListener.js&quot;, &quot;endpointListener.js&quot; ], ... These scripts should be located in the listeners folder of the endpoint.
Within these scripts, you can dynamically define listeners. This way, when developers integrate an endpoint into their apps, listeners will be automatically incorporated.
For instance, you could utilize this feature to enable automatic data synchronization between the app and an external service. In this scenario, you would create a listener that triggers when a record is modified in the app, facilitating the synchronization of changes to the external service. Similarly, you could establish another listener to respond to incoming webhooks from the external app, ensuring that the data in the app remains updated.
To define listeners, you should add them as properties to the listeners object:
var getEntity = function(){ return 'companies'; }; listeners.listenerForCompaniesChanges = { label: 'Listener for Companies changes', type: 'data', options: { executeInBackground: true, entity: getEntity(), events: [ { type: 'recordCreated' }, {type: 'actionPerformed', action: 'assignCompanyType'} ] }, callback: function(event, record, oldRecord) { sys.logs.info('Entering to listener handler'); sys.logs.info('Event: '+JSON.stringify(event)); sys.logs.info('Record: '+JSON.stringify(record)); sys.logs.info('Old record: '+(oldRecord ? JSON.stringify(oldRecord) : '')); } }; The script can contain its own functions, such as getEntity. The name of the variable will be the name of the listener. Additionally, the user needs to configure the label of the listener, followed by the type (which can be data, endpoint, or job). The options field pertains to the specific configuration for each type. Finally, the callback defines the action executed by the listener. The header of this function is ignored; only the internal code is utilized. Developers must consider the parameters based on the listener type. Refer to the documentation for more details.
Next, we will provide a brief overview of the different types of listeners:
Data # Refer to the example below:
listeners.listenerForCompaniesChanges = { //The name will be taken from this namespace label: 'Listener for Companies changes', //label configuration type: 'data', options: { executeInBackground: true, //Indicates if the listener must be executed in background entity: 'companies', //The name or id of the entity listened events: [ //entity events configuration {type: 'recordCreated'}, //the type of entity event, it can be 'recordCreated', 'recordChanged', 'recordDeleted', 'actionPerformed' {type: 'actionPerformed', action: 'assignCompanyType'} //not all event types are available, in addition, for 'actionPerformed' the name or id can be specify ] }, callback: function(event, record, oldRecord) {// available parameters are 'event', 'record' and 'oldRecord' sys.logs.info('Entering to listener handler'); //JS API functions are available sys.logs.info('Event: '+JSON.stringify(event)); sys.logs.info('Record: '+JSON.stringify(record)); sys.logs.info('Old record: '+(oldRecord ? JSON.stringify(oldRecord) : '')); } }; Endpoint # See the example:
listeners.listenerForSample = { //The name will be taken from this namespace label: 'Listener for Sample endpoint', //label configuration type: 'endpoint', options: { endpoint: endpoint.name, //name of listened endpoint, it can be taken for special var called \`endpoint\` referring to current endpoint event: 'inboundEvent' //a valid event defined into \`endpoint.json\` dispatched by selected endpoint }, callback: function(event) {// only \`event\` is a available parameter for this function sys.logs.info('Entering to listener handler'); //JS API functions are available sys.logs.info('Event: '+JSON.stringify(event)); } }; Job # See the example:
listeners.listenerForExportRecords = { //The name will be taken from this namespace label: 'Listener for Export records', //label configuration type: 'job', options: { jobType: 'exportRecords',//job type, available are: \`startApp\`, \`stopApp\`, \`importRecords\`, \`exportRecords\`, \`importUsers\`, \`exportUsers\` event: 'finished'// status listened, available are: \`created\`, \`started\`, \`finished\`, \`stopped\`, \`resumed\`, and \`canceled\` }, callback: function(event) {// only \`event\` is a available parameter for this function sys.logs.info('Entering to listener handler'); //JS API functions are available sys.logs.info('Event: '+JSON.stringify(event)); } }; Flow steps # You have the ability to create customized flow steps for your endpoint. To achieve this, define the endpoint&rsquo;s flow steps in the descriptor file:
... &quot;flowSteps&quot;: [ &quot;numberGenerator&quot;, &quot;weatherService&quot;, &quot;simpleCalculator&quot; ], ... Flow steps should be defined in the flowSteps folder of your endpoint, and the names of the files must match those in the descriptor. For each defined flow step, you need to provide three files:
icon.png: This is the icon representing the step in the flow editor. step.js: This file should contain the function that will be executed as part of the step. The function must receive a unique object parameter called &lsquo;inputs&rsquo;, which contains the function parameters. step.json: This file should contain the name of the step, along with its inputs and outputs. After creating these necessary files, you&rsquo;ll need to register your endpoint with a new version. Additional details can be found in the Endpoint Registration section.
Upon registering the new endpoint version and selecting that new version from the developer portal, the newly defined flow steps will be accessible in the flow editor.
Steps available in the flow editor Required files examples # Examples for step.js file:
/** * Generates a random number. * * @param {object} inputs {number} bound, This is used to get a random number between 0 (inclusive) and the number * passed in this argument, exclusive. */ step.numberGenerator = function (inputs) { var data = endpoint.randomNumber({bound: inputs.bound}); return { &quot;generatedNumber&quot;: data['number'] }; }; /** * Returns some real time weather characteristics given a city * * @param {object} inputs {string} city, City name, if nothing found it will use a default city (NY) */ step.weatherService = function (inputs) { var data = endpoint.weather({city: inputs.city}); return { &quot;city&quot;: data['city'], &quot;temperature&quot;: data['temperature'], &quot;pressure&quot;: data['pressure'], &quot;humidity&quot;: data['humidity'] }; }; From the step.js file, you can invoke JavaScript functions defined in the script files under the scripts folder, as well as functions annotated with @LegacyServiceFunction. The object you return from the step.js function should align with the output structure defined in the step.json file.
Here are examples for the step.json file:
{ &quot;label&quot;: &quot;Random numb&quot;, &quot;name&quot;: &quot;numberGenerator&quot;, &quot;category&quot;: &quot;integrations&quot;, &quot;description&quot;: &quot;Generates a new random number.&quot;, &quot;inputs&quot;: [ { &quot;label&quot;: &quot;Bound&quot;, &quot;name&quot;: &quot;bound&quot;, &quot;type&quot;: &quot;text&quot;, &quot;description&quot;: &quot;This is used to get a random number between 0 (inclusive) and the number passed in this argument, exclusive&quot;, &quot;required&quot;: &quot;true&quot;, &quot;defaultValue&quot;: 2000 } ], &quot;outputs&quot;: [ { &quot;label&quot;: &quot;Generated number&quot;, &quot;name&quot;: &quot;generatedNumber&quot;, &quot;type&quot;: &quot;number&quot;, &quot;description&quot;: &quot;The generated random number&quot; } ] } Inputs examples:
&quot;inputs&quot;: [ { &quot;label&quot;: &quot;Operation&quot;, &quot;name&quot;: &quot;operation&quot;, &quot;type&quot;: &quot;choice&quot;, &quot;defaultValue&quot;: &quot;SUM&quot;, &quot;required&quot;: &quot;true&quot;, &quot;options&quot;: { &quot;possibleValues&quot;: [ { &quot;label&quot;: &quot;Sum&quot;, &quot;name&quot;: &quot;SUM&quot; }, { &quot;label&quot;: &quot;Rest&quot;, &quot;name&quot;: &quot;REST&quot; }, { &quot;label&quot;: &quot;Division&quot;, &quot;name&quot;: &quot;DIV&quot; }, { &quot;label&quot;: &quot;Multiplication&quot;, &quot;name&quot;: &quot;MULT&quot; } ], &quot;allowContextSelector&quot;: &quot;false&quot; } }, { &quot;label&quot;: &quot;First operand&quot;, &quot;name&quot;: &quot;firstOperand&quot;, &quot;type&quot;: &quot;text&quot;, &quot;description&quot;: &quot;First operand&quot;, &quot;required&quot;: &quot;true&quot; }, { &quot;label&quot;: &quot;Second operand&quot;, &quot;name&quot;: &quot;secondOperand&quot;, &quot;type&quot;: &quot;text&quot;, &quot;description&quot;: &quot;Second operand&quot;, &quot;required&quot;: &quot;true&quot; } ] Output examples:
&quot;outputs&quot;: [ { &quot;label&quot;: &quot;result&quot;, &quot;name&quot;: &quot;result&quot;, &quot;type&quot;: &quot;object&quot;, &quot;description&quot;: &quot;Result object containing temperature, pressure and humidity for the given city&quot; } ] &quot;outputs&quot;: [ { &quot;label&quot;: &quot;city&quot;, &quot;name&quot;: &quot;city&quot;, &quot;type&quot;: &quot;text&quot;, &quot;description&quot;: &quot;name of the city&quot; }, { &quot;label&quot;: &quot;temperature&quot;, &quot;name&quot;: &quot;temperature&quot;, &quot;type&quot;: &quot;number&quot;, &quot;description&quot;: &quot;temperature for the given city&quot; }, { &quot;label&quot;: &quot;pressure&quot;, &quot;name&quot;: &quot;pressure&quot;, &quot;type&quot;: &quot;number&quot;, &quot;description&quot;: &quot;pressure for the given city&quot; }, { &quot;label&quot;: &quot;humidity&quot;, &quot;name&quot;: &quot;humidity&quot;, &quot;type&quot;: &quot;number&quot;, &quot;description&quot;: &quot;humidity for the given city&quot; } ] For more information about flows you can go to Developer&rsquo;s reference: Flows Overview
`}),e.add({id:44,href:"/extensions/migrations/extending-platform/java-sdk/",title:"Java SDK",description:`This document will guide through the creation of an endpoint using the Java SDK and will provide details about the framework.
Crate your new endpoint project # To simplify the creation of a new endpoint, we provide a skeleton endpoint on GitHub. You can fork this repository, which contains the common features required for most endpoints. Visit the repository here.
You can also explore our sample endpoints to understand the features available in the Slingr integrations framework:`,content:`This document will guide through the creation of an endpoint using the Java SDK and will provide details about the framework.
Crate your new endpoint project # To simplify the creation of a new endpoint, we provide a skeleton endpoint on GitHub. You can fork this repository, which contains the common features required for most endpoints. Visit the repository here.
You can also explore our sample endpoints to understand the features available in the Slingr integrations framework:
Sample Endpoint Sample User Endpoint Sample Complex Endpoint Additionally, take a look at the HTTP Endpoint since most endpoints interact with HTTP REST APIs, and this endpoint covers the basic features. You can also see how endpoints like Sparkpost utilize these features.
While you can start from scratch, we recommend using the skeleton endpoint to get up and running quickly.
Customize the skeleton template # If you&rsquo;ve used the skeleton endpoint, there are a few adjustments you might want to make:
POM file # The pom.xml contains several elements you might want to adjust:
groupId: This specifies your endpoint&rsquo;s group, which could be your company&rsquo;s group. artifactId: This typically represents your endpoint&rsquo;s name for Maven. version: This is your endpoint&rsquo;s version. You can leave it as 1.0-SNAPSHOT since Slingr uses repository tags for versioning. name: This is a human-readable name for your endpoint. properties &gt; build.main-class: If you modify the package of the main class io.sliongr.endpoints.skeleton.SkeletonLegacyService (which you probably will), update it to match the package (except for the class Runner). For example, if your endpoint&rsquo;s main class is yourcompany.endpoints.LegacyEndpoint, update it to yourcompany.endpoints.Runner. Endpoint descriptor # The endpoint.json file has at least two fields to update:
label: This is a user-friendly endpoint name. name: This is the internal endpoint name used for registration in Slingr. For other settings, refer to the Endpoint Features documentation.
Main class name # You&rsquo;ll likely want to rename and repackage the io.slingr.endpoints.skeleton.SkeletonEndpoint class, which is your endpoint&rsquo;s main class.
Additionally, update the @SlingrEndpoint annotation:
@SlingrEndpoint(name = &quot;name&quot;) public class SkeletonEndpoint extends Endpoint { } Ensure that this name matches the corresponding entry in endpoints.json.
Reading configuration # There are two ways to retrieve configuration settings from the endpoint:
Define individual fields Access the entire configuration using a Json object To define individual variables, follow this syntax within the class annotated with @SlingrEndpoint:
@SlingrEndpoint(name = &quot;name&quot;) public class SkeletonEndpoint extends Endpoint { @EndpointProperty private String token; } To store the value of the configuration property token, assign it to the variable token. Conventionally, the variable name matches the field name. However, you can customize it using the name attribute within the @EndpointProperty annotation.
Additionally, you have the option to utilize the @EndpointConfiguration annotation in the following manner:
@SlingrEndpoint(name = &quot;name&quot;) public class SkeletonEndpoint extends Endpoint { @EndpointConfiguration private Json config; @Override public void endpointStarted() { logger.info(String.format(&quot;Domain [%s]&quot;, config.string(&quot;domain&quot;))); } } Hooks # Within endpoints, several hooks are available for executing initialization or cleanup tasks.
@SlingrEndpoint(name = &quot;name&quot;) public class SkeletonEndpoint extends Endpoint { @Override public void endpointConfigured() { // the definitions and properties are ready to be used at this point } @Override public void endpointsServicesConfigured() { // the communication with the app is ready at this point } @Override public void webServicesConfigured() { // the web services server is ready at this point } @Override public void endpointStarted() { // the endpoint has been started completely } @Override public void endpointStopped(String cause) { // endpoint has been stopped } } Functions # To implement a function defined in the endpoint.json file, employ the @SlingrFunction annotation:
@SlingrEndpoint(name = &quot;sample&quot;) public class SampleEndpoint extends Endpoint { @EndpointFunction(name = &quot;randomNumber&quot;) public Json generateRandomNumber(Json data){ Json res = Json.map(); if (data != null &amp;&amp; data.contains(&quot;max&quot;)) { res.set(&quot;number&quot;, random.nextInt(data.integer(&quot;max&quot;))); } else { res.set(&quot;number&quot;, random.nextInt(10000)); } return res; } } Upon usage, your function will receive a Json argument containing the parameters sent to the function. Your function is expected to return a Json object as the response.
Events # Utilize the Events interface to dispatch events to the app, which can be accessed through the events() method:
@SlingrEndpoint(name = &quot;sample&quot;) public class SampleEndpoint extends Endpoint { @EndpointWebService(methods = {RestMethod.POST}) private WebServiceResponse inboundEvent(WebServiceRequest request) { events().send(&quot;inboundEvent&quot;, Json.map().set(&quot;data&quot;, request.getJsonBody())); return new WebServiceResponse(); } } Note that the event inboundEvent must be defined in your endpoint.json descriptor.
When dispatching events using send(), it&rsquo;s important to note that the process is asynchronous. If you require a response from the app and wish to wait for it, employ sendSync() instead:
@SlingrEndpoint(name = &quot;sample&quot;) public class SampleEndpoint extends Endpoint { @EndpointWebService(methods = {RestMethod.POST}) private WebServiceResponse inboundEvent(WebServiceRequest request) { Object res = events().sendSync(&quot;inboundEvent&quot;, Json.map().set(&quot;data&quot;, request.getJsonBody())); // do something with the res return new WebServiceResponse(); } } Remember that, in this scenario, to obtain a response, the listener in the app should utilize the keyword return to send back the desired response.
Data stores # For endpoints requiring data persistence, data stores are accessible. These stores should be defined in the descriptor file, after which they can be utilized within the endpoint:
@SlingrEndpoint(name = &quot;sample&quot;) public class SampleEndpoint extends Endpoint { @EndpointDataStore(name = &quot;test_data_store&quot;) private DataStore dataStore; @EndpointWebService(methods = {RestMethod.POST}) private WebServiceResponse processItems(WebServiceRequest request) { Json body = request.getJsonBody(); Json query = Json.map().set(&quot;code&quot;, body.string(&quot;code&quot;)); Json item = dataStore.findOne(query); if (item == null) { item = body; dataStore.save(item); } events().send(&quot;items&quot;, item); return new WebServiceResponse(); } } Webhooks # To enable your endpoint to receive HTTP calls, you can achieve this effortlessly by using the @EndpointWebService annotation:
@SlingrEndpoint(name = &quot;sample&quot;) public class SampleEndpoint extends Endpoint { @EndpointWebService(methods = {RestMethod.POST}) private WebServiceResponse genericCommand(WebServiceRequest request) { // do something with the res return new WebServiceResponse(); } @EndpointWebService(path = &quot;/orders&quot;, methods = {RestMethod.POST}) private WebServiceResponse processOrder(WebServiceRequest request) { // do something here return new WebServiceResponse(); } } Given the above sample, the following URLs will be available:
POST https://&lt;yourAppName&gt;.slingrs.io/&lt;env&gt;/endpoints/&lt;endpointName&gt; POST https://&lt;yourAppName&gt;.slingrs.io/&lt;env&gt;/endpoints/&lt;endpointName&gt;/orders When those URLs are called, those methods will be invoked.
You should always add some kind of verification (like a token) to avoid anyone calling your endpoints. Handling files # It is possible to upload and download files to/from the app using the utilities in \`\`
@SlingrEndpoint(name = &quot;sample&quot;) public class SampleEndpoint extends Endpoint { @ApplicationLogger private AppLogs appLogger; @EndpointFunction public Json test1(Json data){ DownloadedFile file = files().download(data.string(&quot;fileId&quot;)); // do something with the file } @EndpointFunction public Json test2(Json data) throws IOException { Json uploadedFileInfo = files().upload(&quot;test&quot;, IOUtils.toInputStream(data.toString(), &quot;UTF-8&quot;), &quot;application/json&quot;); return uploadedFileInfo; } } Logging # It is possible to send logs to the app from your endpoint using the AppLogs:
@SlingrEndpoint(name = &quot;sample&quot;) public class SampleEndpoint extends Endpoint { @ApplicationLogger private AppLogs appLogger; @EndpointWebService(methods = {RestMethod.POST}) private WebServiceResponse genericCommand(WebServiceRequest request) { appLogger.info(&quot;Generic command arrived&quot;, request.getJsonBody()); // do something with the res return new WebServiceResponse(); } @EndpointWebService(path = &quot;/orders&quot;, methods = {RestMethod.POST}) private WebServiceResponse processOrder(WebServiceRequest request) { appLogger.info(&quot;Order processing arrived&quot;, request.getJsonBody()); // do something here return new WebServiceResponse(); } } In addition to sending a message, you have the option to include supplementary information that will be viewable by clicking on More Info within the app monitor log.
Setting up a proxy endpoint # Before proceeding to run your endpoint locally, it&rsquo;s essential to configure a proxy endpoint in the app you intend to use for testing your endpoint&rsquo;s development. Further details about this can be found in the guide: Create your own endpoints.
Upon adding a new Proxy endpoint to your app, you will be prompted to provide the Endpoint URI in the configuration. We recommend employing ngrok as an alternative to opening a port on your router. With ngrok, you can establish a URI as follows:
./ngrok http 10000 This will provide you with both an HTTP and HTTPS URL. We highly recommend utilizing the HTTPS URL; therefore, copy it and paste it into your endpoint&rsquo;s configuration.
As for the token, we suggest retaining the auto-generated token, unless you have a specific reason not to.
After creating the endpoint, you will encounter a configuration section similar to the following:
_endpoint_name=proxy _app_name=yourtestapp _environment=dev _pod_id=id _profile=default _custom_domain= _debug=true _local_deployment=true _base_domain=slingrs.io _webservices_port=10000 _endpoints_services_api=https://yourtestapp.slingrs.io/dev/endpoints/proxy/api _token=91833a8b-929f-4eab-b7b4-2383c10cd629 _endpoint_config={} Copy and paste this configuration into the endpoints.properties file. Please note that the final property, _endpoint_config, should contain valid JSON configuration for your endpoint. You may want to avoid overwriting this property. If you&rsquo;ve utilized the skeleton endpoint, your configuration might resemble the following:
_endpoint_name=proxy _app_name=yourtestapp _environment=dev _pod_id=id _profile=default _custom_domain= _debug=true _local_deployment=true _base_domain=slingrs.io _webservices_port=10000 _endpoints_services_api=https://yourtestapp.slingrs.io/dev/endpoints/proxy/api _token=91833a8b-929f-4eab-b7b4-2383c10cd629 _endpoint_config={&quot;token&quot;:&quot;123456&quot;} If you prefer, an alternative approach is to utilize a separate file if you wish to avoid committing sensitive credentials to your repository. We typically employ endpoint_proxy.properties for this purpose, which is already included in the .gitignore of the skeleton endpoint. You can provide this file as an argument when executing your endpoint. Consequently, this configuration will be utilized when your endpoint runs with the proxy.
Please bear in mind that endpoint.properties is exclusively used when you locally run the endpoint. It&rsquo;s valuable as a foundation for creating endpoint_proxy.properties. However, it doesn&rsquo;t impact the endpoint&rsquo;s behavior in the cloud since endpoint configuration is managed differently.
Once the proxy endpoint has been established in your app, remember to commit and push changes to ensure proper initialization.
Running your endpoint # Before you proceed with running your endpoint, ensure that you have built it:
cd ENDPOINT_FOLDER mvn package You can proceed to run your endpoint either through the command line or using your Integrated Development Environment (IDE). Ensure that you provide the following details when launching:
Main Class: Set this to package.Runner, where package corresponds to the configuration you established when creating the endpoint. You can find the class path within the pom.xml file. Configuration File: Specify the properties file to use. Typically, this will be endpoints.properties, endpoints_proxy.properties, or any other designated properties file. VM Options: Optionally, you can define the heap size using -Xmx256M. This helps restrict the memory usage of your endpoint, minimizing potential issues upon deployment to the cloud. Keep in mind that this memory setting doesn&rsquo;t precisely mirror the memory available when the endpoint is deployed in the cloud. Total memory consumption includes native memory used by the entire process. Nevertheless, limiting heap memory can be beneficial. Working Directory: Confirm that the working directory aligns with the location of your endpoint&rsquo;s code. Using Maven, you can execute the command below in the root folder of your endpoint:
mvn exec:java -Dexec.mainClass=&quot;io.slingr.endpoints.skeleton.Runner&quot; -Dexec.args=&quot;configurationFile=endpoint_proxy.properties&quot; -DROOT_LOGGER=stdout Testing that your endpoint is working # NWith your endpoint operational and the proxy endpoint established, let&rsquo;s perform a brief test to confirm that everything is functioning correctly. To carry out this test, execute the provided code within your builder or monitor console:
var res = app.endpoints.proxy.randomNumber({}); log('res: '+JSON.stringify(res)); You should see an output like this:
res: {&quot;number&quot;:5560} We are making the assumption that you are utilizing the skeleton endpoint template, which includes the availability of this method. Alternatively, if you're not using the skeleton template, ensure that you call a method that exists within your own endpoint. Exploring additional samples # Numerous endpoints have already been developed for the Slingr platform. Feel free to browse through them to gain insights into the various features offered by the endpoints framework.
`}),e.add({id:45,href:"/dev-reference/app/public-files/",title:"Public files",description:`Certain scenarios require the upload of files that need to be accessible by anyone. A classic example is when you wish to include icons or images in emails.
Within the app builder, under App &gt; Files, you have the capacity to upload files that can be accessed via a public URL. For instance, if you upload a file named logo.png into the images folder, you can retrieve it using the following URL:`,content:`Certain scenarios require the upload of files that need to be accessible by anyone. A classic example is when you wish to include icons or images in emails.
Within the app builder, under App &gt; Files, you have the capacity to upload files that can be accessed via a public URL. For instance, if you upload a file named logo.png into the images folder, you can retrieve it using the following URL:
https://&lt;app&gt;.slingrs.io/&lt;env&gt;/runtime/api/files/public/images/logo.png Public files are a constituent of your app&rsquo;s metadata. This signifies that they are synchronized to the production environment. It&rsquo;s prudent to confine the usage of this space to relatively small files that might be required. Excessive reliance on this mechanism can potentially decelerate the process of syncing changes. For substantial files, such as videos, it&rsquo;s recommended to explore alternative storage services.
While every new app comes with three default folders (documents, images, and misc), you have the flexibility to organize files according to your specific requirements. This is achievable through the creation or modification of folders.
`}),e.add({id:46,href:"/dev-reference/app/versions/",title:"Versions",description:`During the process of pushing changes, a crucial flag comes into play: Backup version. Activating this flag results in the creation of a backup for the version being pushed. This backup can subsequently be restored from the App &gt; Versions section within the app builder.
It&rsquo;s important to note that these backups exclusively encompass the app&rsquo;s metadata; data itself is not retained in these backups. Furthermore, when changes are synchronized to the production environment, an automatic backup of that version is generated.`,content:`During the process of pushing changes, a crucial flag comes into play: Backup version. Activating this flag results in the creation of a backup for the version being pushed. This backup can subsequently be restored from the App &gt; Versions section within the app builder.
It&rsquo;s important to note that these backups exclusively encompass the app&rsquo;s metadata; data itself is not retained in these backups. Furthermore, when changes are synchronized to the production environment, an automatic backup of that version is generated.
Upon inspecting the App &gt; Versions listing, the following information is presented:
Number: A distinct numerical identifier for the version. This appears in blue if the version hasn&rsquo;t been synced to production, yellow if synced but not the current production version, and green if it is the current production version. Author: The developer responsible for pushing or syncing changes. Date: The timestamp of backup creation. Sync date: The timestamp of changes synchronization. Comments: Comments composed during the changes&rsquo; push. Prod version: Indicates whether this version is the current one in the production environment. Within the context of a specific version selection, the following operations can be performed:
View changes: Offers insight into alterations made from the previous version to the chosen one. This mirrors the summary observed during changes&rsquo; push. Restore version: Executing this action results in the app builder&rsquo;s metadata being reverted to the state of the selected version. It&rsquo;s important to recognize that backups encompass solely metadata; hence, data restoration doesn&rsquo;t occur. However, data refactorings could be applied based on disparities with the restored version. To witness the restored version in execution, pushing changes and subsequently syncing those changes are necessary for presentation in the production environment. `}),e.add({id:47,href:"/dev-reference/environment-settings/",title:"Environment settings",description:"",content:""}),e.add({id:48,href:"/dev-reference/environment-settings/environment-var/",title:"Environment variables",description:`Environment variables serve as placeholders that can be employed throughout your app&rsquo;s metadata. When the app is loaded, these placeholders are dynamically replaced with their designated values. Employing environment variables instead of hard-coded values offers several distinct advantages:
Modifiable in the Production Environment: Environment variables can be managed via the app monitor, allowing changes to be made in the production environment. This is essential for adjusting app behavior, as the app builder is not accessible in the production environment.`,content:`Environment variables serve as placeholders that can be employed throughout your app&rsquo;s metadata. When the app is loaded, these placeholders are dynamically replaced with their designated values. Employing environment variables instead of hard-coded values offers several distinct advantages:
Modifiable in the Production Environment: Environment variables can be managed via the app monitor, allowing changes to be made in the production environment. This is essential for adjusting app behavior, as the app builder is not accessible in the production environment. Centralized Value Management: Altering the value of an environment variable requires changes in just one place. In contrast, hard-coded values necessitate manual updates across the entire app. To manage environment variables, you can access the dedicated section within the app builder: Environment settings &gt; Environment variables. Alternatively, these variables can also be managed via the app monitor: Environment settings &gt; Environment variables.
Synchronization of environment variables # Upon creation, environment variables are typically designated as &ldquo;synced.&rdquo; This implies that if a variable&rsquo;s value is modified in the development environment, the change will be mirrored in the production environment during the synchronization of changes.
While this synchronization approach is beneficial when a uniform configuration is desired for both development and production, it might not suit scenarios where distinct values are needed. In such cases, the option to disable &ldquo;Keep in sync&rdquo; can be exercised. This is executed within the app monitor of the production environment. Once toggled, syncing changes from development to production will no longer overwrite the variable&rsquo;s value.
Harnessing environment variables # The utility of environment variables spans across various sections of your app&rsquo;s metadata. These variables should be enclosed using the following syntax: \${ENVIRONMENT_VARIABLE_NAME}. For instance, if your variable is named ADMIN_EMAIL, referencing it would involve using \${ADMIN_EMAIL}.
For instance, if you possess an environment variable named TOKEN, its value can be integrated into a script in the following manner:
var token = '\${TOKEN}'; sys.logs.info('token: '+token); Another frequent scenario involves the utilization of environment variables within the settings of an legacy service. This approach offers a dynamic and adaptable means of configuration. For instance, when configuring a Slack legacy service, rather than embedding the bot token directly, an environment variable can be employed for enhanced flexibility. In the legacy service settings, the following syntax can be utilized (assuming the environment variable is named SLACK_BOT_TOKEN):
\${SLACK_BOT_TOKEN} System environment variables # System environment variables are automatically accessible across all apps. These variables possess calculated values designed to enhance app functionality. The following system variables are available:
APP_NAME: Reflects the name of the app. APP_ENV: Specifies the current execution environment of the app. This can be either dev (development) or prod (production). APP_URL: Provides the URL required for accessing the app runtime. For example, the URL might resemble https://app.slingrs.io/prod/runtime. APP_VERSION: A numerical identifier indicating the version of the app. This value is represented in milliseconds since the Epoch, corresponding to the moment changes were pushed. Consequently, this version number changes each time new changes are pushed. `}),e.add({id:49,href:"/extensions/migrations/extending-platform/node-sdk/",title:"Node SDK",description:`Create your new endpoint project # To streamline the creation of a new endpoint, we offer a sample GitHub repository containing a skeleton endpoint. You can fork this repository to quickly access the common features most users require for their endpoints. Here&rsquo;s the URL for the repository: Node.js Skeleton Endpoint
While you can certainly start building your endpoint from scratch, utilizing the skeleton endpoint can expedite your setup process.
Customize the skeleton template # If you&rsquo;ve chosen to use the skeleton endpoint, there are a few adjustments you may want to make:`,content:`Create your new endpoint project # To streamline the creation of a new endpoint, we offer a sample GitHub repository containing a skeleton endpoint. You can fork this repository to quickly access the common features most users require for their endpoints. Here&rsquo;s the URL for the repository: Node.js Skeleton Endpoint
While you can certainly start building your endpoint from scratch, utilizing the skeleton endpoint can expedite your setup process.
Customize the skeleton template # If you&rsquo;ve chosen to use the skeleton endpoint, there are a few adjustments you may want to make:
package.json file # The package.json file contains several elements that you might need to modify:
name: This is a user-friendly name for your endpoint. version: This indicates the version of your endpoint. You can leave it as 1.0.0 since this version isn&rsquo;t related to the versions registered in Slingr; Slingr employs the tags in your repository instead. description: Provide a description for what this endpoint is all about. scripts: This section allows you to set up execution scripts for your endpoints or tests. keywords: You can specify keywords relevant to your endpoint here. Endpoint descriptor # The endpoint.json file contains at least two fields that require updates:
label: This is the user-friendly name of the endpoint. name: This is the internal endpoint name, and it must correspond with the name you use to register the endpoint in Slingr. For a better understanding of the other settings, refer to the Endpoints Features section.
Accessing configuration settings # You can access the endpoint configuration using the following code snippet (always within a function):
endpoint.functions.someFunction = (endpointRequest) =&gt; { const configs = endpoint.endpointConfig; //your code... } Hooks # Endpoints provide a variety of hooks that allow you to execute initializations or perform cleanup tasks.
endpoint.hooks.onConfigurationReady = () =&gt; { //Some code here... } endpoint.hooks.onEndpointServicesConfigured = () =&gt; { //Some code here... } endpoint.hooks.onWebServicesReady = () =&gt; { //Some code here... } endpoint.hooks.onEndpointStart = () =&gt; { //Some code here... } //This one receives a 'cause' parameter which is the 'code' of the process.on('beforeExit') event endpoint.hooks.onEndpointStop = (cause) =&gt; { //Some code here... } Functions # To implement a function defined in the endpoint.json file, follow these steps:
endpoint.functions.yourFunctionName = (endpointRequest) =&gt; { //You can access all the endpoint services here like endpoint.endpointConfig or endpoint.dataStores //Your custom code goes here... return { someInfo: 'someValue'} } When implementing an endpoint function, it will receive a request parameter containing the function&rsquo;s parameters along with other relevant information. Remember, it&rsquo;s essential to always return a Json object as a response.
Events # Sending events to the app is accomplished through the use of the events property within the endpoint. Depending on your requirements, you can dispatch either an asynchronous event or a synchronous event if you anticipate a response from the app:
endpoint.functions.fnThatSendsAsyncEvent = (endpointRequest) =&gt; { const requestId = endpointRequest.id; //Later in your code... endpoints.events.send('someEventName', data, requestId); } endpoint.functions.fnThatSendsSyncEvent = (endpointRequest) =&gt; { const requestId = endpointRequest.id; //Later in your code... let eventResponse = endpoints.events.sendSync('someEventName', data, requestId); //Do something with that response... } Note: Ensure that the event named 'someEventName' is specified within your endpoint.json file under the events property. The data argument within the event will carry the data you intend to receive.
Additionally, the requestId parameter, as illustrated in the previous example, can be obtained from the request parameter defined in the respective function.
Data stores # For endpoints requiring persistent data storage, data stores are at your disposal. Definition of these stores takes place within the endpoint.json file, enabling their subsequent utilization within the endpoint.
The subsequent methods offer access to the various data stores:
endpoints.functions.someFunction = async () =&gt; { //Find documents by some flter: Filter here is the same as the one in sys.data.find(). eg: {someField: 'someValue'} endpoints.dataStores.someDataStore.find(filter); endpoints.dataStores.someDataStore.findOne(filter); //Find document by id: endpoints.dataStores.someDataStore.findById('documentId'); //Save a document: Some object will be any javascript object. endpoints.dataStores.someDataStore.save(someObject); //Update a document: endpoints.dataStores.someDataStore.update('documentId',someObject); //Remove documents by filter: endpoints.dataStores.someDataStore.remove(filter); //Remove by id: endpoints.dataStores.someDataStore.removeById('documentId',someObject); //Count the documents currently saved in the store by filter: endpoints.dataStores.someDataStore.count(filter); } You have the option to either await the response or employ the then() block, depending on your specific requirements.
Web services # To enable your endpoint to accept HTTP calls, you can specify these calls using the webServices property. It&rsquo;s essential to define this property as an object containing the webservice&rsquo;s method, path, and handler:
endpoint.webServices.nameForYourWebService = { method: 'POST', path: '/', //As this is an express endpoint, you receive the req, and res objects handler: (req, res) =&gt; { //Do something... and then return a response to the caller res.json({status: 'ok'}) } } Taking the provided example into account, the subsequent URL will be operational and responsive to incoming requests:
POST https://&lt;yourAppName&gt;.slingrs.io/&lt;env&gt;/endpoints/&lt;endpointName&gt; Upon invoking this URL, the associated handler will be triggered.
To ensure secure access to your endpoints, it's advisable to incorporate a form of verification, such as a token. This measure helps prevent unauthorized calls to your endpoints. File handling # The app provides utilities within the files property to facilitate the uploading and downloading of files. Depending on whether you intend to process these actions synchronously or asynchronously, you can either await the service or manage the response within the then() block. Subsequently, you can dispatch an event to the platform.
Both scenarios are illustrated below:
endpoint.functions.asyncDownloadFileFromEndpoint = async (endpointRequest) =&gt; { const file = endpointRequest.params; endpoint.files.download(file.id).then( (res) =&gt; { endpoint.logger.info('File download has completed!'); //In this case we return res.toString() because we know the file being downloaded is a .txt. Its not recommended to return the plain buffer to the platform. endpoint.events.send('onDownloadComplete', res.toString(), endpointRequest.id) } ); return { msg: 'File [' + file.id + '] is being downloaded and the processing will be made asynchronously. An event will be fired when the download is complete.' } }; endpoint.functions.syncDownloadFileFromEndpoint = async (endpointRequest) =&gt; { const file = endpointRequest.params; var fileResponse = await endpoint.files.download(file.id); endpoint.logger.info('File download has completed!'); //In this case we return res.toString() because we know the file being downloaded is a .txt. Its not recommended to return the plain buffer to the platform. return { fileContents: fileResponse.toString() } }; endpoint.functions.uploadFileSyncFromEndpoint = async (endpointRequest) =&gt; { const fileUrl = 'https://jsoncompare.org/LearningContainer/SampleFiles/PDF/sample-pdf-with-images.pdf'; try { //We download the dummy file from an HTTP request var downloadResponse = await endpoint.httpModule.get(fileUrl); } catch (error) { endpoint.logger.error('Couldn\\'t download the file from [' + fileUrl + '].', error); } //And upload it to the platform var fileInfo = await endpoint.files.upload('somefile.pdf', downloadResponse.data); //The info is returned to the app synchronously return fileInfo; }; endpoint.functions.uploadFileAsyncFromEndpoint = (endpointRequest) =&gt; { const fileUrl = 'https://jsoncompare.org/LearningContainer/SampleFiles/PDF/sample-pdf-with-images.pdf'; //We download the dummy file from an HTTP request endpoint.httpModule.get(fileUrl).then( (downloadResponse) =&gt; { //And upload it to the platform endpoint.files.upload('somefile.pdf', downloadResponse.data).then( (fileInfo) =&gt; { //In this case, the info will be sent asynchronously via events endpoint.events.send('onUploadComplete', fileInfo, endpointRequest.id); } ).catch( (err) =&gt; { endpoint.logger.error('Couldn\\'t upload the file to platform.', err); } ); } ).catch( (err) =&gt; { endpoint.logger.error('Couldn\\'t download the file from [' + fileUrl + '].', err); } ); return { msg: 'A file will be downloaded and then uploaded to the platform. This processing will be made asynchronously. An event will be fired when the download/upload is complete.' } }; Remember that the events must be defined in the **\`endpoint.json\`** file, and if you are using callbacks, also in the function's callbacks array property." Logging # You can transmit logs from your endpoint to the app using AppLogs:
endpoint.functions.someFunctionThatLogs = (endpointRequest) =&gt; { endpoint.appLogger.debug('Function executed!') endpoint.appLogger.info('Function executed!') endpoint.appLogger.warn('Function executed!') endpoint.appLogger.error('Function executed!') } To include supplementary information that will be viewable upon clicking More Info within the app monitor logs, provide a second parameter to the appLogger functions in the following manner:
endpoint.functions.someFunctionThatLogs = (endpointRequest) =&gt; { endpoint.appLogger.debug('Function executed!',someObjectOrMessage) endpoint.appLogger.info('Function executed!',someObjectOrMessage) endpoint.appLogger.warn('Function executed!',someObjectOrMessage) endpoint.appLogger.error('Function executed!',someObjectOrMessage) } Note: Debug logs will exclusively appear within development and staging environment monitors.
Establishing a proxy endpoint # Before you can initiate the local execution of your endpoint, it&rsquo;s essential to configure a proxy endpoint within the app you intend to use for testing your endpoint&rsquo;s development. For detailed guidance, refer to Create Your Own Endpoints.
Upon adding a new Proxy endpoint to your app, you will be prompted to input the Endpoint URI within the configuration. We recommend utilizing ngrok in lieu of opening a port on your router. Through ngrok, you can configure a URI as demonstrated below:
./ngrok http 10000 This will provide both an HTTP and an HTTPS URL. Opt for the HTTPS URL, as it&rsquo;s more secure. Copy this HTTPS URL into your endpoint&rsquo;s configuration.
Regarding the token, we advise retaining the automatically generated token, unless you possess a specific reason to opt otherwise.
Upon creating the endpoint, you will encounter a configuration similar to the example below:
_endpoint_name=proxy _app_name=yourtestapp _environment=dev _pod_id=id _profile=default _custom_domain= _debug=true _local_deployment=true _base_domain=slingrs.io _webservices_port=10000 _endpoints_services_api=https://yourtestapp.slingrs.io/dev/endpoints/proxy/api _token=91833a8b-929f-4eab-b7b4-2383c10cd629 _endpoint_config={} You should duplicate this configuration and place it within your .env file. Remember, the final property, _endpoint_config, necessitates a valid JSON containing your endpoint&rsquo;s configuration. Thus, you might need to customize this aspect.
If you&rsquo;ve employed the skeleton endpoint, your configuration might resemble the following:
_endpoint_name=proxy _app_name=yourtestapp _environment=dev _pod_id=id _profile=default _custom_domain= _debug=true _local_deployment=true _base_domain=slingrs.io _webservices_port=10000 _endpoints_services_api=https://yourtestapp.slingrs.io/dev/endpoints/proxy/api _token=91833a8b-929f-4eab-b7b4-2383c10cd629 _endpoint_config={&quot;token&quot;:&quot;123456&quot;} Please note that the .env file is only relevant when running the endpoint locally. It doesn&rsquo;t impact the endpoint&rsquo;s behavior when operating in the cloud, as the endpoint configuration is conveyed through a different mechanism.
Should the need arise, you can maintain multiple .env files for distinct environments or setups. For instance, you could incorporate supplementary files like .staging.env or .myCustomEnv.env. In such scenarios, you must run your endpoint with the NODE_ENV environment variable aligned with the respective file&rsquo;s name. For guidance on setting environment variables across various operating systems and terminals, refer to this resource. By default, the .env file is loaded.
Once you have established the proxy endpoint within your app, remember to commit and push changes to initiate the setup.
Executing your endpoint # Before you execute your endpoint, ensure that you have installed all the required dependencies:
cd ENDPOINT_FOLDER npm install Following this, you can proceed to run your endpoint either from the command line or through your integrated development environment (IDE):
node endpoint.js or
npm start Alternatively, you have the option to create a personalized start script within the package.json file.
Testing the functionality of your endpoint # With your endpoint operational and the proxy endpoint configured, it&rsquo;s prudent to conduct a swift test to ensure all components are functioning as intended. To execute this test, implement the provided code within your builder or monitor console:
var res = app.endpoints.proxy.randomNumber({}); log('res: '+JSON.stringify(res)); Upon execution, you should observe an output resembling the following:
res: {&quot;number&quot;:5560} Please note that we are making the assumption that you are utilizing the skeleton endpoint template, where this method is readily accessible. In case you are employing a different template, make sure to invoke a method that exists within your endpoint.
Additional examples # The Slingr platform boasts an array of pre-developed endpoints, providing numerous features within the endpoint framework. To explore further functionalities within the endpoint framework, consider browsing through this repository.
`}),e.add({id:50,href:"/extensions/migrations/extending-platform/proxy-endpoint/",title:"Proxy Endpoint",description:`Overview # This endpoint acts as a proxy for an endpoint running on your local server within the Slingr platform. It&rsquo;s primarily designed for endpoint development. For more details, refer to the &ldquo;Create Your Own Endpoint&rdquo; section.
Configuration # Endpoint URI # The endpoint URI is the address at which both the external service and Slingr can locate your local endpoint. This should be a public URL (you might need to set up port forwarding on your router).`,content:`Overview # This endpoint acts as a proxy for an endpoint running on your local server within the Slingr platform. It&rsquo;s primarily designed for endpoint development. For more details, refer to the &ldquo;Create Your Own Endpoint&rdquo; section.
Configuration # Endpoint URI # The endpoint URI is the address at which both the external service and Slingr can locate your local endpoint. This should be a public URL (you might need to set up port forwarding on your router). It should point to the TCP port specified by _webservices_port (default TCP port 10000). Alternatively, you can use ngrok for added convenience, which creates a secure tunnel to your localhost.
Endpoint Token # This token serves as a verification mechanism for validating messages sent to and received from the proxy endpoint. While we recommend using the auto-generated token, you have the option to modify it if needed. This token will be part of your local endpoint configuration (see below).
Local Endpoint Configuration # Here is the fundamental configuration that should be applied to your local endpoint. Consult the SDK documentation you&rsquo;re using to find out where this configuration needs to be placed.
Javascript API # The Javascript API is determined by the functions and scripts within your endpoint. To understand the range of possibilities, please review the &ldquo;Endpoint Features&rdquo; section.
Events # Events are specified within your endpoint&rsquo;s configuration file. For more details, refer to the &ldquo;Endpoint Features&rdquo; section.
`}),e.add({id:51,href:"/dev-reference/environment-settings/ui-settings/",title:"UI settings",description:`These settings hold a global influence on the app&rsquo;s user interface (UI), impacting its appearance and behavior.
Theme # You can select from a range of themes that will alter the styling of the app, including color schemes. Enabling a different theme results in a comprehensive visual update across all app components.
Show icons # By disabling this option, buttons and menu choices within the app will not display icons. This option is enabled by default.`,content:`These settings hold a global influence on the app&rsquo;s user interface (UI), impacting its appearance and behavior.
Theme # You can select from a range of themes that will alter the styling of the app, including color schemes. Enabling a different theme results in a comprehensive visual update across all app components.
Show icons # By disabling this option, buttons and menu choices within the app will not display icons. This option is enabled by default.
Header # Show app logo # When enabled, the app&rsquo;s logo will be presented within the header.
Show app label # Upon activation, the app&rsquo;s label will be showcased within the header. An additional setting named Show App Label in Uppercase becomes accessible, allowing you to determine whether the label should be presented in uppercase or its original format.
Login # Show default identity provider # If you have multiple identity providers configured and wish to exclude the default provider from view, you can deactivate this flag. This is particularly useful when, for instance, you&rsquo;ve established an identity provider for Slack and want to prevent users from encountering the Login with &lt;App Label&gt; button.
However, if no additional identity providers are configured, this flag has no effect.
Show app logo # Upon activation, the app&rsquo;s logo will be displayed on the login page.
Show background image # Enabling this option will exhibit the background image that was previously set within the developer portal on the login page.
Change login panel color # When this option is enabled, you have the liberty to define the background color for the login page.
Login panel opacity # This setting allows you to adjust the opacity of the login panel, with values ranging from zero to one hundred.
`}),e.add({id:52,href:"/dev-reference/environment-settings/logs-and-alerts/",title:"Logs and alerts settings",description:`These are crucial app-wide settings accessible through the app builder under Environment Settings &gt; Logs and Alerts.
Logs size # The Logs Size setting allows you to determine the maximum space occupied by the logs collection in memory. It&rsquo;s important to note that this is an inherent attribute of the database engine and generally exceeds the actual size utilized within the database.
Enable cold logs # This toggle, Enable Cold Logs, empowers you to archive historical app logs into files.`,content:`These are crucial app-wide settings accessible through the app builder under Environment Settings &gt; Logs and Alerts.
Logs size # The Logs Size setting allows you to determine the maximum space occupied by the logs collection in memory. It&rsquo;s important to note that this is an inherent attribute of the database engine and generally exceeds the actual size utilized within the database.
Enable cold logs # This toggle, Enable Cold Logs, empowers you to archive historical app logs into files. You can establish a Storage Period that signifies how long files should be retained in storage. This time frame can be indicated in terms of months or years.
Alerts configuration # The alerts feature is designed to send notifications to developers whenever specific events occur during app execution. For instance, if an error is logged, the responsible developer can receive an email containing information about the error.
To activate alerts, enable the Enable Alerts flag. Subsequently, other configuration options will become accessible:
Level: Alerts are based on the app&rsquo;s logs, enabling you to specify which types of logs trigger alerts. You have two options: Only Errors: Alerts will be dispatched exclusively for logs with the ERROR level. Errors and Warnings: Alerts will be dispatched for logs with either the ERROR or WARN levels. Report Threshold: This determines the maximum alert frequency the app will generate. Particularly useful when dealing with recurring errors that you don&rsquo;t want to inundate developers with. Users to Notify: Designates the developers who will receive the alerts. Emails to Notify: In scenarios where notifications need to be sent to individuals who aren&rsquo;t app users, you can provide email addresses. Alerts will be sent to these addresses as well. `}),e.add({id:53,href:"/getting-started/getting/first-steps/event-planner/firstchanges/",title:"First changes",description:`In this section, we are going to take our first steps with the builder. If you are in the developer portal, you should see an app card similar to the one shown in the image:
Open the builder # 👉 Click on the button on the right (the one with the wrench icon 🔧 ) to open the builder in a new tab.
In this section, we are going to add a new field to the events.`,content:`In this section, we are going to take our first steps with the builder. If you are in the developer portal, you should see an app card similar to the one shown in the image:
Open the builder # 👉 Click on the button on the right (the one with the wrench icon 🔧 ) to open the builder in a new tab.
In this section, we are going to add a new field to the events. This can be used to improve metrics related to the events, for example. Alright, let&rsquo;s get to work.
👉 If you are in the builder, you should be seeing something like this:
Go to &ldquo;App navigation&rdquo; tree # On the left, you will see a tab called &ldquo;App navigation&rdquo; with a tree inside. Each item here is referred to as a &ldquo;Node&rdquo; (Marked in red in the image above). Clicking on these nodes will allow you to navigate through the different pages of the builder. Some nodes have extra functionalities accessible through the right-click option. You will be able to distinguish them because when you hover over them, an arrow will appear like this:
Create the field # Great! Now that we know how to navigate through the builder, let&rsquo;s go ahead and add our new field to the events entity. To do so, follow these steps:
👉 Right-click on the node Model &gt; Entities &gt; Events &gt; Fields, and a dropdown menu will be shown.
👉 Click on &ldquo;New Field&rdquo;.
👉 Fill in the form with the following details:
Label: Status Name: status Type: Choice Values: 1. Active 2. Done 3. Cancel Save and Edit the field. # 👉 Click on Create and Edit.
👉 Set the default value to Active.
👉 Click on Save.
Push Changes # Awesome! We&rsquo;ve made a small improvement to our app. To see the changes reflected in the runtime, follow these steps:
👉 On the header of the builder, click the button next to your name (The hamburger button).
👉 A dropdown menu will be shown. Click on &ldquo;Push Changes.&rdquo;
👉 A popup will appear, displaying the changes you have made. Review them, and if everything looks good, click on &ldquo;Push Changes.&rdquo;
🥳
Fantastic!
We have finished with the builder for now. In the next section, we will see our changes in action.
Let&rsquo;s move on to the next section: &ldquo;First Look at Our New App.&rdquo;
`}),e.add({id:54,href:"/dev-reference/environment-settings/localization/",title:"Localization",description:`These are comprehensive app-wide settings found within the app builder under Environment Settings &gt; Localization.
Timezone # The Timezone setting designates the default timezone for the app. This default timezone is utilized in scenarios where no user is associated with the ongoing execution context. For instance, if an event originates from a global legacy service without a specific user triggering it, the default timezone is applied. Moreover, it serves as the default for time listeners, although this can be modified.`,content:`These are comprehensive app-wide settings found within the app builder under Environment Settings &gt; Localization.
Timezone # The Timezone setting designates the default timezone for the app. This default timezone is utilized in scenarios where no user is associated with the ongoing execution context. For instance, if an event originates from a global legacy service without a specific user triggering it, the default timezone is applied. Moreover, it serves as the default for time listeners, although this can be modified.
Language # The Language setting establishes the default language for the app. It&rsquo;s important to note that if the app isn&rsquo;t appropriately internationalized, you might encounter a mixture of languages within the interface.
✅ It&rsquo;s worth highlighting that users possess the ability to configure their own localization preferences within their profiles. These individual settings will supersede the app-wide localization settings. `}),e.add({id:55,href:"/platform-ref/slingr-dev-portal/",title:"Slingr developer portal",description:"",content:""}),e.add({id:56,href:"/dev-reference/environment-settings/api-tokens/",title:"API Tokens",description:`API Tokens serve as credentials for accessing the REST API. Developers are responsible for configuring appropriate permissions for these tokens, which helps restrict access to sensitive information.
The automatically generated key is the essential component that must be utilized in each REST API request. It should be included in the request header under the token parameter.
Public token properties # A public token consists of the following properties:
Label: A human-readable label designed to identify the public token.`,content:`API Tokens serve as credentials for accessing the REST API. Developers are responsible for configuring appropriate permissions for these tokens, which helps restrict access to sensitive information.
The automatically generated key is the essential component that must be utilized in each REST API request. It should be included in the request header under the token parameter.
Public token properties # A public token consists of the following properties:
Label: A human-readable label designed to identify the public token. Name: A unique code allocated to the public token for identification purposes. User: The user associated with the token. The calculation of permissions is based on this user&rsquo;s permissions. It&rsquo;s recommended to employ a REST API user with carefully restricted permissions for security. Key: The key that must be used in every call to the REST API. This value is set as the token header in the request. Allowed Domains: This property offers a security mechanism to control the origins of requests. Wildcards (*) are permitted. For instance: https://*.slingrs.io. `}),e.add({id:57,href:"/dev-reference/data-model-and-logic/",title:"Data model and logic",description:"",content:""}),e.add({id:58,href:"/dev-reference/data-model-and-logic/entities/",title:"Entities",description:`Entities are the fundamental concept in a Slingr app. They define both the data structure and the behavior of an app. Entities can represent various entities like companies, people, tasks, projects, and more.
Once an entity is created, you can create records within that entity. For instance, if you have an entity named companies, each individual company under that entity will be treated as a record.
An entity defines the following aspects:`,content:`Entities are the fundamental concept in a Slingr app. They define both the data structure and the behavior of an app. Entities can represent various entities like companies, people, tasks, projects, and more.
Once an entity is created, you can create records within that entity. For instance, if you have an entity named companies, each individual company under that entity will be treated as a record.
An entity defines the following aspects:
Settings: These encompass details such as name, label, history logs, indexes, etc. Fields: Fields establish the structure of the entity, affecting both the database and the UI. Actions: Here, you can define the &ldquo;behavior&rdquo; or actions associated with the entity. Permissions: Specify who has access to operations, actions, and fields within the entity. Settings # Label # The label represents a human-readable name for the entity. It can include spaces, special characters, and a mixture of uppercase and lowercase letters.
This label is used as a reference for the entity within the user interface. Changing the label of an entity does not require any data restructuring.
Name # The name is the internal identifier for the entity. It cannot contain special characters or spaces.
This name serves various purposes within the app:
Database: Records for the entity are stored under this name. REST API: The automatically generated REST API uses this name for URLs. Scripts: Scripts often reference the entity by its name. Changing the entity&rsquo;s name impacts all of the above aspects.
Database changes are handled automatically by the platform when changes are pushed, eliminating the need for manual intervention.
Changes in the REST API are also managed automatically. However, if external apps are using the REST API, those apps might require adjustments.
Scripts using the entity name need manual updates. We plan to provide assistance for these cases in the near future.
Type # The type setting defines the behavior of the entity:
Data: This signifies that the entity holds app data. It&rsquo;s the default and most common option. Data in this entity is excluded from backups and doesn&rsquo;t synchronize between environments and linked apps. Enum: These entities usually contain a small number of records that contribute to the app&rsquo;s metadata, such as order types or states. Records in this entity are included in backups and synchronized across environments and linked apps. Sync behavior options include: Not syncing: The entity acts like a data entity, with no record synchronization. Create new records: Only new records are synced; existing records in the target environment aren&rsquo;t deleted or updated. Create and update records: New and existing records are synced; changes to existing records in the target environment are overwritten. Full sync: Synchronization ensures records in the target environment match those in the source environment, potentially leading to record deletions. Calculated: This type calculates entity data. It&rsquo;s useful for representing external data in the app, and behaves the same as Data entities. System: Platform-created and managed entities that can be extended with custom configurations like fields and actions. Autogenerated metadata for these entities is immutable. They reside under the System folder. An example is the Users entity, created during app provisioning. Parent entity # Entities can inherit from other entities, reducing redundancy in the app.
Inheriting from a parent entity provides access to the parent entity&rsquo;s fields, actions, and indexes within the child entity.
Abstract # Setting an entity as abstract when inheriting means instances of this entity won&rsquo;t exist. Views can&rsquo;t be created for abstract entities.
Record label # Records possess a label used as a summary in various app contexts. For instance, in relationship fields, the label appears when selecting a record.
Typically, the label should represent the record&rsquo;s content. For example, if the entity contains individual information, the label could be the person&rsquo;s full name.
Two methods exist to define record labels:
Field: Select an entity field whose string value serves as the record&rsquo;s label. Script: For more flexibility, write a script returning the record&rsquo;s label. Parameters # Name Type Description record sys.data.Record The record where the label is being calculated. Returns # string - You should return the label of the record.
Samples # // builds the label using first and last names return record.field('firstName').val()+' '+record.field('lastName').val(); Modifying the record label definition triggers data refactorings across the entity&rsquo;s records. This also applies to records within entities that possess relationship fields pointing to records in the entity where the label was altered.
Indexes # Indexes play a crucial role in enhancing query performance and follow the principles of traditional databases. For instance, if your entity comprises a substantial number of records and you frequently query by the sku field, creating an index for the sku field can significantly expedite those queries and mitigate the need for full scans.
Indexes can be generated directly within the Indexes section of an entity. Alternatively, they are automatically generated when you designate a field as Unique or Indexable.
Each index encompasses the following properties:
Name: This signifies the index name in the database. It is automatically computed and unalterable. Type: The index type is automatically determined based on the chosen fields. Possible types encompass: Normal: Regular indexes. Relationship: Created for fields applied to relationships, users, groups, or files. Comprises ID and label indexes. Compound: Generated when multiple fields are selected. Status: Denotes the present index creation status. While you can create the index in the builder, it won&rsquo;t manifest in the database until changes are pushed or synced. During index creation, potential issues might arise, and the status helps ensure successful creation. Unique: This flag indicates whether index values must be unique. If duplicate values exist in existing records, index creation will fail. Fields: Lists the fields forming the index. Remember that in queries, all indexed fields must be queried to utilize the index effectively. Adding or removing indexes results in the construction or removal of indexes, which can be time-consuming for entities with numerous records. It&rsquo;s important to note that indexes entail overhead during record creation, update, and deletion, as they need to be updated. Hence, make sure to only generate indexes when they are genuinely essential.
Global search # Enabling the Allow Global Search flag initiates index creation, thereby enabling efficient word-based querying across all fields of the record. This feature significantly enhances the ability to search across the contents of various fields.
For more details on how Global Search operates, refer to this documentation.
Record validations # Record validations empower you to execute intricate validations encompassing all fields within a record. Moreover, they facilitate interaction with external services, capabilities that are beyond the scope of field-level rules.
For instance, you might possess an endpoint for address validation services that can be utilized to validate addresses. Alternatively, you might require certain fields to conform to specific patterns when specific options are selected.
This is the script context:
Parameters # Name Type Description record sys.data.Record The record to validate. Returns # object[] - You should return an array of errors.
To handle errors effectively, return an array of error objects following this structure:
path: This corresponds to the field&rsquo;s location with issues. For nested fields like address.zipCode, provide the full path. For multi-valued fields, specify the index, such as addresses[1].zipCode.
code: Assign an appropriate error code. This code will be included in the response when attempting to create/update a record via the REST API or as exception information when saving a record with the JavaScript API.
message: Craft a descriptive error message that will not only be displayed in the user interface but also sent in response, along with the associated error code.
[ { path: 'addressLine', code: 'invalid', message: 'This is not a valid US address' },{ path: 'zipCode', code: 'invalid', message: 'This is not a valid US zip code' } ] Samples # // validates the zip code using an external service var errors = []; var zipCode = record.field('address.zipCode').val(); if (!app.endpoints.addressValidator.isValidZipCode(zipCode)) { errors.push({ path: 'address.zipCode', code: 'invalid', message: 'This is not a valid US zip code' }); } return errors; Lookup fields # Fields configured with this feature are considered during record retrieval. To look up a specific record, these fields are used in conjunction with the default system fields: ID and label.
Lookup fields require the unique flag to be enabled.
Detailed logs # This feature enables more detailed logging for various record operations: create, edit, delete, and the execution of actions on data records.
Activate this feature at the entity level through this setting:
Enable Detailed Logging: Toggle to enable detailed logging for record operations. History logs # This feature allows you to log changes in records, which is useful for auditing purposes. You can track when a record was created, the different changes made to it over time, as well as the modified fields and people involved in those changes.
When history logs are enabled for an entity, you can query logs for a specific record (or even all records at the same time) using the REST API or the UI. See History for more details.
Several settings control what gets logged in the history of records:
Logs Expiration: Define rules to determine when logs should expire. Delete Policy: Indicate what to do with the history of a record when it is deleted. Delete History with Record: Delete the history logs when the record is deleted. Keep History: Keep the history logs of the record. When this option is selected, specify how long the history logs will be kept (e.g., number of days, weeks, or months). User Events: Track changes made as a consequence of an external request, such as from the REST API or the UI. These events include: Ignore Fields: Exclude specific fields from change tracking when changes are made through the REST API or the UI. This can be useful for fields that are updated frequently or contain extensive content. Record Created: Log the creation of records via the REST API or the UI. Record Changed: Log updates to records via the REST API or the UI. Record Deleted: Log record deletions via the REST API or the UI. Action Executed: Log the execution of actions on individual records via the REST API or the UI. Events from Scripts: These are events generated from scripts in the app, such as when a script uses the method &lsquo;sys.data.save()&rsquo;. Ignore Fields: Exclude specific fields from change tracking when changes are made from a script in the app. This can be useful for fields that are updated frequently or contain extensive content. Record Created: Log the creation of records from a script in the app. Record Changed: Log updates to records from a script in the app. Record Deleted: Log record deletions from a script in the app. Action Executed: Log the execution of actions on individual records from a script in the app. System Events: These events result as side effects of other operations. For example, updating the label of a record that is referenced by another record will update the relationship. Generally, you don&rsquo;t want to track these kinds of changes. Cascade Updates: These events are generated when a change in one record needs to be propagated to other records. For instance, when copied fields in a relationship field are updated in a record, they need to be copied to relationship fields referencing that record. Refactorings: If this flag is set, when changes are made in the entity definition that lead to refactorings on records (e.g., field deletion or label changes), a log for it will be created. Data generation settings # These settings are only available for Calculated Entities.
Schedule time expression # This expression determines when the script for generating data should run. The minimum supported frequency is 15 minutes. Refer to this documentation for more information on the format of the expression.
Condition type # Choose whether data should always be generated when the time expression is met or if you want to evaluate it using a script.
Condition # This script determines if data should be regenerated and is only available if you choose Script as the condition type. The script should return true if regeneration is necessary or false otherwise. The Data Generation Script will only run if this script returns true.
Data generation script # This script should return a list of either Record objects or JSON objects that can be mapped to a Record object.
Behavior during regeneration # This flag allows to configure the behavior when data it’s being generated. It applies to data queries.
If the flag it’s set to true, when trying to read any data for this entity, if data it’s being generated at that moment, that read operation will wait until data generation ends. If the flag it’s set to false, when trying to read any data for this entity, if data it’s being generated at that moment, an AccessForbiddenException will be thrown. Fields # Fields define what information will be stored in records of the entity.
Slingr allows to have more complex structures than you usually can use in traditional relational database. For example it is allowed to have multi-valued fields as well as nested fields. These features make it is easy to define a more natural model.
For example you might have an entity with this structure:
name type phoneNumbers (multi-valued) addresses (multi-valued) addressLine zipCode state Each field has a type, which defines which data can be stored there as well as rules and display options. You can check the copied field types here.
Apart from the type-specific settings, all fields share some common features. For more details check Fields.
There are two special field types that are worth mentioning:
Nested fields: this type can hold other fields inside of it. This allows to have multiple levels of nesting. You can find more information here. Relationship: this type allows to reference another record of any entity. This way it is possible to create relationships between data. You can find more information here. Changes on fields and data refactorings # If you make changes to the structure of the entity by removing fields or making changes to existing fields in a way that affect the data structure (for example you change the field name), when those changes are pushed or synced, data refactorings will be done to adjust all records to the new structure.
For example if you rename a field from type to category, when changes are pushed or synced a refactoring over all records will be done to rename field type to category.
A more complex case happens when you change the type of the field. Let&rsquo;s suppose that the field itemCode was an integer field but it is changed to a text field. In this case the data refactoring will convert numbers to strings and the value will be preserved.
However, if you are converting in the other way around, the conversion might not be valid in some cases. For example if the value was the string &quot;10&quot;, then it can be safely converted to the number 10, but if the value was A10 then it is not a valid integer number and the field value will be set to null.
The rule during conversions is that the original value will be converted to its string representation, and the new type will try to parse that string representation. If the parsing fails, the value will be set to null.
Finally, another conversion that can affect the structure is multiplicity changes. If a field is changed from single-valued to multi-valued, existing value will be set as the first value in the field. On the other hand, if the multiplicity is changed from multi-valued to single-valued, only the first value will be kept, discarding any additional value of the field.
Changes in rules # If there are changes in the rules of a field, it is possible that records that were valid before are not longer valid. For example you have a text field and you add a maximum length of 10 characters. If there were already records with values longer than 10 characters for that field, those records won&rsquo;t be valid any longer.
When this happens records will be kept as they are. If you try to update them the validation error will show up and you will need to fix it before proceeding.
Actions # Actions allow to define some behavior on records. For example, in an entity that holds tasks, you could have an action to complete it, that will check that all pre-conditions are met, update the status and notify people involved in the task.
There are basically two types of actions:
One record: these actions are applied to one record at a time. Even when it is possible to select many records through the UI or send many IDs on the REST API, this action will be applied at one record at a time. The action doesn&rsquo;t know how many records are involved, it is only aware of the record the action is being applied. Many records: these actions take a query as parameter that defines the selection of records. This way the action knows all the records involved and it can do something with all of them at the same time. For example you could have an action to send a summary of many tasks in one email, which is not possible to do with actions that are executed over individual records. For more information about actions, please check the documentation for Actions.
Record listeners # Record Listeners can be hooked to different record events, like record created, changed, action executed, etc.
Those listeners will be listed in the entity, however they can also be managed from the Model &gt; Listeners section in the app builder.
For Caculated entities they have a different behavior. These listeners are used to update the records and they will be only listed in the calculated entity.
For more information check the documentation of Listeners.
External listeners # These listeners are only available for Caculated entities. External Listeners can be hooked to different record events, like record created, changed, action executed, etc.
Those listeners will be listed in the entity, however they can also be managed fromthe Model &gt; Listeners section in the app builder.
For more information check the documentation of Listeners.
Permissions # Permissions allow to define which operations can be done for each group on records of the entity.
Permissions for an entity can be handled right in the entity definition, but it is just a different view of what you can configure in groups. It is oriented so you can easily configure permissions on the entity for all existing groups.
When a new entity is added, no permissions are added to any group by default.
For more information about permissions please refer to Groups.
`}),e.add({id:59,href:"/dev-reference/data-model-and-logic/fields/",title:"Fields",description:`Fields serve as the fundamental units of data in Slingr apps. They primarily define the structure of entities, but also find utility in other contexts, such as parameters within actions.
A pivotal attribute of a field is its type, which determines the available options, rules, display preferences, and user interfaces for editing and reading. More information about types is available here.
Field settings are organized as follows:
Basic Settings: These foundational settings are essential for all fields.`,content:`Fields serve as the fundamental units of data in Slingr apps. They primarily define the structure of entities, but also find utility in other contexts, such as parameters within actions.
A pivotal attribute of a field is its type, which determines the available options, rules, display preferences, and user interfaces for editing and reading. More information about types is available here.
Field settings are organized as follows:
Basic Settings: These foundational settings are essential for all fields. They encompass the name, label, type, and multiplicity. All of these settings are mandatory. Rules: These settings influence value validation and storage in the database. For instance, designating a field as sensitive will result in encrypted database storage and exclusion from logs. There might also be type-specific rules, such as defining minimum and maximum values for an integer field. General Rules: These settings are universal across all types, though certain types may lack some options. Type-Specific Rules: These settings are tailored to each type. For instance, text fields offer rules for specifying the minimum and maximum string length. Display Options: Unlike rules, display options don&rsquo;t impact value validation or database storage. They focus solely on the field&rsquo;s appearance in the user interface. General Display Options: These overall settings influence how the field is visually presented, without affecting its value. For example, you can define label aesthetics and value indentation, but these settings won&rsquo;t dictate how field values are displayed. Type-Specific Display Options: These settings determine how the field&rsquo;s value is shown. For instance, in the case of a relationship field, you can choose to display the reference as a link. During editing, you might opt for a dropdown or selection boxes to choose a new value. For insights into type-specific settings, please refer to the Types documentation.
Basic settings # Label # This represents the human-readable field name. It&rsquo;s what appears in the UI when the field is displayed.
Display options can override this label, useful for showing distinct labels in specific contexts.
Name # This is the internal field name, used in the REST and JavaScript APIs, as well as for database storage within entities.
The name must not contain special characters or spaces; only letters and numbers are allowed.
Keep in mind that altering the field name can have ramifications:
Database: Renaming a field within an entity triggers data refactoring during pushes or syncs. For entities with substantial records, this renaming process might take some time. REST API: External apps utilizing this field through the REST API will require updates, as the field name changes. Scripts: If any app scripts reference this field in queries or for fetching values, manual updates to these scripts are necessary. Future tools are anticipated to aid in such cases. Type # The field&rsquo;s type determines the allowable content and its visual rendering. Each type is associated with specific rules and display options.
To explore available types and their features, please refer to the Types documentation.
When altering the field type, during pushes or syncs, the app will attempt to automatically convert existing values to the new type. The conversion rule is as follows: the original value will be transformed into its string representation, which will then be parsed by the new type. If parsing fails, the value will be set to null.
Note that changing a field&rsquo;s type may result in side effects:
Database: If the field was used within an entity, modifying its type might trigger data refactoring to adapt the value to the new type. REST API: External apps utilizing this field via the REST API may need updates due to potential changes in the field&rsquo;s format. For instance, if the field type shifts from integer to text, the REST API will return a string instead of a number. Scripts: If there were scripts in the app referencing this field, updates might be necessary, especially if the scripts relied on type-specific features. Multiplicity # Multiplicity indicates whether the field can store one or multiple values. For instance, you could have an emails field capable of holding multiple email addresses for users with more than one email.
Changing the multiplicity of an existing field triggers automatic refactoring of existing records. If a field transitions from single-valued to multi-valued, the existing value becomes the first value in the field. Conversely, when shifting from multi-valued to single-valued, only the first value remains, discarding any additional values.
Note that changing field multiplicity might entail side effects:
Database: If the field was used within an entity, alterations to multiplicity may trigger data refactoring during pushes or syncs to adjust the structure. REST API: External apps relying on the field through the REST API will require updates, as the field structure will change. Scripts: Scripts referencing this field in the app may need updating if they make assumptions about the field&rsquo;s multiplicity. General rules # Default value # You can set a default value for a field. The behavior varies based on the context:
Entity Field: The default value applies solely when creating a new record; it won&rsquo;t affect editing existing records. Action's Parameter: The default value takes effect only if the parameter is empty. Usually, changing this setting doesn&rsquo;t trigger any refactoring and mainly affects new records. However, if the field is also marked as required or if it&rsquo;s a newly added field, a refactoring might occur to assign the default value to all records where this field is empty or added.
Default values can be defined in two ways:
Value: You can choose a fixed value as the default.
Script: Alternatively, you can provide a script to calculate the default value. Here&rsquo;s the script context:
Parameters # Name Type Description record sys.data.Record This record is linked to the operation at hand. If the default value is for an entity field, this record encompasses the field. It&rsquo;s important to recognize that, in this context, the default value is generally computed before record creation. As a result, many fields might be empty in this phase. The only scenario in which other fields are populated is when introducing a new field or when the required flag has been added. Thus, during default value calculation, other fields might already be present.
If the field serves as an action parameter, this record pertains to the ongoing execution of the action. In such cases, the record contains values and is notably more informative. parentField sys.data.Record This variable exclusively comes into play when dealing with a field nested within another field. Its behavior aligns with the rules applicable to variables associated with records or actions (similar principles apply whether it&rsquo;s an action parameter or an entity field).
The variable takes the form of a sys.data.Record object, albeit with a distinction: the record&rsquo;s root is set to the encompassing nested fields. This arrangement facilitates access to fields within the nested group. For instance, you can utilize parentField.field('fieldA') instead of resorting to record.field('nested.fieldA') or action.field('nested.fieldA'). This feature proves especially invaluable when nested fields are multi-valued, as you are not required to know the index. action sys.data.Action This variable becomes accessible exclusively when the field serves as an action parameter. It grants access to other parameters, though it&rsquo;s important to note that these parameters might be devoid of content, unless an initial value has been designated. Returns # any or any[] - You should return the calculated value in the format used in the Javascript API for the type of the field. If the field is multi-valued, you should return an array.
Samples # // if current user has an email with 'slingr.io', set this field to 'true' let flag = false; const currentUser = sys.context.getCurrentUserRecord(); if (currentUser.field('email').val().indexOf('@slingr.io') != -1) { flag = true; } return flag; Required # Enabling this flag designates a field as required. A required field necessitates a value. This value can be explicitly set or drawn from the default value. If no value is furnished for the field and no default value exists, an attempt to save the record will trigger a validation error.
The available choices for the required flag are as follows:
Always: The field is consistently obligatory.
Script: The field&rsquo;s requirement hinges on the script&rsquo;s evaluation yielding true. Here&rsquo;s the script&rsquo;s context:
Parameters # Name Type Description record sys.data.Record This record is linked to the ongoing operation. If the field resides within an entity field, this record corresponds to the container of that field.
In the case of a field serving as an action parameter, this record pertains to the execution of the action. parentField sys.data.Record This variable is exclusively accessible when the field is situated within a nested field. It operates based on the variable record or action, adhering to the same principles applicable to action parameters or entity fields.
The variable assumes the form of a sys.data.Record object. The key distinction is that the record&rsquo;s root is set to encompass the nested fields in which it resides. This configuration facilitates the retrieval of fields within the nested group. For instance, you can employ parentField.field('fieldA') as an alternative to record.field('nested.fieldA') or action.field('nested.fieldA'). This feature proves particularly valuable in cases involving multi-valued nested fields where index awareness might be absent. action sys.data.Action This variable is accessible solely when the field functions as an action parameter. It facilitates access to other parameters. Returns # boolean - You should return true if the field must be required, false otherwise.
Samples # // if 'numberOfExmployees' is bigger than 10, then this field is required return record.field('numberOfEmployees').val() &gt; 10; Expression: The field becomes required if the expression evaluates to true. For further details, consult the Expressions documentation.
Never: The field remains non-required. This is the default setting.
Unique # This flag indicates whether the value must be unique across all records in the entity. When activated, the app enforces this validation.
Empty values will not be considered when assessing uniqueness. Consequently, numerous records may possess an empty field.
Activating this flag generates an index with respect to this field.
It&rsquo;s important to note that the flag can be enabled even if duplicated values exist in current records. Handling such cases of duplication will require manual intervention.
Indexable # Upon enabling this flag, an index will be established for the field. This can prove beneficial for enhancing performance in scenarios where querying using this field is frequent and the entity contains a substantial number of records.
Bear in mind that index creation introduces some overhead during record creation, updates, and deletions, as well as impacts storage requirements. Consequently, you should only set the indexable flag when it&rsquo;s genuinely necessary.
Unless you possess advance knowledge of which entities will amass numerous records and understand the anticipated data querying patterns, we recommend initially forgoing indexes and only introducing them as performance concerns emerge.
Transient # When this flag is activated, values won&rsquo;t be permanently stored in the database. However, you can still manipulate the values within these fields during record processing. For instance, if you have a listener that triggers when records are created, you can utilize the value of this field in the listener&rsquo;s script to perform specific actions.
Sensitive # Activating this flag triggers enhanced precautions when handling data within these fields:
For user-sent data that&rsquo;s logged, fields marked as sensitive will be masked. These fields will be encrypted in the database. When data is synchronized from production to another environment, the data in these fields will be obfuscated. This flag can be used in conjunction with the transient flag. For instance, it&rsquo;s illogical to avoid storing credit card information in the database if it&rsquo;s being logged in plain text. In such cases, when both flags are set, the data will be masked in logs and won&rsquo;t be stored or synced.
However, designating a field as sensitive carries certain limitations:
Filtering only functions for text fields, and searches must match the exact text (no partial matching). Sorting won&rsquo;t function for these fields. Read/Write access # This attribute indicates when the field can be read from and written to. Consider the following scenario with fields:
type (a choice field with options a, b, and c) subType (visible only if type is c) In this instance, you might want the subType field to only appear when type is set to c. This can be achieved using a read/write access condition on the subType field.
If you require distinct access rules for reading and writing, you can uncheck the Sync read/write flag. This allows you to define separate conditions for read and write access. Although uncommon, such a configuration might be necessary.
The available read/write access options include:
Always: The field is perpetually accessible.
Script: When the script returns true, the field becomes accessible; otherwise, it remains inaccessible. Here&rsquo;s the script&rsquo;s context:
Parameters # Name Type Description record sys.data.Record This record is linked to the ongoing operation. If the field resides within an entity field, this record corresponds to the container of that field.
In the case of a field serving as an action parameter, this record pertains to the execution of the action. parentField sys.data.Record This variable is exclusively accessible when the field is situated within a nested field. It operates based on the variable record or action, adhering to the same principles applicable to action parameters or entity fields.
The variable assumes the form of a sys.data.Record object. The key distinction is that the record&rsquo;s root is set to encompass the nested fields in which it resides. This configuration facilitates the retrieval of fields within the nested group. For instance, you can employ parentField.field('fieldA') as an alternative to record.field('nested.fieldA') or action.field('nested.fieldA'). This feature proves particularly valuable in cases involving multi-valued nested fields where index awareness might be absent. action sys.data.Action This variable is accessible solely when the field functions as an action parameter. It facilitates access to other parameters. Returns # boolean - You should return true if there is access to the field, false otherwise.
Samples # // if 'numberOfExmployees' is bigger than 10, then this field is visible return record.field('numberOfEmployees').val() &gt; 10; Expression: The field becomes accessible if the expression evaluates to true. More information is available in the Expressions documentation.
Never: The field will never be accessible. This option is relevant only when the Sync read/write flag is unchecked and you&rsquo;ve selected either the read or write option.
It&rsquo;s worth highlighting that access control here differs from permission settings. In this context, rules apply universally to all users, and there&rsquo;s no way to bypass these rules, even via scripting. In contrast, permissions don&rsquo;t affect developers and system users and are similarly disregarded in scripts.
Calculated value # Certain types permit the field to be calculated, implying that the field&rsquo;s value will be derived from other data, and users won&rsquo;t be able to manually set it.
Two approaches exist for calculating a value:
Script: In this scenario, you can furnish a script to compute the value. Here&rsquo;s the script&rsquo;s context:
Parameters # Name Type Description record sys.data.Record This record is linked to the ongoing operation. If the field resides within an entity field, this record corresponds to the container of that field.
In the case of a field serving as an action parameter, this record pertains to the execution of the action. parentField sys.data.Record This variable is exclusively accessible when the field is situated within a nested field. It operates based on the variable record or action, adhering to the same principles applicable to action parameters or entity fields.
The variable assumes the form of a sys.data.Record object. The key distinction is that the record&rsquo;s root is set to encompass the nested fields in which it resides. This configuration facilitates the retrieval of fields within the nested group. For instance, you can employ parentField.field('fieldA') as an alternative to record.field('nested.fieldA') or action.field('nested.fieldA'). This feature proves particularly valuable in cases involving multi-valued nested fields where index awareness might be absent. action sys.data.Action This variable is accessible solely when the field functions as an action parameter. It facilitates access to other parameters. Returns # any or any[] - You should return the calculated value in the format used in the Javascript API for the type of the field. If the field is multi-valued, you should return an array.
Samples # // calculate the total price from the unit price and quantity return record.field('unitPrice').val() * record.field('quantity').val(); Note: The accurate sequence of field calculations is automatically managed within the bounds of the current entity&rsquo;s scope. This signifies that if you invoke a script outside of the entity scope, any associated dependencies will not be monitored. For instance, when utilizing a library to compute values, ensure you make the call in the following manner:
var field1 = record.field('fiedl1').val(); var field2 = record.field('field2').val(); app.utils.foo(field1, field2); instead of: app.utils.foo(record); Aggregate: In this scenario, you can compute a value based on an aggregate query involving other records. For instance, if you possess an entity named departments and another named employees with a field labeled salary, you could create a field for calculating the average salary per department. This calculation would be an aggregation over the employees entity, considering records with the department field pointing to the department being evaluated. The aggregation would involve calculating an average over the salary field. This aggregation would be dynamically updated each time a salary changes or an employee is added or removed from a department. Thus, when you select the Aggregate calculation, you have access to the following options:
Aggregate Entity: The entity housing the records to be aggregated. In the aforementioned example, this would be the employees entity. Expression: This expression filters which records from the Aggregate Entity are included in the aggregation. In the earlier example, the expression filtered records by matching the Current Record with the department field, thus ensuring only employees from the current department contribute to the aggregation. Aggregate Operation: This operation dictates what action to perform. Options include: Count: This simply tallies the number of records matching the expression. Sum: It calculates the sum of values in the Aggregate Field (see below) for records fulfilling the expression. Avg: It computes the average of values in the Aggregate Field (see below) for records satisfying the expression. Aggregate Field: If the Aggregate Operation isn&rsquo;t Count, a field must be chosen to which the operation applies. In the example above, the selected field is salary. Custom validations # Custom validations enable the execution of intricate validations on the field, along with the use of services not available within field rules. In cases where the field is multi-valued, this validation will be triggered for each individual value. If you need to validate multiple values simultaneously, record validations should be employed.
For instance, consider a legacy service that utilizes an address validation service or the need to ensure a field value adheres to a specific pattern.
Here&rsquo;s the script&rsquo;s context:
Parameters # Name Type Description record sys.data.Record The record that contains the field to validate. parentField sys.data.Record This variable is exclusively accessible when the field is situated within a nested field. It operates based on the variable record or action, adhering to the same principles applicable to action parameters or entity fields.
The variable assumes the form of a sys.data.Record object. The key distinction is that the record&rsquo;s root is set to encompass the nested fields in which it resides. This configuration facilitates the retrieval of fields within the nested group. For instance, you can employ parentField.field('fieldA') as an alternative to record.field('nested.fieldA') or action.field('nested.fieldA'). This feature proves particularly valuable in cases involving multi-valued nested fields where index awareness might be absent. field sys.data.Wrapper The field wrapper to be validated. For more details on how to manipulate it, refer to the documentation for sys.data.Wrapper. action sys.data.Action This variable will be available only if the field is an action parameter. It will provide access to other parameters, but keep in mind that they might be empty (except that they have an initial value set). Returns # object - You should return an object representing the error, something like this:
{code: 'invalid', message: 'This is not a valid US zip code'} Where code represents the error code. You can use any value that aligns with your context. This value will be included in the response when attempting to create/update a record through the REST API or as part of the exception information when saving a record using the JavaScript API.
The message parameter corresponds to the text that will be showcased in the user interface. It will also be included in the response along with the code.
When the field is considered valid, no response is required.
Samples # // validates the zip code using an expression var zipValue = field.val(); if (zipValue &amp;&amp; !/(^\\d{5}$)|(^\\d{5}-\\d{4}$)/.test(zipValue)) { return {code: 'invalid', message: 'This is not a valid US zip code'}; } // validates the zip code using an external service var zipValue = field.val(); if (!app.endpoints.addressValidator.isValidZipCode(zipValue)) { return {code: 'invalid', message: 'This is not a valid US zip code'}; } Type rules # In this section, you configure rules that are specific to the field&rsquo;s data type. For instance, a text field will have rules that limit the length of the value, while choice fields will define valid options.
There are three methods to define type rules:
Custom: You manually define type rules for this field. To learn which rules are available for each data type, consult the Types documentation. Predefined: You can select one of the global type rules configured in the &ldquo;App &gt; Types&rdquo; section of the app builder. Refer to Global Type Settings. Field: You can reference an existing field within the entity and inherit its type rules. Consequently, if the type rules for the referenced field are altered, the rules for this field will be automatically updated. General display options # Read-Only # This indicates when the field should be perpetually displayed in read-only mode.
Remember that this setting solely influences the UI. Consequently, although the field appears read-only, it can still be modified using the REST API or in another view where this flag isn&rsquo;t enabled.
For instance, consider the following fields:
type (a choice field with options a, b, and c) subType (only editable if type is c) In this scenario, you desire the subType field to be editable exclusively when type is set to c. Achieving this involves employing a read-only condition on the subType field.
Read-Only has the following options:
Always: The field is consistently read-only.
Script: If the script returns true, the field becomes editable; otherwise, it remains read-only. Here&rsquo;s the script&rsquo;s context:
Parameters # Name Type Description record sys.data.Record This record is linked to the ongoing operation. If the field resides within an entity field, this record corresponds to the container of that field.
In the case of a field serving as an action parameter, this record pertains to the execution of the action. parentField sys.data.Record This variable is exclusively accessible when the field is situated within a nested field. It operates based on the variable record or action, adhering to the same principles applicable to action parameters or entity fields.
The variable assumes the form of a sys.data.Record object. The key distinction is that the record&rsquo;s root is set to encompass the nested fields in which it resides. This configuration facilitates the retrieval of fields within the nested group. For instance, you can employ parentField.field('fieldA') as an alternative to record.field('nested.fieldA') or action.field('nested.fieldA'). This feature proves particularly valuable in cases involving multi-valued nested fields where index awareness might be absent. action sys.data.Action This variable is accessible solely when the field functions as an action parameter. It facilitates access to other parameters. Returns # boolean - You should return true if there is access to the field, false otherwise.
Samples # // if 'numberOfExmployees' is bigger than 10, then this field is visible return record.field('numberOfEmployees').val() &gt; 10; Expression: The field becomes editable if the expression evaluates to true. Additional information is available in the Expressions documentation.
Never: The field will remain uneditable. This is the default option.
Visible # If set to Never, the field won&rsquo;t be displayed even when included in the view. This flag proves valuable, eliminating the need to manually remove the field from managed views.
Remember that this setting solely influences the UI.
For example, consider the following fields:
type (a choice field with options a, b, and c) subType (only visible if type is c) In this instance, you want the subType field to exclusively appear when type is set to c. This can be accomplished through a visibility condition applied to the subType field.
Visibility has the following options:
Always: The field is consistently visible. This is the default option.
Script: If the script returns true, the field becomes visible; otherwise, it remains hidden. Here&rsquo;s the script&rsquo;s context:
Parameters # Name Type Description record sys.data.Record This record is linked to the ongoing operation. If the field resides within an entity field, this record corresponds to the container of that field.
In the case of a field serving as an action parameter, this record pertains to the execution of the action. parentField sys.data.Record This variable is exclusively accessible when the field is situated within a nested field. It operates based on the variable record or action, adhering to the same principles applicable to action parameters or entity fields.
The variable assumes the form of a sys.data.Record object. The key distinction is that the record&rsquo;s root is set to encompass the nested fields in which it resides. This configuration facilitates the retrieval of fields within the nested group. For instance, you can employ parentField.field('fieldA') as an alternative to record.field('nested.fieldA') or action.field('nested.fieldA'). This feature proves particularly valuable in cases involving multi-valued nested fields where index awareness might be absent. action sys.data.Action This variable is accessible solely when the field functions as an action parameter. It facilitates access to other parameters. Returns # boolean - You should return true if there is access to the field, false otherwise.
Samples # // if 'numberOfExmployees' is bigger than 10, then this field is visible return record.field('numberOfEmployees').val() &gt; 10; Expression: The field becomes visible if the expression evaluates to true. More details can be found in the Expressions documentation.
Never: The field will never be visible.
Sorting # Indicates the sorting order for values:
Oldest to Newest: Oldest values appear at the top, and new values are inserted at the bottom of the list. This is the default. Newest to Oldest: Newest values appear at the top, and new values are inserted at the top as well. This option is only visible in fields with a multiplicity of Many.
Pagination # Enabling this flag results in paginated values. This prevents excessive space usage on the form if the field contains numerous values, allowing users to fetch additional values as needed. The default page size is 5.
This option is only visible in fields with a multiplicity of Many.
Page Size # When Pagination is enabled, this setting lets you define the number of values to display on each page. The default is 5.
Customize add button # Enabling this flag introduces additional options to customize the appearance of the &ldquo;Add&rdquo; button, used to add more values to the field.
This option is only visible in fields with a multiplicity of Many.
Text to append # When Customize Add Button is enabled, this setting determines the text appended to the button&rsquo;s label. For instance, setting this field to Note results in a button label of Add Note instead of just Add.
Label options # Show label # Indicates whether the label should be displayed. If the label is hidden, you can choose whether to indent the value using the Indent Value flag.
Override label # Enabling this flag permits overriding the default label. This can be useful in specific views where a distinct label is desired.
Indent value # If Show Label is not enabled, you can determine whether to indent the value. This flag controls this behavior.
Value options # Text alignment # Specifies text alignment for the read-only view. Possible values are Left, Center, or Right. Applicable to all data types except Nested Fields, File, Html, and Color.
Help message # An informational message displayed when hovering over the information icon next to the field&rsquo;s label. Developers can utilize this to explain the field&rsquo;s purpose. Only visible during editing.
Placeholder # Provides a brief hint describing the expected value of an input field.
Prepend addon type # Allows inclusion of an addon (Text or Icon) on the left side of the input field. Available for text and numeric data types. Disabled by default.
Prepend addon text # For Text addon type, specifies the text to add to the left side of the input field.
Prepend addon icon # For Icon addon type, specifies the icon to add to the left side of the input field.
Append addon type # Allows inclusion of an addon (Text or Icon) on the right side of the input field. Available for text and numeric data types. Disabled by default.
Append addon text # For Text addon type, specifies the text to add to the right side of the input field.
Append addon icon # For Icon addon type, specifies the icon to add to the right side of the input field.
Type display pptions # In this section, you configure display options specific to the data type. Three methods are available:
Custom: Manually define display options for this field. Refer to the Types documentation for available options for each type. Predefined: Select a global display option configured in the &ldquo;App &gt; Types&rdquo; section of the app builder. See Global Type Settings. Field: Reference an existing field in the entity to inherit its display options. Changes to display options in the referenced field will automatically update this field. Permissions # Permissions determine which groups have access to the field. Permissions are enforced in both the UI and the REST API.
Here, access permissions for the field can be specified. Options include:
Parent: Inherits permissions from the parent field. This is only available for fields within nested fields and is the default behavior. Read/Write: Users in this group can read and write to this field. Read Only: Users in this group can only read this field. If they attempt to modify the value during an update, the change will be silently discarded. None: Users in this group cannot read or write to this field. The field will be entirely omitted from both the UI and REST API. Advanced: Enables configuring read or write access separately, optionally based on record data using expression filters or scripts. This mirrors the capability of Read/Write Access in fields. When a new field is added to an entity, permissions are automatically set based on the group&rsquo;s access to the entity (Can Create or Can Edit set to Always or Condition). If there&rsquo;s only read access to the entity (Can Access set to Always or Condition), read-only access is granted to the field for that group. No permissions are automatically set otherwise.
For more information about permissions, refer to the Groups documentation.
`}),e.add({id:60,href:"/dev-reference/data-model-and-logic/actions/",title:"Actions",description:`Actions allow you to define behaviors for records within an entity beyond basic operations like creation or deletion. For example, in an entity that manages tasks, you could implement an action to mark a task as complete. This action might involve checking preconditions, updating the task&rsquo;s status, and notifying relevant parties.
Once an action is defined for an entity, it becomes accessible through the UI, the REST API, and the JavaScript API.`,content:`Actions allow you to define behaviors for records within an entity beyond basic operations like creation or deletion. For example, in an entity that manages tasks, you could implement an action to mark a task as complete. This action might involve checking preconditions, updating the task&rsquo;s status, and notifying relevant parties.
Once an action is defined for an entity, it becomes accessible through the UI, the REST API, and the JavaScript API.
Action settings # Label # This is the human-readable name of the action, which will be displayed in the UI.
Name # The name serves as the internal identifier for the action and is used in both the REST and JavaScript APIs.
The name must consist only of letters and numbers, without special characters or spaces. It&rsquo;s important to note that changing the action&rsquo;s name might have consequences:
REST API: External applications using this action through the REST API will need updates, as the action&rsquo;s URL will change. Scripts: Any scripts in the app referencing this action will require manual updates. Future tools are planned to aid in such cases. Type # The action&rsquo;s type indicates whether it is executed for each individual record or as a batch operation for a group of records:
One Record: These actions are applied to one record at a time, even if you can select multiple records through the UI or provide multiple IDs in the REST API. The action processes each record individually, unaware of the total number of records involved. Many Records: These actions accept a query parameter that defines the record selection. This allows the action to operate on all selected records simultaneously. For example, you could create an action to send a summary of multiple tasks in a single email—a task not feasible with actions targeted at individual records. Actions for many records lack options like restricting to a single record and setting preconditions. Global Entity: These actions do not receive any parameter to determine affected records. They appear in all grid views and workflow views under a special section called Global Actions. An example might be an action named &ldquo;Check Payment Status&rdquo; in the Payments entity. When executed, it would script to check the status of all pending payments. Visible # This option controls the visibility of the action. If set to Never, even if the action is present in the view, it will remain hidden. This feature spares you the need to manually remove the action from each view.
Keep in mind that this is solely a UI setting.
The Visible options are:
Always: The action is always visible (default option).
Expression: The action becomes visible if the specified expression evaluates to true. Refer to the documentation for Expressions for more information.
Script: The action&rsquo;s visibility depends on the return value of a script. If the script returns true, the action is visible; otherwise, it&rsquo;s hidden. Here&rsquo;s the script context:
Parameters # Name Type Description record sys.data.Record The record where the action will be executed.
This variable is only available if the type of the action is One record. Returns # boolean - true if conditions are met, false otherwise.
Samples # // make the action visible if the type is 'a' return record.field('type').val() == 'a'; Never: the action will be hidden.
Preconditions # For actions of type One record, you can define preconditions that determine the records on which the action can be applied. For instance, consider an entity named tasks with an action named complete. You might only want to allow this action when the status field is set to inProgress.
Preconditions can be established in two ways:
Expression: The action is executable on the record if the provided expression evaluates to true. Otherwise, the action won&rsquo;t be accessible in the UI, or it will result in an error when attempted through the REST or JavaScript API. For further details, consult the documentation on Expressions.
Script: The action is executable on the record if the script returns true. If not, the action won&rsquo;t appear in the UI or will result in an error when invoked via the REST or JavaScript API.
Parameters # Name Type Description record sys.data.Record The record where the action will be executed. Returns # boolean - true if preconditions are met, false otherwise.
Samples # // preconditions of the action are met if type is 'a' and current user is in group 'test' return record.field('type').val() == 'a' &amp;&amp; sys.context.getCurrentUser().containsGroup('test'); Result as response # For actions of type One record or Global entity, you can specify whether the action should return a custom response. If enabled, the result returned by the action script will be used as the response.
For actions of type Many records, the return value of the action script is always utilized as the response for the action.
Any value returned by the script and intended as a response is transformed into valid JSON (if needed). The Content-Type of the response is consistently set to application/json. If JSON conversion is not feasible, an error will be triggered.
This setting solely affects the behavior of the REST API and is irrelevant to the UI. The returned value will be included in the response body of the request.
Save linked parameters # For actions of type One record, it&rsquo;s possible to include linked parameters. Enabling this flag ensures that the record is automatically updated with the values from linked parameters. If this flag is not set, you will be responsible for saving the record within the action script to make the changes permanent.
It&rsquo;s important to note that if this option is set, a record changed event will be triggered before executing the action script (when the record is saved). If you save the record again within the action script, another record changed event will be triggered, in addition to the event triggered by the action itself.
Execute in background # If this flag is enabled, executing the action will immediately return with a reference to a job responsible for performing the action in the background.
For instance, when using the REST API to execute the action, instead of receiving the action&rsquo;s result, you will receive a job reference that indicates the action will be carried out in the background. To determine completion, you should monitor the status of the job.
This flag can be overridden for a specific call through the REST API or JavaScript API. Additionally, the UI might choose to override this flag. For instance, when multiple records are selected, the UI will always send the action to the background, even if this flag is not set.
When this flag is not enabled, calls to the action will wait for its completion and return the action&rsquo;s result.
For more information on actions in the REST API and JavaScript API, refer to the documentation.
Avoid triggering UI events # Enabling this flag for executing the action in the background will prevent UI notifications from being triggered. This is valuable for efficiency during execution, particularly in batch processing scenarios where notifying end-users about data changes is unnecessary.
Restrict to only one record # For actions of type One record, enabling this flag signifies that only a single record can be selected and the action can be executed. This is particularly applicable when there are parameters that are not meaningful to apply to multiple records simultaneously.
For instance, if the action&rsquo;s purpose is to update the title of a task, executing it on more than one record is illogical since the same title would be set for numerous tasks.
Action script # The action&rsquo;s core script is executed when the action is invoked. It runs when the action is executed in the UI (when the action&rsquo;s execution is confirmed), and it is the place where the action&rsquo;s intended operations should be carried out.
Parameters # Name Type Description record sys.data.Record The record where the action will be executed. This variable is only available if the type of the action is One record. oldRecord sys.data.Record The record before linked parameters are merged. This variable is only available if the type of the action is One record. query sys.data.Query A query object with filters to find all records afected by this action. This variable is only available if the type of the action is Many Records. action sys.data.Action This allows access to the parameters of the action. Samples # // updates some values in the record and save it var newValue = action.field('param1') * 10; record.field('field').val(newValue); sys.data.save(newValue); // many records actions that sums up the number of employees on selected companies var total = 0; var records = sys.data.find(query); while (records.hasNext()) { total += records.next().field('numberOfEmployees').val(); } return total; Custom validations # Custom validations for actions enable more intricate validations that span across all fields within the action. These validations can utilize external services or functionalities that aren&rsquo;t accessible through field rules.
For ONE_RECORD action types, the record is accessible within the script context. In the case of MANY_RECORDS, a Query object can be used to ascertain which records will be impacted.
For instance, consider an external endpoint for address validation that you can integrate to validate addresses. Alternatively, you might want to enforce a requirement that when a specific option is chosen in one field of the record or the action, another field&rsquo;s value must adhere to a specific pattern.
Here is the script context for these custom validations:
Parameters # Name Type Description record sys.data.Record The record where the action is executed. You can use this information on your validation rules. This parameter is only available when action type is ONE_RECORD query sys.data.Query A query object with filters to find all records afected by this action. This parameter is only available when action type is MANY_RECORDS action sys.data.Action The action to validate. Returns # object - You should return an array of errors, something like this:
[ { path: 'addressLine', code: 'invalid', message: 'Not a valid address when running this action' }, { path: 'zipCode', code: 'invalid', message: 'Wrong zip code' } ] Where path is the path to the field experiencing issues. For nested fields, the full path should be provided, such as address.zipCode. For multi-valued fields, the index should be indicated, like addresses[1].zipCode.
The code is an error code that you can define according to your needs. This code will be included in the response when attempting to execute the action using the REST API or the JavaScript API.
Finally, the message is what will be displayed in the UI and will also be included in the response along with the code.
Samples # // validates the zip code using an external service var errors = []; var zipCode = action.field('address.zipCode').val(); if (!app.endpoints.addressValidator.isValidZipCode(zipCode)) { errors.push({ path: 'address.zipCode', code: 'invalid', message: 'Wrong zip code' }); } return errors; Parameters # Parameters are fields that will be prompted for when the action is executed. For instance, when executing the action from the UI, a popup will appear asking the user to input values for the parameters configured in the action (refer to action views for more details on configuring the UI of an action).
Parameters can fall into three types:
Parameter: These fields are associated with the action itself, not the entity. They have their own configuration, and you&rsquo;re not required to store their values in the record (though you can copy the value to a record field within the action script if needed). Linked parameter: These fields are part of the entity&rsquo;s structure and settings, which means their structure and settings cannot be altered (except for display options in views). If the Saved linked parameters flag is enabled, these fields will be automatically updated in the record before executing the action script, which then triggers a record changed event. Entity field parameter: These parameters are also part of the entity but are not directly linked to the action. Instead, they are used within the context of the action and can be accessed through the record variable. For more information on configuring parameters, please refer to the Fields documentation.
Permissions # Permissions dictate which groups are granted the authority to execute the action. As with other aspects of the application, these permissions are enforced both in the UI and the REST API.
Upon adding a new action to an entity, if a group has permissions for all the actions in that entity, the action is automatically granted the Allowed permission.
Permissions for parameters can be configured within each parameter or at the group level.
Upon adding a new parameter to an action, if a group has permissions for the action, read-write permission is automatically assigned to that parameter within the group.
For more details on permissions, please consult the Groups documentation.
Views # To enable the execution of an action from the UI, a view must be defined. To simplify this process, a default view is automatically generated alongside the action. This default view is fully managed, meaning that new fields will be added or removed as you modify your actions. In most scenarios, you can simply rely on the default action views.
However, it&rsquo;s possible to define multiple views for a single action based on different settings required for various parts of the UI. For example, in a grid view, you might want to prompt users for confirmation before executing an action, since they can select multiple records. On the other hand, in a read-only view, skipping action confirmation can enhance efficiency.
Each view comes with the following settings:
Label: A user-friendly name for the action view, which users will see as the action&rsquo;s name. This label doesn&rsquo;t need to be unique. Name: A unique name for the action view, which cannot contain spaces or special characters. Is default view: Indicates whether this is the default view for the action. Default views are used, for instance, when you opt to display all actions in a grid view. In this case, only the default view of each action is listed, as it wouldn&rsquo;t make sense to display all views of each action in the same place. Managed: If this option is enabled, new parameters will be automatically incorporated into the view, and the order will be maintained between action parameters and the view. Ask for confirmation: Enabling this flag prompts users for confirmation before executing the action. This is useful when no parameters are defined in the view. Style: Specifies the style of the action button in the UI. Icon: Defines the icon displayed for the action in the UI. Events # Before show # The before show script is evaluated before the action is executed. In the UI, it runs before displaying the popup to the user, allowing you to make changes to parameters based on special conditions.
If multiple records are selected, the script is executed only once. You can determine which records will be affected by using the query parameter within the script.
Parameters # Name Type Description record sys.data.Record The record where the action will be executed.
This variable is only available if the type of the action is One record or if you are appliying the action to many records. query sys.data.Query A query object with filters to find all records afected by this action. Only for type Many records. action sys.data.Action This allows access to the parameters of the action. When the action is executed from the UI, changes made here will be reflected in the UI. Samples # // sets the default value as the email of the current user action.field('sendTo').val(sys.context.getCurrentUser().email()); On action change # The on action change script is evaluated each time a view parameter&rsquo;s value changes. Therefore, it is possible to modify parameters based on specific conditions.
You can identify the parameter that triggered the event by utilizing the modifiedParameter parameter within the script.
Parameters # Name Type Description record sys.data.Record The record where the action will be executed.
This variable is only available if the type of the action is One record or if you are appliying the action to many records. In case of on change event the record is read only. action sys.data.Action This allows access to the parameters of the action. When the action is executed from the UI, changes made here will be reflected in the UI. modifiedParameter string A string with the name of the field that fires the event. Samples # // sets the value as the email of the current user only if the field 'sendTo' has changed and is empty if (modifiedParameter == 'sendTo' &amp;&amp; action.field('sendTo').isEmpty()) { action.field('sendTo').val(sys.context.getCurrentUser().email()); } After action executed # The after action executed script is evaluated immediately after the user confirms the execution of the action (or when they initiate the action if the Ask for confirmation flag is not set). It&rsquo;s important to note that this evaluation occurs exclusively when the action is executed through the UI using this specific view.
If multiple records are selected, the script is executed only once. You can ascertain which records will be affected by employing the query parameter within the script.
Furthermore, if the action is dispatched to the background for execution, a job object becomes accessible. This job object refers to the job responsible for carrying out the action over the record(s).
Parameters # Name Type Description record sys.data.Record The record where the action will be executed.
This variable is only available if the type of the action is One record or if you are appliying the action to many records. query sys.data.Query A query object with filters to find all records afected by this action. Only for type Many records. action sys.data.Action Action object to access parameters of the action. job sys.jobs.job This is the job object, which is only available when the action is executed in background.
Keep in mind that the after action executed script is executed right after you triggered the action from the UI and the job might be still pending or running. Samples # // after action is executed redirect to read only view of given record var record = sys.data.findOne(query); sys.ui.sendMessage({ scope: 'global', name: 'navigate', view: '590ce2e38a2....', recordId: record.id() }); `}),e.add({id:61,href:"/dev-reference/data-model-and-logic/listeners/",title:"Listeners",description:`Listeners allow you to connect with various events within the app. For instance, you can listen to the creation of records or the reception of an event from an legacy service and take certain actions when these events occur.
Apart from event listening, it&rsquo;s also possible to schedule listeners to run periodically based on a CRON expression.
Label # This represents the human-readable name of the listener.
Name # This serves as the internal name of the listener.`,content:`Listeners allow you to connect with various events within the app. For instance, you can listen to the creation of records or the reception of an event from an legacy service and take certain actions when these events occur.
Apart from event listening, it&rsquo;s also possible to schedule listeners to run periodically based on a CRON expression.
Label # This represents the human-readable name of the listener.
Name # This serves as the internal name of the listener.
The name cannot include special characters or spaces, only letters and numbers are allowed.
Type # The listener type indicates the category of events it will be observing. The available types include:
Data: Data listeners can tap into data-related events such as record creation, record updates, or the execution of actions on records. When selecting this type, additional settings can be configured to filter the specific data events to be handled: Entity: The listener will focus on events within records under this entity. Events: Specifies which data events the listener will process. Refer to the Data events for more details. Legacy service: Legacy service listeners can intercept events sent from legacy services. For example, an HTTP legacy service can generate an event when a webhook is triggered, which can then be processed by a listener. When choosing this type, further settings can be customized to filter the events to be managed: Legacy services: The listener will be attuned to events generated by this specific legacy service. Event: Indicates the specific event to be considered. UI plugin: These listeners can capture events and callbacks originating from UI plugins. When opting for this type, you can specify additional settings to filter the events to be handled: Plugin: The plugin to which the listener will be attuned. Event: The event/callback emanating from the plugin. Job: Job listeners can respond to user events like job start or job completion. When selecting this type, additional settings can be defined to filter the job events to be handled: Job: The category of job that the listener will be observing. Event: Specifies the particular event to be considered. Time: Time listeners execute based on a CRON expression. When selecting this type, additional settings can be configured: Timezone: The timezone employed for the CRON expression. Expression: The expression determining when the listener will execute. For more information on the expression format, please review this documentation. Execute in the background # For certain event types (such as Data), you can decide whether the listener should execute synchronously or be sent to the background.
For instance, if this flag isn&rsquo;t enabled and the listener pertains to a record creation, the operation won&rsquo;t conclude until the listener&rsquo;s execution is finished. Therefore, you should enable this flag when the listener&rsquo;s execution might surpass an acceptable time frame for the ongoing operation.
Avoid Triggering UI events # Enabling this flag ensures that when the listener is triggered in the background, it bypasses sending notifications to the UI. This feature proves valuable in avoiding additional overhead during execution. A typical use case is executing a listener for batch processing, where notifying end users about data changes isn&rsquo;t necessary.
Action # This refers to the script that will be executed when the event is triggered. Depending on the event type, the script&rsquo;s context will differ.
Data listeners # Parameters # Name Type Description event object Contains information about the event. It has the following structure: {
&ldquo;type&rdquo;: &ldquo;DATA&rdquo;,
&ldquo;dataEvent&rdquo;: &ldquo;RECORD_CHANGED
}
- Possible values for dataEvent are: RECORD_CREATED, RECORD_CHANGED, RECORD_DELETED, CONDITION_MET, ACTION_PERFORMED. record sys.data.Record The record involved in the data operation.
There is one case where this variable will be empty, which when the event.dataEvent is ACTION_PERFORMED and the action executed was of type Many records. In this case, as the action is executed over a group of records, it isn’t possible to set a single record. oldRecord sys.data.Record If the event is of type RECORD_CHANGED, ACTION_PERFORMED, or CONDITION_MET, this variable will hold the version of the record before the event occurred. Samples # // logs a message when there is a data event (the listener is configured accordingly) sys.logs.info('*** EVENT: '+event.dataEvent); sys.logs.info('*** RECORD: '+record.label()); Legacy services listeners # Parameters # Name Type Description event object Contains information about the event. It has the following structure: {
&ldquo;type&rdquo;: &ldquo;ENDPOINT&rdquo;,
&ldquo;date&rdquo;: 1486673333420,
&ldquo;endpoint&rdquo;: &ldquo;sample&rdquo;,
&ldquo;endpointEvent&rdquo;: &ldquo;inboundEvent&rdquo;,
&ldquo;data&rdquo;: {
&ldquo;token&rdquo;: &ldquo;123456&rdquo;,
&ldquo;number&rdquo;: 4468
}
}
date is the timestamp when the event was sent.
endpoint is the name of the endpoint.
endpointEvent is the name of the event.
data is data sent by the endpoint which is specific for each event and you should check the documentation for each endpoint. Samples # // logs the data sent by the endpoint sys.logs.info('*** ENDPOINT: '+event.endpoint); sys.logs.info('*** EVENT: '+event.endpointEvent); sys.logs.info('*** DATA: '+event.data); Service listeners # Parameters # Name Type Description event object Contains information about the event. It has the following structure: {
&ldquo;type&rdquo;: &ldquo;SERVICE&rdquo;,
&ldquo;date&rdquo;: 1486673333420,
&ldquo;endpoint&rdquo;: &ldquo;sample&rdquo;,
&ldquo;endpointEvent&rdquo;: &ldquo;inboundEvent&rdquo;,
&ldquo;data&rdquo;: {
&ldquo;token&rdquo;: &ldquo;123456&rdquo;,
&ldquo;number&rdquo;: 4468
}
}
date is the timestamp when the event was sent.
service is the name of the service.
serviceEvent is the name of the event.
data is data sent by the endpoint which is specific for each event and you should check the documentation for each service. Samples # // logs the data sent by the package sys.logs.info('*** SERVICE: '+event.service); sys.logs.info('*** EVENT: '+event.serviceEvent); sys.logs.info('*** DATA: '+event.data); UI service listeners # Parameters # Name Type Description event object Contains information about the event. It has the following structure: {
&ldquo;type&rdquo;: &ldquo;UI_SERVICE&rdquo;,
&ldquo;date&rdquo;: 1486673333420,
&ldquo;uiService&rdquo;: &ldquo;sample&rdquo;,
&ldquo;event&rdquo;: &ldquo;event1&rdquo;,
&ldquo;callback&rdquo;: &ldquo;callback1&rdquo;,
&ldquo;data&rdquo;: {
&ldquo;originalMessage&rdquo;: {
&ldquo;companyId&rdquo;: &ldquo;ABC&rdquo;
},
&ldquo;callbackData&rdquo;: {
&ldquo;number&rdquo;: 1234,
&ldquo;text&rdquo;: &ldquo;hello&rdquo;
}
}
}
date is the timestamp when the event was sent.
uiService is the name of the uiService.
event is the name of the event.
callback is the name of the callback.
data is data sent by the callback request. Samples # // logs the data sent by the ui service sys.logs.info('*** UI_SERVICE: '+event.uiService); sys.logs.info('*** DATA: '+event.data); UI plugin listeners # Parameters # Name Type Description event object Contains information about the event. It has the following structure: {
&ldquo;type&rdquo;: &ldquo;PLUGIN&rdquo;,
&ldquo;date&rdquo;: 1486673333420,
&ldquo;plugin&rdquo;: &ldquo;sample&rdquo;,
&ldquo;event&rdquo;: &ldquo;event1&rdquo;,
&ldquo;callback&rdquo;: &ldquo;callback1&rdquo;,
&ldquo;data&rdquo;: {
&ldquo;originalMessage&rdquo;: {
&ldquo;companyId&rdquo;: &ldquo;ABC&rdquo;
},
&ldquo;callbackData&rdquo;: {
&ldquo;number&rdquo;: 1234,
&ldquo;text&rdquo;: &ldquo;hello&rdquo;
}
}
}
date is the timestamp when the event was sent.
plugin is the name of the plugin.
event is the name of the event.
callback is the name of the callback.
data is data sent by the callback request. Samples # // logs the data sent by the plugin sys.logs.info('*** PLUGIN: '+event.plugin); sys.logs.info('*** DATA: '+event.data); Job listeners # Parameters # Name Type Description event object Contains information about the event. It has the following structure: {
&ldquo;type&rdquo;: &ldquo;JOB&rdquo;,
&ldquo;jobType&rdquo;: &ldquo;IMPORT_RECORDS&rdquo;,
&ldquo;jobEvent&rdquo;: &ldquo;FINISHED&rdquo;,
&ldquo;jobId&rdquo;: &ldquo;589cdb2ae201af1d75ec2d83&rdquo;
}
jobType is the type of job
jobEvent is the event of the job that triggered the listener.
jobId is the ID of the job. You can use it to find the job and get more information about it. Samples # // finds job and checks if it had errors var job = sys.jobs.findById(event.jobId); sys.logs.info('*** ERRORS: '+job.hasErrors()); Time listeners # Parameters # Name Type Description event object Contains information about the event. It has the following structure: {
&ldquo;type&rdquo;: &ldquo;TIME&rdquo;
} Samples # // logs something when the timer is triggered sys.logs.info('*** TIME LISTENER!'); Custom event listeners # Parameters # Name Type Description event object Contains information about the event. It has the following structure: {
&ldquo;type&rdquo;: &ldquo;CUSTOM&rdquo;,
&ldquo;customEvent&rdquo;: &ldquo;newNote&rdquo;,
&ldquo;customData&rdquo;: {
&ldquo;noteId&rdquo;: &ldquo;589cdb2ae201af1d75ec2d83&rdquo;
}
}
customEvent is the name of custom event that triggered the listener.
customData is an object sent by user as data opf this custom event. Samples # // log note ID create sys.logs.info('*** NOTE CREATED: '+customData.noteId); Package event listeners # Parameters # Name Type Description event object Contains information about the event. It has the following structure: {
&ldquo;type&rdquo;: &ldquo;CUSTOM&rdquo;,
&ldquo;packageEvent&rdquo;: &ldquo;newNote&rdquo;,
&ldquo;package&rdquo;: &ldquo;newNote&rdquo;, &ldquo;data&rdquo;: {
&ldquo;messageContent&rdquo;: &ldquo;589cdb2ae201af1d75ec2d83&rdquo;
}
}
packageEvent is the name of the package event that triggered the listener.
data is an object sent by user as data of this package event. package is the name of the package. Samples # // log message content sys.logs.info('*** NEW MESSAGE CREATED: '+data.messageContent); `}),e.add({id:62,href:"/dev-reference/data-model-and-logic/libraries/",title:"Libraries",description:`Libraries are essentially JavaScript files where you can store code that is intended to be shared across various sections of your application. For instance, you might create a library to handle the encoding and decoding of strings, a functionality required in multiple actions throughout your application. Instead of duplicating these algorithms within each action, you can centralize them within a library and invoke them from your actions.
The structure of a library&rsquo;s code is depicted as follows:`,content:`Libraries are essentially JavaScript files where you can store code that is intended to be shared across various sections of your application. For instance, you might create a library to handle the encoding and decoding of strings, a functionality required in multiple actions throughout your application. Instead of duplicating these algorithms within each action, you can centralize them within a library and invoke them from your actions.
The structure of a library&rsquo;s code is depicted as follows:
var privateFunction = function(msg) { return '['+msg+']'; }; exports.logSomething = function(msg) { sys.logs.info('*** logged from library: '+privateFunction(msg)); }; The crucial component here is the exports variable. Any elements you wish to make available from the library should be added to this object. Otherwise, they will remain inaccessible, as demonstrated by the privateFunction in the preceding example.
To access the library, you can use the namespace app.&lt;libraryName&gt; from any script. For instance, if the library in the provided example is named utils, you can employ the library in this manner within any script of the application:
var msg = record.field('description').val(); app.utils.logSomething(msg); If an attempt is made to call app.utils.privateFunction(msg), an error will be thrown because that method was not exposed using the exports variable.
In the exports variable, you have the flexibility to include various entities; it need not be limited to functions alone. You could expose constants, as demonstrated below:
exports.MAX_ORDERS = 100; exports.MAX_AMOUNT = 50000; `}),e.add({id:63,href:"/dev-reference/data-model-and-logic/endpoints/",title:"Legacy services",description:`Legacy services are components that operate alongside your app. They possess their own resources and their primary purpose is to enhance the platform&rsquo;s capabilities.
A prevalent use case is establishing connections between your app and other applications through the utilization of APIs for sending, receiving, and retrieving data. For instance, endpoints exist for services like Slack, Google Contacts, Google Calendar, and various other widely-used cloud platforms. This allows your app to seamlessly leverage the functionalities provided by these external services.`,content:`Legacy services are components that operate alongside your app. They possess their own resources and their primary purpose is to enhance the platform&rsquo;s capabilities.
A prevalent use case is establishing connections between your app and other applications through the utilization of APIs for sending, receiving, and retrieving data. For instance, endpoints exist for services like Slack, Google Contacts, Google Calendar, and various other widely-used cloud platforms. This allows your app to seamlessly leverage the functionalities provided by these external services.
Global vs. user legacy services # There are two categories of legacy services:
Global legacy services: These legacy services boast a universal configuration for the entire app, irrespective of the user. For instance, the SparkPost legacy service falls under this category as its operations aren&rsquo;t tied to any specific app user. User legacy services: These legacy services feature both a global configuration and an individual configuration per user. This configuration is managed within the My integrations tab under My profile in the app runtime. This distinction becomes crucial when the external service necessitates awareness of the user initiating the calls. For instance, most Google legacy services require users to grant permissions so that all operations are executed on the user&rsquo;s behalf. Consider the Google Calendar legacy service configuration; each user must grant permission to access it. Two key considerations when employing user legacy services are: Valid Current User for Method Calls: When calling a method in the legacy service&rsquo;s API, the current user within the execution context must be connected to the legacy service. Failure to meet this requirement will result in an error. For instance, if a user creates a new record in a contacts entity, and the Slingr app user hasn&rsquo;t connected the Google Contacts endpoint, the attempt to create the contact in Google will fail. User-Based Event Generation: Events generated per user might lead to multiple events when you expect only one. For example, with a Google Contacts endpoint and a Contact updated event listener, creating a new contact in Google results in an event per user, rather than a single event. This means that if 10 users in your app are connected to the Google Contacts endpoint, you will receive 10 events, assuming all 10 users have permission to view the new contact. This behavior acknowledges that each user may have varying levels of access in the external system based on settings or security rules. This way, users without access to specific content won&rsquo;t receive irrelevant events, sparing the need to replicate security rules within your app. Legacy service configuration # While there are certain shared settings among legacy services, each legacy service may have distinct additional settings. Documentation for each specific legacy service should be consulted for detailed explanations of these settings.
Here, we will elucidate common settings.
Label # This stands as the human-readable legacy service name, serving no operational purpose during app execution.
Name # This internal legacy service name is used within the JavaScript API.
The name should exclusively consist of letters and numbers, with no special characters or spaces.
It&rsquo;s worth noting that altering the legacy service name could have ramifications for scripts referencing the legacy service. For example, if the name changed from slack to something like slackmaster, calls like app.endpoints.slack.* might need to be updated to app.endpoints.slackmaster.*. Although we intend to provide tools to assist in such cases, for now, changes must be made manually.
Initial status # This signifies the legacy service&rsquo;s initial status when first pushed or synced. This setting exclusively affects the initial deployment. Once the legacy service is pushed or synced, its status remains unchanged and should be modified through the app monitor.
This flag is particularly useful when constructing template apps that will be cloned, but you wish to delay legacy service deployment until they are configured. Thus, the initial status can be set to Undeployed, ensuring it remains inactive until configured and deployed.
Profile # Profiles represent distinct deployment configurations for a legacy service, encompassing resource allocation and other necessities. For instance, a Slack legacy service might feature profiles like Default, Medium team, and Big team, each accommodating a different number of concurrent Slack team users. The legacy service documentation should provide a comprehensive description of each profile, aiding in selecting the suitable one.
This setting is only applicable to legacy services that support multiple profiles.
Force end user configuration # This flag is exclusive to user legacy services. When enabled, users logging into the app will be prompted to configure the legacy service for their accounts. Although users can postpone this process and configure it later, the configuration screen will appear whenever they log in.
Groups # Applicable only to user legacy services, this setting designates which groups are permitted to use the legacy service. Selection can be made from all groups or specific ones. Users must belong to at least one selected group to access the legacy service; otherwise, the legacy service will be invisible to them.
Legacy service-specific configuration # In addition to common settings, legacy service-specific configuration options should be explored in each legacy service&rsquo;s documentation. These typically encompass credentials and configurations influencing legacy service behavior.
Due to the environment-dependent nature of legacy services, employing environment variables for configuration, especially for sensitive information like credentials, is advisable. This facilitates the use of distinct accounts for development and production.
Secure legacy service-specific configuration # Storing sensitive data, such as passwords and keys, in environment variables is highly recommended. Configuration properties can then reference these environment variables. For further details, consult the documentation on Environment Variables.
Legacy service properties # For all configured legacy services, several properties prove useful to developers in certain scenarios. These properties are accessible through the app.endpoints.&lt;endpointName&gt; namespace, where endpointName represents the legacy service&rsquo;s name. While some are endpoint-specific, a couple of generic properties exist:
_name # This is the internal name of the legacy service, used within the JavaScript API.
_configuration # This property contains a JSON representation of the legacy-service-specific configuration.
_token # This token is employed to validate messages exchanged between the legacy service and the platform.
For example, if a legacy service is named fullcontact, the properties can be accessed like this:
sys.logs.info(JSON.stringify(app.endpoints.fullcontact)); Or having a legacy service called ftp you can print the _token:
sys.logs.info(app.endpoints.ftp._token); Legacy services usage # When a legacy service is added, it introduces two new features to the app:
Functions: These functions can be invoked from any script and are typically used to send and retrieve data from an external app. Events: These events are triggered by the external app and can be handled through listeners. By creating listeners for legacy services, you can intercept and process these events. Functions # Legacy service functions are accessible from any script using the namespace app.endpoints.&lt;endpointName&gt;, where endpointName refers to the legacy service&rsquo;s name. For instance, if there&rsquo;s a legacy service named slack that offers a function called sendMessage(), you can call it from any script using app.endpoints.slack.sendMessage().
For instance, the following is an example of a call to send a message using the Slack legacy service:
const msg = action.field('message').val(); app.endpoints.slack.sendMessage({channel: '#test', message: msg}); If errors occur during the execution of a function, an exception will be raised. By default, this exception halts the execution of the script, and the error is logged. However, you have the option to handle it if desired:
const msg = action.field('message').val(); try { app.endpoints.slack.sendMessage({channel: '#test', message: msg}); } catch (e) { sys.logs.warn('There was a problem sending a message through Slack: '+sys.exceptions.getMessage(e)); } // execution will continue even if the message to Slack couldn't be sent You should refer to each legacy service&rsquo;s documentation to identify the functions that are available.
For example, to learn about the functions provided by the Slack legacy service, consult the Slack legacy service&rsquo;s documentation.
User legacy service functions # For user legacy services, most function calls are likely to be tied to a specific user. For instance, consider the case of using the Google Contacts user legacy service. When creating a new contact within this legacy service, it needs to be added to the Google account of the user currently utilizing the app.
This determination hinges on the current user within the execution context (you can check this using the script: sys.context.getCurrentUser(). In the aforementioned example, when invoking the function to create a contact in Google Contacts, the legacy service identifies the current user and performs the contact creation on behalf of that user. Naturally, this assumes that the current user has previously connected to the legacy service; otherwise, the function call will fail.
There are instances where the current user might be the system user. In such cases, if you attempt to call a legacy service method requiring association with a user, the call will fail. If you possess the information about the user intended for this function call, you can set it using the method sys.context.setCurrentUser() before calling the legacy service&rsquo;s function.
All user legacy service incorporate the following functions:
connectUser(config): Establishes a connection between the current user and the legacy service. Here, config pertains to the user&rsquo;s configuration for that specific legacy service. For instance:
const msg = {}; msg.configuration = {}; msg.configuration.code = 'user-code'; // code generated on the authentication page by the user try { const response = app.endpoints.googleContacts.connectUser(msg, { 'userConnected': function(event) { sys.logs.info('User connected to Google Contacts: '+sys.context.getCurrentUser().fullName()); sys.logs.info(' - Configuration: '+JSON.stringify(event.data.configuration)); }, 'userDisconnected': function(event) { sys.logs.info('Could not connect user to Google Contacts:'+sys.context.getCurrentUser().fullName()); } }); sys.logs.info('Response: '+JSON.stringify(response)); } catch(e) { sys.logs.error('Error when try to execute function ['+sys.exceptions.getMessage(e)+']'); } disconnectUser(): disconnects the current user from the endpoint. For example:
const msg = {}; try { const response = app.endpoints.googleContacts.disconnectUser(msg, { 'userDisconnected': function(event) { sys.logs.info('User disconnected from Google Contacts:'+sys.context.getCurrentUser().fullName()); } }); sys.logs.info(&quot;Response: &quot;+JSON.stringify(response)); } catch(e) { sys.logs.error('Error when try to execute function ['+sys.exceptions.getMessage(e)+']'); } isUserConnected(): returns true if current user is connected to the endpoint, false otherwise. For example:
if (app.endpoints.googleContacts.isUserConnected()){ sys.logs.info('User connected'); } else { sys.logs.info('User disconnected'); } Callbacks # Certain functions offer callbacks that enable easy handling of asynchronous responses. For instance, when utilizing the function to send an email with Mandrill, you can include a callback to perform an action when a reply to the email is received:
let msg = {}; msg.subject = &quot;A test subject.&quot;; msg.templateName = &quot;test-template&quot;; msg.important = true; msg.to = &quot;user1@test.com&quot;; msg.globalMergeVars = { companyName: record.field('name').val(), companyId: record.id() }; msg.waitResponse = true; try { let callbackData = {company: record, currentUserEmail: sys.context.getCurrentUserRecord().field('email').val()}; let response = app.endpoints.mandrill.sendEmail(msg, callbackData, { responseArrived: function(event, data) { // event data sys.logs.info('Response arrived:'); sys.logs.info('Date/Time: '+event.data.eventTime); sys.logs.info('From: '+event.data.fromName+' &lt;'+event.data.fromEmail+'&gt;'); sys.logs.info('Subject: '+event.data.subject); sys.logs.info('Text: '+event.data.text); // callback data sys.logs.info('Record ID: '+data.company.id()); sys.logs.info('User email: '+data.currentUserEmail); } }); sys.logs.info(&quot;Mandrill response: &quot;+JSON.stringify(response)); } catch(e) { sys.logs.error('Error when try to send an email: '+sys.exceptions.getMessage(e)); } When callbacks are supported, two parameters are available at the end:
callbackData: This object can be sent, and it will be returned when the callback is processed. This is crucial because, in the function processing the callback, access to variables outside the function is restricted. For instance, in the previously provided code, referencing the variable msg outside the callback function isn&rsquo;t feasible. This limitation arises due to the asynchronous nature of callbacks, causing a loss of context, which differs from standard JavaScript behavior. Hence, it&rsquo;s important to keep this in mind. callbacks: This map allows you to listen for various callbacks. The earlier example only listens to the responseArrived callback. However, the Mandrill legacy service can trigger additional callbacks based on diverse events. Functions within this callback possess two parameters: event: This encompasses the event information, identical to the event available in listeners. Refer to the documentation on Legacy service Listeners. data: This constitutes the callback data dispatched when the function was called. Please consult each legacy service&rsquo;s documentation to ascertain the available callbacks for each function.
Events # Events signify occurrences within the external app that require notification. These events can originate from the external app itself, or the legacy service might identify certain events and relay them to the app. For instance, this could involve a message sent to a Slack channel or the FTP legacy service detecting a new file in a monitored folder.
Events can be managed via Legacy service Listeners. Each legacy service provides its own distinct events; therefore, consulting the documentation for each legacy service is advised.
User legacy service events # A key aspect regarding user legacy services pertains to event processing. When events arrive, the current execution context is aligned with the user from whom the event originated. Consequently, during event handling within the listener, if you invoke 'sys.context.getCurrentUserRecord()' you will get the user associated to the event:
const currentUser = sys.context.getCurrentUserRecord(); sys.logs.info('*** EVENT FOR USER: '+currentUser.field('email').val()); Keep in mind that there might be global events in a user legacy service, so in those cases current user will be null. You should check that in the legacy service&rsquo;s documentation.
Finally, user legacy services have two additional events that are always available:
User connected: indicates that a user connected to the legacy service, which usually means that the user granted permissions. This event has some information about the configuration that you can get at event.data.configuration:
sys.logs.info('User connected to Google Calendar: '+sys.context.getCurrentUserRecord().field('email').val()); sys.logs.info(' - Configuration: '+JSON.stringify(event.data.configuration)); User disconnected: indicates that a user disconnected from the legacy service.
`}),e.add({id:64,href:"/dev-reference/field-types/",title:"Field types",description:"",content:""}),e.add({id:65,href:"/dev-reference/data-model-and-logic/services/",title:"Services",description:`Services are essential components that run alongside your application. They possess their own set of resources and are primarily designed to extend the capabilities of the platform.
The most common use case for services is to facilitate connections between your application and external apps by enabling the sending, receiving, and fetching of data through external APIs. For instance, you can create a service to manage HTTP requests or to generate PDF files.`,content:`Services are essential components that run alongside your application. They possess their own set of resources and are primarily designed to extend the capabilities of the platform.
The most common use case for services is to facilitate connections between your application and external apps by enabling the sending, receiving, and fetching of data through external APIs. For instance, you can create a service to manage HTTP requests or to generate PDF files.
Services configuration # All services share some common settings, although each service may have additional settings that are specific to its functionality. It&rsquo;s important to refer to the service&rsquo;s documentation for a detailed explanation of these settings.
Here, we will describe some of the common settings:
Label # This is the human-readable name of the service, primarily for organizational purposes and does not impact the app&rsquo;s execution.
Name # This is the internal name of the service, used in the JavaScript API. It should not contain special characters or spaces, only letters and numbers. Be cautious when changing the service name, as it may require updates in scripts that reference it.
Instance type # The HTTP service, for instance, offers two instance types: dedicated and shared. Shared instances do not require deployment configuration and use a platform component, while dedicated instances have specific components deployed for exclusive app usage, incurring additional costs.
Initial status # This represents the initial status of the service when it is first pushed or synced. It only affects the service&rsquo;s first deployment. Afterward, the status should be managed through the app monitor. This feature is particularly useful for template apps that will be cloned; you can set the initial status to &lsquo;Undeployed&rsquo; to delay activation until it&rsquo;s configured and deployed.
Service properties # All configured services offer properties that can be valuable for developers. These properties are organized under the svc.&lt;serviceName&gt; namespace, where serviceName corresponds to the name of the service. While some properties are service-specific, there are also a couple of generic properties:
Name # This is the internal name of the service, used in the JavaScript API.
Configuration # This JSON representation holds service-specific configurations.
Token # This token is used to validate messages exchanged between the service and the platform.
For example, if you have a service named 'fullcontact,' you can access its properties as follows:
sys.logs.info(JSON.stringify(svc.fullcontact)); Or having an service named ftp you can print the _token:
sys.logs.info(svc.ftp._token); Service usage # Functions # Service functions are callable from any script and are accessed via the svc.&lt;serviceName&gt; namespace, where serviceName corresponds to the name of the service. For instance, if a service named &lsquo;pdfGenerator&rsquo; provides a function called 'generatePdf()', you can invoke it from any script using the following syntax: svc.pdfGenerator.generatePdf().
For example, here&rsquo;s a GET request using the HTTP service:
const resquest = 'https://www.slingr.io/'; var response = svc.http.get({url:request}); log(JSON.stringify(&quot;Response: &quot; + response)); During the execution of a function, if errors occur, an exception will be thrown. By default, this exception halts the execution of the script, and the error is logged. However, you have the option to handle errors if desired.
Please refer to each service&rsquo;s documentation to identify the available functions and their respective error handling mechanisms.
Callbacks # Some functions provide callbacks that facilitate the receipt of asynchronous responses. For example, when generating a PDF file using a PDF generator, you can incorporate a callback to perform actions once the image is returned:
try { let userName = sys.context.getCurrentUserRecord().label(); let callbackData = {company: record, currentUserEmail: sys.context.getCurrentUserRecord().field('email').val()}; let response = svc.pdf.generatePdf({}, callbackData, { responseArrived: function(event, data) { // event data sys.logs.info('Response arrived:'); sys.logs.info('event: '+JSON.stringify(event)); // callback data sys.logs.info('Record ID: '+data.company.id()); sys.logs.info('User email: '+data.currentUserEmail); } }); sys.logs.info(&quot;Pdf response: &quot;+JSON.stringify(response)); } catch(e) { sys.logs.error('Error when try to generate a pdf file: '+sys.exceptions.getMessage(e)); } When callbacks are supported, two parameters are available at the end:
callbackData: This is an object that you can send and will be returned when the callback is processed. This is important because, in the function processing the callback, you won&rsquo;t have access to any variables outside the function scope. For instance, in the code above, you won&rsquo;t be able to reference the userName variable because it exists outside the callback function. This limitation arises because callback execution is asynchronous, resulting in a different context compared to regular JavaScript code. Keep this in mind when working with callbacks.
callbacks: This is a map where you can register listeners for various callbacks. In the example above, it&rsquo;s listening only for the responseArrived callback, but certain services, like Mandrill, can trigger multiple callbacks based on different events. Functions within this callback have two parameters:
event: This parameter contains event information, identical to the event data available in listeners. Please refer to the service&rsquo;s documentation for details on service-specific events. data: This parameter holds the callback data that was sent when the function was initially called. Please consult each service&rsquo;s documentation to determine the available callbacks for each function.
Events # Events signify occurrences within the service or an external app that require notification. These events can be triggered by the external app itself or detected by the service, prompting it to send an event to the app. For instance, an event might be generated when a message is sent to a Slack channel or when the FTP service detects a new file in the watched folder.
Events can be managed through service listeners. Each service offers its own set of events, so it&rsquo;s essential to consult the service&rsquo;s documentation for specific event details.
`}),e.add({id:66,href:"/dev-reference/data-model-and-logic/packages/",title:"Packages",description:`Packages are a convenient way to import a set of metadata into your application. Their primary purpose is to streamline the implementation of predefined functionalities, saving developers a significant amount of time.
The most common use cases for packages include importing utility libraries to perform common operations and connecting your application with external services by sending, receiving, and fetching data via their APIs. Packages contain all the logic necessary for utilizing an HTTP service and consuming these external APIs.`,content:`Packages are a convenient way to import a set of metadata into your application. Their primary purpose is to streamline the implementation of predefined functionalities, saving developers a significant amount of time.
The most common use cases for packages include importing utility libraries to perform common operations and connecting your application with external services by sending, receiving, and fetching data via their APIs. Packages contain all the logic necessary for utilizing an HTTP service and consuming these external APIs. For instance, there are packages available for Slack, Google Contacts, Google Calendar, and other popular cloud services, allowing your application to seamlessly leverage the features offered by these apps.
Package installation and management # Available packages for your application can be found in a section called the &quot;Marketplace.&quot; From there, you can read the package README.md to learn more and install the package. Once a package is installed, you can monitor it for updates to ensure you&rsquo;re using the latest version.
Package configuration # While all packages share some common settings, each package may also have additional settings specific to its functionality. It&rsquo;s essential to refer to the package&rsquo;s documentation to understand the meaning of these settings.
Here, we will describe common settings:
Label # This is the human-readable name of the package and does not impact the execution of your application.
Name # This is the internal name of the package, used in the JavaScript API. It should not contain special characters or spaces, only letters and numbers. Be cautious when changing the package name, as it may require updates in scripts that reference the package.
Version # This indicates the current version of the package.
Upgrade policies # This setting defines how the package behaves when new versions are available. Versions follow the format X.Y.Z. The available options are:
Compatible version: Shows updates when the Y or Z values are updated. Bug fixes: Shows updates when the Z value is updated. Manual: Updates won&rsquo;t be shown for new versions. Latest: Shows updates for any version change. Package-specific configuration # In addition to common settings, each package may have its own configuration settings. These settings often include credentials and configurations that determine the package&rsquo;s behavior. Packages might be environment-dependent, so consider using environment variables for configurations such as credentials to allow for different accounts in production and development environments.
Package dependencies configuration # Packages that depend on services require selecting a service instance for the package to use. This selected service will also be the target of imported listeners.
Secure packages-specific configuration # For security, it&rsquo;s highly recommended to use environment variables to store sensitive information like passwords and keys. You can then configure a specific property to reference an environment variable. Please refer to the &ldquo;Environment Variables&rdquo; section for more information.
Data storage # Some packages may need to generate and store information during runtime securely. For instance, a GitHub package might need to store credentials securely after user authentication. In such cases, the package will encrypt and store this information in the app&rsquo;s storage.
Using packages # When a package is added, it introduces new features to your application:
Script Libraries: Functions within these libraries can be called from any script and belong to the script libraries imported by the package.
Events: These events are triggered by the package and can be processed through Package Listeners. When creating a listener for packages, you will see the package and its associated events, allowing you to handle them effectively.
Listeners: Listeners are useful for processing events, such as validating and formatting content received via webhooks through an HTTP service, and then triggering package-related events.
UI Services: These services provide client-side functionality, such as enabling OAuth 2.0 connections to external services from the application runtime.
Flow Steps: Flow steps introduced by packages can be used in any application flow.
All of these elements can be explored in the metadata tree of the builder within the &ldquo;Packages&rdquo; section.
Script libraries # Package libraries can be invoked from any script and are located under the namespace pkg.&lt;packageName&gt;, where packageName corresponds to the name of the package. For instance, if a package named &lsquo;slack&rsquo; provides a library called &lsquo;messages,&rsquo; you can call a function like &lsquo;sendMessage()&rsquo; from any script using the following syntax: pkg.slack.messages.sendMessage().
For example, here&rsquo;s a call to send a message using the Slack legacy service:
const msg = action.field('message').val(); pkg.slack.messages.sendMessage({channel: '#test', message: msg}); In case of errors during the execution of a function, an exception will be thrown. By default, this exception will halt the script&rsquo;s execution, and the error will be logged. However, you have the option to handle errors if necessary:
const msg = action.field('message').val(); try { pkg.slack.messages.sendMessage({channel: '#test', message: msg}); } catch (e) { sys.logs.warn('There was a problem sending a message through Slack: '+sys.exceptions.getMessage(e)); } // execution will continue even if the message to Slack couldn't be sent To discover the available libraries and functions within each package, it&rsquo;s essential to refer to the respective package&rsquo;s documentation. Each package may offer a unique set of libraries and functions tailored to its specific functionality.
For detailed information on what is available and how to use them, consult the documentation provided with each package.
`}),e.add({id:67,href:"/getting-started/getting/first-steps/event-planner/firstlook/",title:"First look at our new app",description:`In this section, we&rsquo;ll review the changes made to our app in the previous section.
👉 First, open the developer portal and click on the runtime button (the square icon ) to open the runtime in a new tab.
👉 Navigate to the All Events section and select an event to open a read-only view.
👉 Click on the Edit button and change the status of the event to Cancel.`,content:`In this section, we&rsquo;ll review the changes made to our app in the previous section.
👉 First, open the developer portal and click on the runtime button (the square icon ) to open the runtime in a new tab.
👉 Navigate to the All Events section and select an event to open a read-only view.
👉 Click on the Edit button and change the status of the event to Cancel.
Great job!
With this simple step, we&rsquo;ve successfully added a new field to our events.
In the next section, we&rsquo;ll create some actions to change the status of an event without editing the record.
`}),e.add({id:68,href:"/dev-reference/data-model-and-logic/ui-services/",title:"UI services",description:`UI Services are client-side components designed to enhance the user interface (UI) features of the platform.
The primary use case for UI Services is to facilitate interactions with external applications on the client side. For example, a UI Service could be created to interact with Twilio, allowing it to display an incoming call and enabling users to answer it directly within the platform&rsquo;s UI.
Action definition # When an action is defined for an entity, it becomes accessible through the UI, REST API, and JavaScript API.`,content:`UI Services are client-side components designed to enhance the user interface (UI) features of the platform.
The primary use case for UI Services is to facilitate interactions with external applications on the client side. For example, a UI Service could be created to interact with Twilio, allowing it to display an incoming call and enabling users to answer it directly within the platform&rsquo;s UI.
Action definition # When an action is defined for an entity, it becomes accessible through the UI, REST API, and JavaScript API.
Action settings # Label # This is the human-readable name of the UI Service, and it&rsquo;s displayed in the user interface (UI).
Name # This internal name is used when sending messages to the UI Service from the backend using the JavaScript API. The name should not contain special characters or spaces, only letters and numbers.
By groups # This option filters access to the UI Service by app groups.
Places # Indicates where the UI Service should be loaded on the client side. Possible values include:
APP LOGIN Dependencies # This feature allows you to load dependencies from external sources or files within the UI Service files. These dependencies can be placed at the top or bottom of the HTML and can be either JavaScript or CSS sources.
Functions # Here, you should specify the exported functions. Each function should have a label, name, and whether they have callbacks or not.
Events # List the events that can be triggered by the UI Service.
Main file # This file contains the code that will be injected into the client-side UI. The exposed methods should be added to a service object and listed in the UI Service configuration.
UI service helpers # These are utility functions designed to facilitate communication with the backend of your app from scripts within the UI Service.
For detailed information on configuring and using UI Services, refer to the UI Service&rsquo;s specific documentation.
sendEvent(eventName, eventData) # Triggers a ui service event in the app.
Parameters # Name Type Required Description eventName string yes A simple string representing the event name. eventData object no An optional object to be included in the event data. Samples # // Trigger a ui service event service.sendEvent('test', {msg:&quot;this is a test event&quot;}); callback(message, eventName, eventData) # Triggers the callback of function of the ui service in the backend.
Parameters # Name Type Required Default Description message object yes Used to send the function context back to the app. eventName string yes A simple string representing the callback event name. eventData object no An optional object to be included in the event data. Samples # // Trigger a ui service event in the backend service.callback(originalMessage, 'fail', {msg: ' callback data'}); uiCallbacks(message, eventName, eventData) # Triggers the callback of function of the ui service in the client side.
Parameters # Name Type Required Default Description message object yes Used to send the function context back to the app. eventName string yes A simple string representing the callback event name. eventData object no Data that the callback needs Samples # // Trigger a ui service event callback client side service.uiCallback(originalMessage, 'fail', {msg: ' callback data'}); Sending message to ui service # It is possible to send messages to UI Services from a backend script using the JavaScript API. For example, to call the UI Service named 'sample' for the 'event1' event, you would use the following syntax:
sys.ui.sendMessage({ scope: 'uiService:sample', name: 'event1', companyId: record.id(), callbacks: { callback1: function(originalMessage, callbackData) { sys.logs.debug(&quot;Here is the original message for callback 1&quot;); sys.logs.debug(JSON.stringify(originalMessage)); sys.logs.debug(&quot;Here is the callback data for callback 1&quot;); sys.logs.debug(JSON.stringify(callbackData)); }, callback2: function(originalMessage, callbackData) { //do something } } }); Events # UI Services have the capability to send events to the backend. These events can be captured and processed by listeners configured with the type 'UI Service' and selecting the corresponding event.
Parameters # Name Type Description record sys.data.Record Represents the record where the action will be executed. This variable is available when the action type is One record or when applying the action to many records. query sys.data.Query A query object with filters to find all records affected by this action. This variable is used for actions of type Many records. action sys.data.Action Action object that provides access to the parameters of the action. job sys.jobs.Job The job object, which is available when the action is executed in the background. It&rsquo;s important to note that the after-action executed script runs immediately after triggering the action from the UI, and the job may still be in a pending or running state. Samples # // after action is executed redirect to read only view of given record var record = sys.data.findOne(query); sys.ui.sendMessage({ scope: 'global', name: 'navigate', view: '590ce2e38a2....', recordId: record.id() }); `}),e.add({id:69,href:"/dev-reference/field-types/overview/",title:"Field types",description:"Special # Nested fields Relationship Text # Text Long text Masked text URL HTML Email Phone Number # Integer Auto-increment Decimal Money Percentage Big Number Multiple choice # Boolean Choice Dynamic Choice Date and time # Date Year-Month Month-Day Date-Time Date record created Date record modified Date-Time no timezone Time Time duration References # Group File Miscellaneous # Color Rank ",content:"Special # Nested fields Relationship Text # Text Long text Masked text URL HTML Email Phone Number # Integer Auto-increment Decimal Money Percentage Big Number Multiple choice # Boolean Choice Dynamic Choice Date and time # Date Year-Month Month-Day Date-Time Date record created Date record modified Date-Time no timezone Time Time duration References # Group File Miscellaneous # Color Rank "}),e.add({id:70,href:"/dev-reference/security/",title:"Security",description:"",content:""}),e.add({id:71,href:"/dev-reference/security/overview/",title:"Security",description:`Slingr offers comprehensive features for user authentication and authorization.
Authentication # Slingr provides the capability to establish authentication rules, including password policies, maximum login attempts, IP restrictions, and the utilization of different identity providers to facilitate Single Sign-On (SSO) via protocols such as SAML or Slack.
Authorization # On the authorization front, Slingr empowers you to define granular permissions for entities, fields, actions, and views. This flexible approach allows for precise control over user privileges and operations.`,content:`Slingr offers comprehensive features for user authentication and authorization.
Authentication # Slingr provides the capability to establish authentication rules, including password policies, maximum login attempts, IP restrictions, and the utilization of different identity providers to facilitate Single Sign-On (SSO) via protocols such as SAML or Slack.
Authorization # On the authorization front, Slingr empowers you to define granular permissions for entities, fields, actions, and views. This flexible approach allows for precise control over user privileges and operations.
The majority of security configurations are organized into groups. Subsequently, users can be assigned to one or multiple groups (with one designated as the primary group). These group assignments determine a user&rsquo;s permissions. For instance, if group G1 possesses permissions for entity E1 and group G2 has access to entity E2, a user belonging to both G1 and G2 can access both entities E1 and E2.
Password rules and policies are associated with the primary group.
All permissions are enforced not only at the UI level but also within the REST API, ensuring data remains shielded from unauthorized access. However, it&rsquo;s important to note that permissions are not validated within scripts. Developers bear the responsibility of ensuring that scripts operate within the bounds of allowed actions.
For detailed information regarding groups, identity providers, and users, please consult the following documentation:
Groups Users Single Sign-On `}),e.add({id:72,href:"/dev-reference/security/groups/",title:"Groups",description:`Groups enable the definition of permissions and security regulations for users. Permissions can be tailored for entities and views, while security rules can be configured to manage user aspects like passwords, IP whitelisting, and user management.
A user can be a member of multiple groups simultaneously, but only one group serves as the primary designation. The primary group significantly influences which security rules apply to the user.
When you create a new group, it doesn&rsquo;t automatically come with any pre-set permissions.`,content:`Groups enable the definition of permissions and security regulations for users. Permissions can be tailored for entities and views, while security rules can be configured to manage user aspects like passwords, IP whitelisting, and user management.
A user can be a member of multiple groups simultaneously, but only one group serves as the primary designation. The primary group significantly influences which security rules apply to the user.
When you create a new group, it doesn&rsquo;t automatically come with any pre-set permissions.
Groups are also employed in OAuth Scopes. Before removing a group, ensure it is not currently used in an OAuth Scope. For more information, consult the OAuth Support documentation.
Next, we will delve into the configuration settings for a group.
Label # This represents the human-readable name of the group. You can utilize spaces, special characters, and a mix of upper and lower case letters.
The label is used for referencing the group within the user interface. Generally, changing the label of a group doesn&rsquo;t necessitate code modifications. However, if you&rsquo;ve employed it in scripts or via the REST API, manual updates might be required.
Name # This denotes the internal name of the group. It must exclude special characters or spaces.
Typically, the group name is utilized in scripts and the REST API. Changing it could potentially impact your app, demanding certain manual adjustments.
Entity permissions # Each entity is associated with a set of permissions, dictating permissible actions, as well as the accessibility of fields and actions.
When a new entity is introduced, it doesn&rsquo;t come with any default permissions assigned to any group.
Let&rsquo;s now explore the permissions applicable to entities.
Can create # Indicates if users can generate new records for the entity.
Creation options include:
Always: Users can create records within the entity regardless of field values (as long as they adhere to validation rules). Condition: Users can solely create records that meet a specified condition. For example, a user might only create tickets assigned to themselves. Refer to Expressions for defining conditions. Never: Users are prohibited from creating records within this entity. Can access # Indicates whether users can retrieve records from the entity. Access permissions take precedence over other permissions. For instance, if you possess editing permissions for a record but lack access permissions, editing becomes unfeasible. The same principle applies to deletion, history tracking, and exporting.
Access options encompass:
Always: Users have access to all records within the entity. Condition: Users can solely access records meeting a given condition. For instance, a user might access only tickets assigned to them. Refer to Expressions for condition definition. Never: Users lack access to records within this entity. Can edit # Indicates whether users can modify records within the entity. Users must also have access permissions for a record to be editable.
Editing options encompass:
Always: Users can edit any record within the entity. Condition: Users can solely edit records that meet a specified condition. For instance, a user might edit solely those tickets assigned to them. Refer to Expressions for condition definition. Never: Users lack permission to edit records within this entity. History access # Indicates whether users can view historical logs of records within the entity. Access permissions for the record must also be present to view its history.
History access options include:
Always: Users can view historical logs of all records within the entity. Condition: Users can solely view history logs of records meeting a specified condition. For instance, a user might view history logs of tickets assigned to them. Refer to Expressions for condition definition. Never: Users lack access to history logs of records within this entity. Can import # Indicates whether users can import records via a CSV file. User must also have creation permissions; otherwise, record creation would fail.
Can export # Indicates whether users can export records to a CSV file. Export is only possible for records the user possesses access to.
Field permissions # Field permissions can be specified for each field. Options encompass:
Parent: Field permissions replicate those of the parent field. This solely applies to fields nested within other fields and is the default setting. Read/Write: Users within this group can both read from and write to this field. Read Only: Users within this group can solely read this field. Any attempts to alter the value during updates are silently discarded. None: Users within this group have neither read nor write permissions for this field. The field is entirely concealed from the UI and REST API. Advanced: This allows for separate read or write access configurations, optionally dependent on record data via expressions, filters, or scripts. This mirrors the functionality of Read/Write Access for fields. Upon introducing a new field to an entity, if a group has update access to the entity (Can Create or Can Edit is set to Always or Condition), the field is automatically assigned read-write permission for that group. If there&rsquo;s solely read access to the entity (Can Access is set to Always or Condition), read-only permission is assigned to the field for that group. No permissions are automatically set otherwise.
Action permissions # Action permissions are configured similarly to advanced field configurations. This implies that configuration can be influenced by record configuration. Action permissions comprise the following options:
Always: The action is always executable. Script: The action becomes executable if the script returns true; otherwise, it remains inexecutable. The script operates within the context of: Parameters Name Type Description record sys.data.Record This is the record associated to the operation. If field is inside an entity field, this will be the record that contains the field.
If the field is an action parameter, this will be the record where the action is being executed.
parentField sys.data.Record This variable is only available when this is a field inside a nested field and it is based on the variable record or action (the same rules apply then it is an action parameter or an entity field).
It is a sys.data.Record object with the difference that the root of the record is set to the nested fields containing it. This way it is possible to access fields in the nested group like parentField.field('fieldA') instead of record.field('nested.fieldA') or action.field('nested.fieldA'), which is specially needed when nested fields are multi-valued as you don&rsquo;t know the index.
action sys.data.Action This variable will be available only if the field is an action parameter. It will provide access to other parameters. Returns boolean - You should return true if there is access to the field, false otherwise. Samples// if &rsquo;numberOfExmployees&rsquo; is bigger than 10, then this field is visible return record.field('numberOfEmployees').val() > 10; Expression: The action is executable if the expression evaluates to true. Further details about expressions are available in the Expressions documentation. Never: The action cannot be executed. This option is meaningful only when the relevant flag is unchecked. Upon adding a new action to an entity, if the group holds permissions for all actions within that entity, the newly added action is granted permission as well.
It&rsquo;s also feasible to establish permissions for action parameters, following the same criteria as Field Permissions. When introducing a new parameter to an action, if a group possesses permissions for the action, read-write permission is automatically extended to the parameter within that group.
View permissions # Specify which views users can see and employ. For proper functioning, the user should also possess access permissions for the relevant entity. Consequently, adding a view automatically results in permissions for the associated entity if none were initially defined.
When you create a new view, if a group holds permissions for the entity linked to that view (applicable to grid, record, and card views), the view is automatically granted permission for that group&rsquo;s usage.
Security settings # Secure access # Allowed IPs # Define a whitelist of IPs from which users can log in. If a user attempts to log in or access the app from an IP outside this whitelist, an error will be generated.
If a user belongs to multiple groups, each defining valid IPs, any of these IPs will be deemed valid.
Password rules # These rules stipulate the prerequisites for a valid password. Only rules established in the user&rsquo;s primary group are enforced.
Require upper case # If enabled, passwords must include an uppercase character.
Require lower case # If enabled, passwords must include a lowercase character.
Require number # If enabled, passwords must contain a numerical digit.
Require symbol # If enabled, passwords must incorporate a special character.
Require minimum length # If enabled, the minimum length for a valid password can be specified.
Password policies # Only policies set in the user&rsquo;s primary group are taken into account.
Password expiration # Specifies the frequency at which users are required to change their passwords. Setting this value to Never means users are never prompted to reset their passwords (which is the default setting).
Maximum login attempts # Sets the maximum number of consecutive failed login attempts allowed per user. If this limit is exceeded, the user&rsquo;s access will be blocked.
Impersonate users # Determines whether users can impersonate other users. Enabling this feature allows them to execute operations on other users, such as editing, password resets, unblocking, and more. This applies to both the REST API and the UI. The UI gains a new menu item in the secondary menu titled Impersonate Users.
`}),e.add({id:73,href:"/getting-started/getting/first-steps/event-planner/creatingactions/",title:"Creating actions",description:`In this section, we will learn how to add actions to our events. The purpose is to enable changing the event status without entering the edit view.
Create a &lsquo;cancel event&rsquo; action # Let&rsquo;s get started by creating an action to cancel events using a feature called Flows. This action will only be visible when the current status of the event is set to Active. Follow these steps:
👉 Right-click on the node Model &gt; Entities &gt; Events &gt; Actions and select New Action from the dropdown menu.`,content:`In this section, we will learn how to add actions to our events. The purpose is to enable changing the event status without entering the edit view.
Create a &lsquo;cancel event&rsquo; action # Let&rsquo;s get started by creating an action to cancel events using a feature called Flows. This action will only be visible when the current status of the event is set to Active. Follow these steps:
👉 Right-click on the node Model &gt; Entities &gt; Events &gt; Actions and select New Action from the dropdown menu.
👉 Fill in the form with the following details:
Label: Cancel Event Name: cancelEvent Type: One Record Visible: Always Preconditions: Expression Expression: Value &gt; Status &gt; Equals &gt; Active Actions type: Flow Configure action flow # 👉 Click on Open Editor.
This is what we call the Flow Designer, and the boxes on the left are referred to as &ldquo;steps.&rdquo; Each step has different functionality, and you can connect them to build a flow. You can learn more about flows here. We are going to use it to change the status of the record.
👉 Follow these flow steps:
Create an &ldquo;Update Record&rdquo; step and connect it to the &ldquo;Start&rdquo; step. On the right, fill the form to the following details: Record: record Data: Status &gt; Set &gt; Cancel Store Changes: true Create an &ldquo;End&rdquo; step and connect it to the &ldquo;Update Record&rdquo; step. Click on Create. This is ready!
👉 When this action is executed that, the user will be able to set the status of an event to &ldquo;Cancel&rdquo; without having to edit the event record.
Create a &lsquo;done&rsquo; action # Now, the only thing left is to create another event to transition an event from &ldquo;Active&rdquo; to &ldquo;Done.&rdquo;
We can follow the same process we just learned, but this time, we will utilize the JavaScript API offered by Slingr. You can learn more about it here.
Let&rsquo;s do it:
👉 Right-click on the node Model &gt; Entities &gt; Events &gt; Actions and select New Action from the dropdown menu.
👉 Fill in the form with the following details:
Label: End Event Name: endEvent Type: One Record Visible: Always Preconditions: Expression Expression: Value &gt; Status &gt; Equals &gt; Active Actions type: Script Script: record.field(&quot;status&quot;).val(&quot;done&quot;); sys.data.save(record); 👉 Click on Create.
👉 Push to see the changes.
That&rsquo;s it! We have implemented our two actions. After pushing the changes, go to the runtime and proceed to the next section, Actions in Action, to see the results.
`}),e.add({id:74,href:"/dev-reference/security/users/",title:"Users",description:`To access the app, whether through the UI or the REST API, you must possess a valid user account created within the app. Alternatively, you can create an account through an Identity Provider.
User records are maintained within the system entity System &gt; Users. This entity is generated and managed by the platform. While the metadata associated with this entity cannot be altered, it can be extended through custom configurations such as entity fields and actions.`,content:`To access the app, whether through the UI or the REST API, you must possess a valid user account created within the app. Alternatively, you can create an account through an Identity Provider.
User records are maintained within the system entity System &gt; Users. This entity is generated and managed by the platform. While the metadata associated with this entity cannot be altered, it can be extended through custom configurations such as entity fields and actions.
User management can be performed from various locations. In the app builder, user management is available under Security &gt; Users. Within the app monitor, this function resides in the Users section. Additionally, during app runtime, users with sufficient permissions can manage users using the Manage Users menu item in the secondary menu.
User permissions and authentication settings are determined by the groups to which they belong. For further insights, please refer to the documentation on Groups.
User settings # The following system user fields are created by default. Furthermore, custom fields can be created within this entity.
First name # Refers to the user&rsquo;s first name.
Last name # Represents the user&rsquo;s last name.
Email # Denotes the user&rsquo;s email address. This email must be unique within the app, and notifications will be dispatched to this address. Therefore, it&rsquo;s imperative to ensure the email provided is valid.
It&rsquo;s worth noting that certain identity providers might utilize the email address for user identification.
Send welcome email # This flag is exclusively available during the creation of a new user. When activated, a notification containing login instructions is dispatched to the user.
Authentication # This section pertains to settings associated with user session authentication.
Password # This refers to the password utilized by the user to log in using the default Slingr identity provider.
When creating a new user, the Generate Password flag can be selected to automatically generate a password.
Two-Factor authentication # Two-Factor Authentication adds an extra layer of security, necessitating not just a password and username, but also a unique piece of information known solely to the user. This could be a physical token, for instance.
Users can activate this feature within their own profiles by scanning the QR code generated using Google Authenticator on their mobile devices. Additionally, a phone number is required to enable SMS-based recovery of the authentication code, in case the user changes their mobile device.
Groups # This section displays the groups to which the user belongs. Each user must have one and only one primary group.
Identity providers # This section showcases the identity providers configured for the user. You can add or remove identity providers, and also modify the external ID associated with each provider.
It&rsquo;s important to be aware that some identity providers might be configured for automatic addition to a user. For more details, consult Single Sign-On.
Operations # Reset password # In the event of a user forgetting their password, this operation can be employed to reset it. A temporary password will be generated and sent to the user, who will be prompted to change it during their first login.
Deactivate # This operation renders a user account inactive. An inactive user cannot log in or access the app, but their account information remains intact.
Activate # Reactivates an inactive user account, granting them access to the app once again.
`}),e.add({id:75,href:"/dev-reference/security/single-sign-on/",title:"Single sign on",description:`Identity providers enable users to access your app without requiring them to create new accounts. Instead, users can utilize their existing accounts from supported identity providers to sign in.
For instance, enabling Slack as an identity provider permits users with Slack accounts to access your app. However, specific settings can be configured to limit access.
Listed below are the currently supported identity providers.
Shared options for all identity providers # These options are accessible to all identity providers.`,content:`Identity providers enable users to access your app without requiring them to create new accounts. Instead, users can utilize their existing accounts from supported identity providers to sign in.
For instance, enabling Slack as an identity provider permits users with Slack accounts to access your app. However, specific settings can be configured to limit access.
Listed below are the currently supported identity providers.
Shared options for all identity providers # These options are accessible to all identity providers.
Label # This label will be displayed on the login page button. A label like Login with Slack! provides clarity that users can sign in using Slack credentials.
Name # This internal identity provider name must not contain special characters or spaces. If used in scripts or the REST API, a manual update may be required if the name is altered.
Icon # This icon is showcased on the login button within the login screen. A square icon with a recommended minimum size of 64x64 pixels is advised.
Allow user creation # When enabled, users without accounts attempting to sign in through the identity provider will trigger new user creation within the app. When disabled, users must already have accounts in the app.
Allow user data update # If this option is active, user information will be updated with data from the identity provider upon sign-in. When inactive, user creation will occur, but no modifications will be made to user information in the app.
Allow provider addition # Enabling this option automatically adds an identity provider when a user attempts to sign in with it. If disabled, manual allowance is necessary.
Google # The Google identity provider enables users with Google accounts to log in to your application.
Service account of google # To generate a service account in Google, follow these steps:
Go to the Google Cloud console and log in as a super administrator. Create a project in the Google Cloud console. Activate the APIs for the service account. Create a service account in the Google Cloud console. Assign roles to the service account to provide access to GCP resources. Client ID # When you create a service account, a unique and permanent ID is automatically generated. A service account name is provided in the email address format: SA_NAME@PROJECT_ID.iam.gserviceaccount.com. This value serves as the Client ID that you need to configure in the Slingr app.
OAuth redirect URI # The OAuth redirect URI is the URI you need to configure in your Google Cloud console, in the same Google service account you created earlier. The standard format is: https://&lt;appName&gt;.slingrs.io/&lt;environment&gt;/runtime/api/sso/google/&lt;providerName&gt;/consumer.
Default user group # If it is allowed to create users when signing in through this identity provider, any new user created will be automatically assigned to this group.
After configuring app settings in Slingr and applying the changes, a &ldquo;Sign In&rdquo; button will automatically appear on the login page of the app.
When a user clicks the button, a popup will open, allowing the user to select their Google account to use for signing in.
Slack # The Slack identity provider permits Slack users to log in to your app.
Allow login with any team # This setting defines which Slack users can sign in. Enabling it allows any user to log in. Disabling it requires specifying a list of allowed teams using their IDs (not domains). The team ID can be obtained via the Web API by setting the request token in Extra args as token=XYZ123. For further information, refer to Legacy tokens in the official documentation.
Use default slack application # If you opt not to create a Slack application, the default one provided by Slingr can be used. However, creating a custom Slack application enables branding and personalized app names for users signing in with Slack.
To use a custom Slack application, provide the following settings:
Client ID: ID of the custom Slack application. Client Secret: Secret of the custom Slack application. Redirect URI: URI configured in your custom Slack application. For details on creating a Slack application, consult the documentation at Getting started with Slack apps and Sign in with Slack. The sign-in button is pre-implemented in Slingr!
Default group # When new users are created via this identity provider, they will be assigned to this group by default.
Veritone # The Veritone identity provider enables Veritone aiWARE platform users to sign in to a Slingr app.
Configure application in veritone aiWARE platform # To register the Slingr app on the Veritone side, configure the following settings:
Application Label: Label for the Slingr app. URL: URL of the Slingr app. Standard format: https://&lt;appName&gt;.slingrs.io. OAuth2 Redirect URL: URL in Slingr where the access code will be received. Format: https://&lt;appName&gt;.slingrs.io/&lt;environment&gt;/runtime/api/sso/&lt;providerName&gt;/consumer. Optional settings such as Application Description and Icon can also be specified.
Refer to the Veritone aiWARE docs for guidance on creating a Veritone aiWARE application.
Configure identity provider in Slingr app # After registering the app with Veritone, you&rsquo;ll receive an ID and OAuth2 Client Secret. Using these, create an identity provider record in the Slingr app with the following settings:
API URL: API URL for authentication. Production URL: https://api.veritone.com. Client ID: Client ID of the Veritone application for single sign-on. Client Secret: Client secret of the Veritone application for single sign-on. Default Group: New users created through this identity provider will be assigned to this group by default unless user role information is provided. Users management # Creating or updating users when signing in through this identity provider is permitted. Synchronized user attributes between Slingr and Veritone include id, first name, last name, email, and roles.
Once Slingr app settings are configured, a sign-in button will automatically appear on the app&rsquo;s login page.
SAML # SAML is an open-standard data format for exchanging authentication and authorization data between parties (see Security Assertion Markup Language).
SAML is commonly used in corporate environments, allowing users to access your Slingr app without needing to log in again, thanks to centralized user management.
Login URL # Provide the URL for user sign-in, provided by the SAML identity provider.
Change password URL # Provide the URL for changing user passwords, provided by the SAML identity provider.
Certificate # Supply the certificate used to validate the authenticity of tokens. Copy the certificate content as-is.
Synchronize only external groups # Enabling this option synchronizes only the groups added by the identity provider in the past. If a user belongs to groups A, B, and C, but only C was added by the identity provider, adding group D won&rsquo;t remove A and B.
Attribute mapping # Attribute mapping specifies how attributes from the identity provider map to user attributes. The default mapping assumes the presence of the following attributes:
userId: Immutable ID from the identity provider (used as the user&rsquo;s external ID). userEmail: User&rsquo;s email in the identity provider. userFirstName: User&rsquo;s first name in the identity provider. userLastName: User&rsquo;s last name in the identity provider. userGroups: Groups to which the user belongs in the identity provider, separated by commas. For custom mapping, a script context is provided. Parameters include idpAttributes for attributes from the SAML identity provider. The script should return an object containing attributes such as userId, userEmail, userFirstName, userLastName, and userGroups.
If you decide to provide a custom mapping, here is the context of the script:
Parameters # Name Type Description idpAttributes object This object contains all the attributes comming from the SAML identity provider. For example if the identity providers sends an attribute with name firstName, you should be able to access it using idpAttributes.firstName. Returns # object - The script should return an object with the following attributes:
userId: immutable ID from identity provider. This will be set as the external ID of the user for this identity provider. userEmail: email of the user in the identity provider. userFirstName: first name of the user in the identity provider. userLastName: last name of the user in the identity provider. userGroups: groups that user belongs to in the identity provider. It is a list of group names separated by comma. Samples # // this is a mapping script where some values are encoded in Base64 var Base64 = { _keyStr: &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;, check: function(s) { var endsWith = function(s, suffix) { return s.indexOf(suffix, this.length - suffix.length) !== -1; }; var base64Matcher = new RegExp(&quot;^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})([=]{1,2})?$&quot;); return endsWith(s, '=') &amp;&amp; base64Matcher.test(s); }, encode: function(input) { var output = &quot;&quot;; var chr1, chr2, chr3, enc1, enc2, enc3, enc4; var i = 0; input = Base64._utf8_encode(input); while (i &lt; input.length) { chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); enc1 = chr1 &gt;&gt; 2; enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4); enc3 = ((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6); enc4 = chr3 &amp; 63; if (isNaN(chr2)) { enc3 = enc4 = 64; } else if (isNaN(chr3)) { enc4 = 64; } output = output + this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4); } return output; }, decode: function(input) { var output = &quot;&quot;; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, &quot;&quot;); while (i &lt; input.length) { enc1 = this._keyStr.indexOf(input.charAt(i++)); enc2 = this._keyStr.indexOf(input.charAt(i++)); enc3 = this._keyStr.indexOf(input.charAt(i++)); enc4 = this._keyStr.indexOf(input.charAt(i++)); chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4); chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2); chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4; output = output + String.fromCharCode(chr1); if (enc3 != 64) { output = output + String.fromCharCode(chr2); } if (enc4 != 64) { output = output + String.fromCharCode(chr3); } } output = Base64._utf8_decode(output); return output; }, _utf8_encode: function(string) { string = string.replace(/\\r\\n/g, &quot;\\n&quot;); var utftext = &quot;&quot;; for (var n = 0; n &lt; string.length; n++) { var c = string.charCodeAt(n); if (c &lt; 128) { utftext += String.fromCharCode(c); } else if ((c &gt; 127) &amp;&amp; (c &lt; 2048)) { utftext += String.fromCharCode((c &gt;&gt; 6) | 192); utftext += String.fromCharCode((c &amp; 63) | 128); } else { utftext += String.fromCharCode((c &gt;&gt; 12) | 224); utftext += String.fromCharCode(((c &gt;&gt; 6) &amp; 63) | 128); utftext += String.fromCharCode((c &amp; 63) | 128); } } return utftext; }, _utf8_decode: function(utftext) { var string = &quot;&quot;; var i = 0; var c = c1 = c2 = 0; while (i &lt; utftext.length) { c = utftext.charCodeAt(i); if (c &lt; 128) { string += String.fromCharCode(c); i++; } else if ((c &gt; 191) &amp;&amp; (c &lt; 224)) { c2 = utftext.charCodeAt(i + 1); string += String.fromCharCode(((c &amp; 31) &lt;&lt; 6) | (c2 &amp; 63)); i += 2; } else { c2 = utftext.charCodeAt(i + 1); c3 = utftext.charCodeAt(i + 2); string += String.fromCharCode(((c &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63)); i += 3; } } return string; } }; var attributes = {}; attributes['userId'] = idpAttributes['userId']; if (Base64.check(idpAttributes['userFirstName'])) { attributes['userFirstName'] = Base64.decode(idpAttributes['userFirstName']); } else { attributes['userFirstName'] = idpAttributes['userFirstName']; } if (Base64.check(idpAttributes['userLastName'])) { attributes['userLastName'] = Base64.decode(idpAttributes['userLastName']); } else { attributes['userLastName'] = idpAttributes['userLastName']; } attributes['userEmail'] = idpAttributes['userEmail']; attributes['userGroups'] = 'Default'; return attributes; `}),e.add({id:76,href:"/dev-reference/security/external-tools/",title:"External tools",description:`LastPass # LastPass is a secure password manager designed to store encrypted passwords online. It offers a web interface and plugins for various web browsers, as well as mobile apps for smartphones.
👉 Sometimes, external factors can impact the performance of your application. Here are some tips to consider:
If you&rsquo;re using the LastPass extension on Chrome and notice performance issues, you can try the following steps:
Adjust Site Settings: Access the LastPass plugin in the upper right corner, then click the edit pen icon for your site.`,content:`LastPass # LastPass is a secure password manager designed to store encrypted passwords online. It offers a web interface and plugins for various web browsers, as well as mobile apps for smartphones.
👉 Sometimes, external factors can impact the performance of your application. Here are some tips to consider:
If you&rsquo;re using the LastPass extension on Chrome and notice performance issues, you can try the following steps:
Adjust Site Settings: Access the LastPass plugin in the upper right corner, then click the edit pen icon for your site. Go to the advanced settings tab and disable the autofill feature. Save the changes and refresh the page.
Modify Extension Options: Right-click the LastPass extension icon and select &ldquo;Options.&rdquo; Navigate to the notifications tab and uncheck &ldquo;Show autofill icon in fields&rdquo; and &ldquo;Show notifications via browser toolbar icon.&rdquo; Save the changes and restart your browser.
Temporarily Disable Extension: If the performance problems persist, consider disabling the LastPass extension. In Chrome, click &ldquo;More tools,&rdquo; then &ldquo;Extensions.&rdquo; Deactivate the LastPass extension.
By implementing these steps, you may be able to enhance the performance of your application when using the LastPass extension.
`}),e.add({id:77,href:"/dev-reference/user-interface/",title:"User interface",description:"",content:""}),e.add({id:78,href:"/dev-reference/user-interface/overview/",title:"Overview",description:`Slingr streamlines the UI creation process by offering a range of features designed to expedite development. The ultimate goal is to empower developers to craft compelling UIs without getting bogged down in intricate details and boilerplate code.
Unlike many low-code platforms where developers still need to manually assemble UI elements within a form, carefully manage layout, and establish connections between the UI and data/operations, Slingr takes a different approach. While this approach might represent progress beyond raw HTML, CSS, and JavaScript, it often demands considerable time and effort, particularly when the app model undergoes changes.`,content:`Slingr streamlines the UI creation process by offering a range of features designed to expedite development. The ultimate goal is to empower developers to craft compelling UIs without getting bogged down in intricate details and boilerplate code.
Unlike many low-code platforms where developers still need to manually assemble UI elements within a form, carefully manage layout, and establish connections between the UI and data/operations, Slingr takes a different approach. While this approach might represent progress beyond raw HTML, CSS, and JavaScript, it often demands considerable time and effort, particularly when the app model undergoes changes.
To simplify UI creation, Slingr introduces substantial building blocks called &ldquo;views&rdquo;. These views present diverse methods for presenting information, each tailored to distinct use cases. For instance, grid views are available for listing records, and workflow views are suitable for displaying records as cards within a dashboard. Each view offers a variety of parameters that can be adjusted to suit different scenarios.
These views are designed to extract as much information as possible from the app model, reducing the need for redundant tasks. For example, views can automatically decipher entity structures to construct forms or apply default display settings to fields.
The app&rsquo;s UI is structured as follows:
Header: This section resides at the top, displaying the app name and logo (customizable). In the builder, it can also incorporate a browser for entities, actions, listeners, and more. Main menu: The app&rsquo;s primary menu contains the different sections of your application. Selecting an item triggers the display of a corresponding view in the main content area. Secondary menu: This menu accommodates items linked to app views that are rendered in the main content area. User menu: In addition to containing system operations such as My profile or Logout, this menu permits the inclusion of items associated with app views rendered in the main content area. Main content: This region is where app views are showcased. Configuration options for the left and top menus are accessible through the Navigation section in the app builder. Conversely, adjustments to the header and certain other global settings can be made within the UI settings section.
Here are the available types of views:
Grid views Workflow views Record views Action views Custom views `}),e.add({id:79,href:"/dev-reference/user-interface/navigation/",title:"Navigation",description:`Navigation within your app refers to how users can access different views.
Slingr offers three primary navigation methods:
Main Menu: This menu is positioned on the left side of the app. Its visibility depends on the device&rsquo;s screen size; it may be hidden on smaller screens. You can add menu items at the root level or use menu groups to introduce one level of nesting. Secondary Menu: Found in the top-right area of the app, this menu allows you to add menu items (without menu groups) that will appear to the left of the User menu.`,content:`Navigation within your app refers to how users can access different views.
Slingr offers three primary navigation methods:
Main Menu: This menu is positioned on the left side of the app. Its visibility depends on the device&rsquo;s screen size; it may be hidden on smaller screens. You can add menu items at the root level or use menu groups to introduce one level of nesting. Secondary Menu: Found in the top-right area of the app, this menu allows you to add menu items (without menu groups) that will appear to the left of the User menu. User Menu: Located at the top-right corner, this menu serves as the platform for various system actions like My profile or Logout. You can include menu items (without menu groups) that will be positioned above the Logout action. Certain components provide supplementary navigation features (e.g., relationship fields enabling the jump to other records). These features are explained within each respective component&rsquo;s documentation.
Menu item # Menu items direct users to specific views within the app. When clicked, the associated view will be displayed in the main content area.
Menu items possess the following configurable settings:
View: This indicates the target view for the menu item. Label: The text to display in the menu. The default value is the same as the view&rsquo;s label. Icon: An optional icon for the menu item. Leave this field blank if no icon is desired. Expression: This permits the addition of filtering expressions to the chosen view. This feature is valuable when different collection views for the same entity only differ in the filtering expression. Refer to the Expressions documentation for guidance on filter configuration. For record views, you will be prompted to provide a script to select the record to be displayed in the view:
Returns # string - The ID of the record to be showcased in the record view.
Samples # // finds one record based on current user var settings; if (sys.context.getCurrentUser().isPrimaryGroup('Testing')) { settings = sys.data.findOne('settings', {type: 'test'}); } else { settings = sys.data.findOne('settings', {type: 'prod'}); } return settings.id(); Dynamic menu item # Dynamic menu items are equipped with a script that generates a list of menu entries. Each entry will be incorporated into the menu at the position of the dynamic menu entry.
Dynamic menu items entail the subsequent settings:
Label: This label serves as an identifier for the menu item.
Script: This script must yield an array of menu items. It can leverage app data to ascertain which entries will be accessible and their attributes. This includes information like the associated views, labels, icons, and additional options such as filters.
Returns # object [] - An array of menu items. Each item should encompass the following details:
label: This label will be displayed in the menu. icon: The icon&rsquo;s name (you can reference icon names here). view: The ID or name of the view to be loaded upon selecting the menu entry. filters: If the view supports filters, this is where you can define them. Samples # // returns a list of menu items that point to Companies view var menuEntries = []; //this entry shows only active companies menuEntries.push({ label: 'Active Companies', icon: 'account-circle', view: 'companies', filters: { active: 'true' } }); // this entry shows only inactive companies menuEntries.push({ label: 'Inactive Companies', icon: 'flower', view: 'companies', filters: { active: 'false' } }); // this entry shows all the companies (no filter applyed) menuEntries.push({ label: 'All the Companies', icon: 'case', view: 'companies' }); return menuEntries; Menu group # Menu groups offer the ability to contain multiple menu items, allowing you to logically group related items under a single label in the menu.
Menu groups come with the following configuration options:
Label: The label to be displayed in the menu. Icon: An optional icon. If you prefer not to have an icon, you can leave this field blank. It&rsquo;s important to note that this functionality is applicable solely to the main menu.
`}),e.add({id:80,href:"/dev-reference/user-interface/grid-views/",title:"Grid views",description:`Grid views facilitate the display of records from an entity in a list format. This list offers capabilities such as sorting, pagination, filtering, and more.
Within the list, users can open, edit, and delete listed records. Additionally, new records can be created directly from this view.
Furthermore, grid views can incorporate subgrids for parent-child relationships.
Entity # This specifies the entity to which the view is linked. Only records belonging to this entity will be listed within the grid view.`,content:`Grid views facilitate the display of records from an entity in a list format. This list offers capabilities such as sorting, pagination, filtering, and more.
Within the list, users can open, edit, and delete listed records. Additionally, new records can be created directly from this view.
Furthermore, grid views can incorporate subgrids for parent-child relationships.
Entity # This specifies the entity to which the view is linked. Only records belonging to this entity will be listed within the grid view.
Label # This represents the human-readable name of the view. You can use spaces, special characters, and a mixture of uppercase and lowercase letters.
The label will be displayed at the top of the grid view, so choose something comprehensible to users.
Name # The internal name of the view. This name must exclude special characters and spaces.
Commonly, this view name is utilized in scripts and the REST API. Altering it may impact your application and necessitate manual adjustments.
List settings # Behavior # These settings determine the behavior of the listing.
Sort field # This defines the default sorting field for the listing.
Users may be able to modify the default sorting if enabled in any of the columns.
Sort type # Specifies the sorting direction.
Users may be able to change the default sorting if enabled in any of the columns.
Page size # This signifies the maximum number of records fetched when the view is loaded or when users click on More to fetch additional records.
Infinite scroll # Enables automatic retrieval of more records as users scroll down.
When this option is activated, the page size is fixed at 100 records, and the More button is concealed.
Show filters # When enabled, filter controls are displayed beneath the header of each column, enabling users to filter records in the listing.
Fixed header # Activating this option locks the grid header, allowing users to retain visibility while scrolling downward.
Main menu # This setting governs the actions executable from the view header.
Available options include:
All: All view-related actions in the entity will appear in the context menu. Some: A custom selection of actions is presented. A new selector, Available actions, emerges, allowing you to pick which actions will be listed (you can select the actions&rsquo; views here). Custom Menu: Developers can customize action rendering. Actions can be grouped. Top-level groups will be rendered as dropdown buttons, while nested groups will be nested dropdowns. Various configuration options for button behavior during runtime are available, such as Label, Default options (which allows overriding of predefined configuration), Only icon, Icon, Style, and Label of action. System Actions Only: Only system actions like CRUD, Import, and Refresh will be displayed. None: No actions will be available. In all scenarios, action permissions and preconditions will be verified. Some actions may remain hidden if the user lacks the requisite permissions or preconditions are unmet.
Record menu # This option regulates the actions executable from the listing itself. They appear when users click the Actions button on the secondary menu of the listing or in the actions column when Display Record Menu Column is enabled.
Available options include:
All: Every action in the entity is displayed under the Actions button on the secondary menu or in the actions column. Note that the default view of each action is used in this scenario. Some: A custom selection of actions is available. A new selector, Available actions, allows you to pick which actions will be listed (you can select the actions&rsquo; views here). System Actions Only: Only system actions like CRUD, Import, and Refresh will be displayed. None: No actions will be available. In all cases, action permissions and preconditions will be verified. Some actions may remain hidden if the user lacks the requisite permissions or preconditions are unmet.
Display record menu column # When enabled, the last column of the listing serves as an actions column. It features a dropdown button that includes CRUD actions (edit, view, and delete), along with actions configured in the grid view. This permits quick execution of an action for a specific record without the need for prior selection.
Allow to rank records # Enabling this option enables sorting of records through drag-and-drop within the listing (utilizing arrows on the left of each row). To use this feature, the entity must possess a field of type Rank.
The following settings must be configured when this option is enabled:
Rank Field: The rank field utilized for sorting records in the list.
Rank Type: Specifies how ranking will be performed. Auto defers the decision to the platform, permitting records to be moved to any position. Select Manual to have more control and use a script to define ranking rules. This is beneficial for imposing restrictions or special rules. For example, if issues have dependencies, tasks with dependencies on other tasks cannot be above those dependent tasks. If Manual is selected, a script must be provided for context:
Parameters # Name Type Description record sys.data.Record This pertains to the record that is undergoing movement. Typically, you will update the rank field within this record using the methods available in the wrapper methods. It&rsquo;s important to remember that after updating the rank field, you must save the record. Failing to save the record will result in the rank not being updated, and the record will not be repositioned. recordBefore sys.data.Record This refers to the record that precedes the intended position for the record being moved. It might be null in instances where the record is being moved to the first position, as there would be no preceding record. recordAfter sys.data.Record This denotes the record following the intended position for the record being moved. It could be null when moving the record to the last position, as there would be no succeeding record. Samples # // rank records in a way that urgent ones are always at the top var fieldName = 'rank'; var moved = false; if (!recordBefore &amp;&amp; recordAfter) { // the record is moved to the top if (!recordAfter.field('urgent').val() || record.field('urgent').val()) { record.field(fieldName).rankBefore(recordAfter.field(fieldName)); moved = true; } } else if (recordBefore &amp;&amp; !recordAfter) { // the record is moved to the bottom if (recordBefore.field('urgent').val() || !record.field('urgent').val()) { record.field(fieldName).rankAfter(recordBefore.field(fieldName)); moved = true; } } else if (recordBefore &amp;&amp; recordAfter) { // the record is placed between two other records if ((!recordAfter.field('urgent').val() || record.field('urgent').val()) &amp;&amp; (recordBefore.field('urgent').val() || !record.field('urgent').val())) { record.field(fieldName).rankBetween(recordBefore.field(fieldName), recordAfter.field(fieldName)); moved = true; } } // IMPORTANT!!! You need to save the record to make the new rank value permanent if (moved) { sys.data.save(record); } Record highlight # The &ldquo;Record Highlight&rdquo; option allows you to specify which records should be visually highlighted using colors. This is particularly helpful when you want users to quickly notice certain records. For instance, in a task listing, you might want to emphasize urgent tasks by assigning them a distinctive red color.
Multiple highlight rules can be defined. For each rule, a color must be chosen, and an expression must be provided. All records that match the expression will be displayed using the selected color.
For more details on expressions, please refer to the Expressions documentation.
Alternatively, you have the option to use a script instead of an expression:
Parameters # Name Type Description record sys.data.Record This represents the record that will undergo evaluation to determine if it should be highlighted. Returns # boolean - You should return true if the record should be highlighted, and false if it should not be highlighted.
Samples # // the task will be highlighted if it is urgent return record.field('urgent').val() == true; Lookup field # The lookup field influences the construction of the record&rsquo;s URL. By default, the ID is utilized, resulting in the following URL structure:
https://&lt;app&gt;.slingrs.io/&lt;env&gt;/runtime/#views/&lt;viewId&gt;/readOnly/&lt;recordId&gt; When a lookup field is chosen, the recordId is substituted with the value of the lookup field. For instance, if the name field is selected as the lookup field, and the value of the opened record is test1, the resulting URL would be:
https://&lt;app&gt;.slingrs.io/&lt;env&gt;/runtime/#views/&lt;viewId&gt;/readOnly/test1 The lookup field must have the unique flag set.
Automatic refresh # Enabling this option creates a dynamic listener that ensures the view refreshes automatically for all users when a record belonging to the entity this view points to is created, updated, or deleted. This applies whether the event is triggered by a user or a script. Enabling this feature for a card view also enables it for its corresponding CRUD read-only view.
Filtering settings # Record filters # This section defines the criteria for listing records. Only records that match the provided expression will appear in the grid view.
Global search # For entities with global search enabled, you can enable the Enable global search flag to allow users to utilize this feature.
Columns # This section allows you to add or remove fields as columns in the listing&rsquo;s table. These columns will initially utilize the default display options of the associated fields, but you can override these options. Refer to the documentation on General Display Options for more details.
Columns offer additional options beyond those available for fields:
Automatic Width: Determines if the column&rsquo;s width should adapt automatically based on available space and content, or if it should have a fixed width, either in pixels or as a percentage. Allow Title Wrapping: By default, titles won&rsquo;t wrap unless this flag is enabled, which can be useful for fields with lengthy labels (you can also override the field&rsquo;s label in display options). Allow Sorting: Indicates whether sorting arrows will be present for this column. This flag is set by default for fields with the indexable flag activated. CRUD actions # Grid views support creating, reading, updating, and deleting records. This section allows you to configure these actions.
If the entity has child entities, you can configure different views for each entity type. For instance, if you have entity A and its children entities A1 and A2, creating a record view for A lets you configure views for A1 and A2. As a result, when you create a grid view for entity A, you&rsquo;ll see records from A1 and A2. The displayed record view depends on the type of record you open.
Create # Allow to create** # This action is used to generate new records within the entity. When enabled, a button for creating new records will appear in the listing. For entities associated with this view&rsquo;s entity that have child entities, a button dropdown displaying available options will be shown.
You can configure the record view for creating a new record by clicking Configure View. For more details, refer to the Record Views Documentation.
Open in modal** # Enabling this flag displays the new record creation view in a modal instead of replacing the listing as the main content.
Show next button** # When this option is enabled, apart from the Cancel and Save buttons, a Next button will appear when creating a new record. This button saves the record and immediately shows the form for creating another new record. This feature proves useful for rapid creation of multiple records.
Selected view** # This setting allows you to select the view for the create CRUD action. Available options for selection include create-type record views of the current entity or custom views. If you opt for a Custom View, a JSON context with information will be conveyed through a message event. To utilize this information in the custom view, add an event listener in the custom view&rsquo;s main file. Additionally, when the Create action button is pressed, a message event is triggered to inform the custom view. The custom view can listen for this event and perform an action. This add event is also triggered after executing other custom actions.
Sample of a listener set in a custom view in order to obtain some context information
window.addEventListener('message', function (event) { //We wait for a message from the platform to let us know the Create Button has been pressed if (event.data.eventType) { if (event.data.eventType === 'add') { //This is a method we should implement to save the new data and then comunicate it back to the platform self.createRecord(); } // Logs the context. This happened once the custom view is fully rendered }else if(event.data.context){ var context = event.data.context; var entity = event.data.context.entity; sys.logs.info(&quot;CONTEXT: &quot; + JSON.stringify(context)); } }); Once you&rsquo;re listening for the add event, you can proceed to implement specific functionalities. Custom views offer a utility method for creating new records and subsequently notifying the platform. Additional details on this can be found in the Custom View section.
Sample of an implementation of a createRecord() method
self.createRecord = function () { console.log('creating new record from REST API'); //Custom view method to create a record and inform back to the platform sys.ui.createRecord(entity.name, newRecord, function (recordCreated) { console.log(&quot;ON SUCCESS RECORD: &quot; + JSON.stringify(recordCreated)); }, function (error) { console.log(&quot;ON ERROR :&quot; + JSON.stringify(error)); }) }; Read # Allow to see details # Enabling this action permits users to open a record from the listing. When enabled, users can click on a record within the listing to view its details. Additionally, the View action will be visible in the action column (if enabled).
You can configure the record view to display details by clicking Configure View. For more information, refer to the Record Views Documentation.
Open in modal # If this flag is set, the view for seeing details of records will be presented in a modal, instead of replacing the listing as the main content.
Selected view # This setting enables you to choose the view for the read-only CRUD action. Available options for selection include read-only record views of the current entity or custom views. If you opt for a Custom View, a JSON context with information will be conveyed through a message event. To utilize this information in the custom view, add an event listener in the custom view&rsquo;s main file. Furthermore, when the Refresh action button is pressed, a message event is triggered to inform the custom view. The custom view can listen for this event and perform an action. This refresh event is also triggered after executing other custom actions.
Sample of a listener set in a custom view in order to obtain some context information
// Logs the context and the event type window.addEventListener('message', function (event) { if(event.data.eventType){ var eventType = event.data.eventType; sys.logs.info(&quot;EVENT: &quot; + JSON.stringify(eventType)); }else if(event.data.context){ var context = event.data.context; sys.logs.info(&quot;CONTEXT: &quot; + JSON.stringify(context)); } }); Update # Allow to edit # Enabling this action enables users to edit a record from the listing. When enabled, users will observe an Edit button in the read view of the record (the read action must be enabled), and they will also see the Edit action in the action column (if enabled).
You can configure the record view for editing by clicking Configure View. Refer to the Record Views Documentation for detailed information.
Open in modal # If this flag is set, the view for editing records will be displayed in a modal, instead of replacing the listing as the main content.
It&rsquo;s important to note that if the read view isn&rsquo;t configured to be shown in a modal, it won&rsquo;t appear as a modal when accessing the edit view from the read view. This setting solely applies when clicking the Edit option in the action column of the listing.
Selected view # This setting allows you to choose the view for the update CRUD action. Available options for selection include edit-type record views of the current entity or custom views. Opting for a Custom View sends a JSON context with information through a message event. To leverage this information in the custom view, add an event listener in the custom view&rsquo;s main file. Moreover, pressing the Save action button triggers a message event to inform the custom view about the save button being pressed. Consequently, the custom view can listen for this event and execute an action. This edit event is also triggered after performing other custom actions.
Sample of a listener set in a custom view in order to obtain some context information
window.addEventListener('message', function (event) { //We wait for a message from the platform to let us know the Save Button has been pressed if (event.data.eventType) { if (event.data.eventType === 'edit') { //This is a method we should implement to save the new data and then comunicate it back to the platform self.updateRecord(); } // Logs the context. This happened once the custom view is fully rendered }else if(event.data.context){ var context = event.data.context; var entity = event.data.context.entity; var contextRecord = event.data.context.record; sys.logs.info(&quot;CONTEXT: &quot; + JSON.stringify(context)); } }); Once you&rsquo;re listening for the edit event, you can proceed to implement specific functionalities. Custom views offer a utility method for updating records and subsequently notifying the platform. Additional details on this can be found in the Custom View section.
Sample of an implementation of a updateRecord() method
self.createRecord = function () { console.log('creating new record from REST API'); //Custom view method to create a record and inform back to the platform sys.ui.createRecord(entity.name, newRecord, function (recordCreated) { console.log(&quot;ON SUCCESS RECORD: &quot; + JSON.stringify(recordCreated)); }, function (error) { console.log(&quot;ON ERROR :&quot; + JSON.stringify(error)); }) }; Delete # Allow to delete # Enabling this action allows records to be deleted. When enabled, a Delete button will be visible in the listing. This button permits the deletion of all selected records. The Delete option will also appear in the action column dropdown and in the read view.
Sub-Grids # Sub-grids are valuable for representing one-to-many relationships. Consider a scenario where you have customers and each customer can have multiple contacts. In this case, you could include contacts as a sub-grid within the customers&rsquo; view.
When the read view of a record is opened, sub-grids will be displayed below the main record.
Sub-grids possess the following attributes:
Title: This title identifies the sub-grid in the user interface. Entity: This is the entity that the sub-grid points to. It must have a relationship field pointing to the entity of the main grid view. Related Field: This is the relationship field that establishes a connection from the sub-grid&rsquo;s entity to the entity of the main grid view. Condition: This permits conditional display of the sub-grid. For instance, you might want to display the orders sub-grid only when the customer is active. Options for conditions are: None: The sub-grid will always be displayed.
Expression: This defines an expression that the record in the main grid view must satisfy to display the sub-grid.
Script: This enables you to create a script to determine whether the sub-grid should be displayed. The context for this script is:
Parameters # Name Type Description record sys.data.Record This is the record in the main grid view. Returns # boolean - You should return true if the sub-grid has to be displayed, false otherwise.
Samples # // only show contacts if customer is active return record.field('state').val() == 'active'; The configuration of sub-grids is identical to that of the main view. There&rsquo;s only a small behavioral difference when creating a new record: the field configured in Related Field will be pre-populated with the record from the main view.
Filters # Global filters # If the Allow Global Filters flag is enabled, the user interface allows users to filter records in the grid based on the fields indicated in Global Filter Fields.
Override label # When Allow Global Filters is enabled, the Global Filter Fields section includes an Override Label flag, which allows overriding the default filter label (which is the field label).
Enable global search # Enabling this option displays a search box above the listing that facilitates filtering fields using the global search feature. This feature finds words in any field of the record.
This option is only available if the entity has global search enabled.
Quick filters # Quick filters provide an effortless way to further filter the collection of records by clicking or unclicking buttons. Refer to Expressions for additional information.
Permissions # Permissions enable the definition of groups that can access this view.
Permissions for a view can be managed directly in the view definition, although it represents a different perspective of what can be configured in groups. This approach facilitates easy configuration of permissions for all existing groups.
When a new view is created and a group has permissions for the entity associated with that view, the view automatically receives permission for usage by that group.
For more comprehensive information about permissions, please consult the Groups Documentation.
`}),e.add({id:81,href:"/dev-reference/user-interface/workflow-views/",title:"Workflow views",description:"Workflow views facilitate the display of entity records in a board-style layout, organized by columns. This organizational structure proves particularly beneficial for scenarios involving workflows. For instance, you could employ a tasks entity, and within the workflow view, you could establish columns such as To do, In progress, and Done. Records are allocated to respective columns based on their status. Users possess the capability to shift cards across columns as they progress through tasks, arrange cards within columns to indicate priority, and more.",content:`Workflow views facilitate the display of entity records in a board-style layout, organized by columns. This organizational structure proves particularly beneficial for scenarios involving workflows. For instance, you could employ a tasks entity, and within the workflow view, you could establish columns such as To do, In progress, and Done. Records are allocated to respective columns based on their status. Users possess the capability to shift cards across columns as they progress through tasks, arrange cards within columns to indicate priority, and more.
Workflow views offer the following functionality:
Creation of new records Access to record details Editing of records Execution of actions These capabilities parallel those of grid views. The fundamental distinction lies in the visual representation of records. In a workflow view, records appear as cards within a board, as opposed to a traditional list format.
To facilitate the transition of records from one column to another, transitions must be defined. Transitions hinge on an associated action, executed upon the movement of a record.
Finally, customization options extend to card rendering. Developers can configure the appearance of cards by modifying the title, content, and tags.
Entity # This specifies the entity to which the view is linked. Only records belonging to this entity will be listed within the grid view.
Label # This represents the human-readable name of the view. You can use spaces, special characters, and a mixture of uppercase and lowercase letters.
The label will be displayed at the top of the grid view, so choose something comprehensible to users.
Name # The internal name of the view. This name must exclude special characters and spaces.
Commonly, this view name is utilized in scripts and the REST API. Altering it may impact your application and necessitate manual adjustments.
Columns # Columns form the structural foundation of workflow views. Primarily, columns mirror different states that records can assume, although they can also be based on alternate criteria.
Label # This label designates the column&rsquo;s title, displayed at the top of the column in the user interface.
Sort field # This indicates the default sorting field for the column.
Sort type # Specifies the sorting direction.
Width # This signifies the column&rsquo;s width, which can be specified in pixels or as a percentage. When using a percentage, the reference point is the width of the main content area. If pixel values are employed and the width exceeds the available space, horizontal scrolling will be enabled to navigate through other columns.
Filters # Filters enable the specification of criteria for which records will be displayed in the column. Consequently, only records matching the expressions defined within the filters will appear in the column. For instance, if the column pertains to To do, a filter might be placed on records with a state field equivalent to toDo (or any other applicable filter condition).
For comprehensive details and configuration instructions regarding filters, consult the Expressions documentation.
Page Size # This designates the maximum number of records to be initially fetched and when users scroll through the list.
Allow to rank records # Enabling this option enables sorting of records through drag-and-drop within the column. To use this feature, the entity must possess a field of type Rank.
The following settings must be configured when this option is enabled:
Rank Field: The rank field utilized for sorting records in the column.
Rank Type: Specifies how ranking will be performed. Auto defers the decision to the platform, permitting records to be moved to any position. Select Manual to have more control and use a script to define ranking rules. This is beneficial for imposing restrictions or special rules. For example, if issues have dependencies, tasks with dependencies on other tasks cannot be above those dependent tasks. If Manual is selected, a script must be provided for context:
Parameters # Name Type Description record sys.data.Record This pertains to the record that is undergoing movement. Typically, you will update the rank field within this record using the methods available in the wrapper methods. It&rsquo;s important to remember that after updating the rank field, you must save the record. Failing to save the record will result in the rank not being updated, and the record will not be repositioned. recordBefore sys.data.Record This refers to the record that precedes the intended position for the record being moved. It might be null in instances where the record is being moved to the first position, as there would be no preceding record. recordAfter sys.data.Record This denotes the record following the intended position for the record being moved. It could be null when moving the record to the last position, as there would be no succeeding record. Samples # // rank records in a way that urgent ones are always at the top var fieldName = 'rank'; var moved = false; if (!recordBefore &amp;&amp; recordAfter) { // the record is moved to the top if (!recordAfter.field('urgent').val() || record.field('urgent').val()) { record.field(fieldName).rankBefore(recordAfter.field(fieldName)); moved = true; } } else if (recordBefore &amp;&amp; !recordAfter) { // the record is moved to the bottom if (recordBefore.field('urgent').val() || !record.field('urgent').val()) { record.field(fieldName).rankAfter(recordBefore.field(fieldName)); moved = true; } } else if (recordBefore &amp;&amp; recordAfter) { // the record is placed between two other records if ((!recordAfter.field('urgent').val() || record.field('urgent').val()) &amp;&amp; (recordBefore.field('urgent').val() || !record.field('urgent').val())) { record.field(fieldName).rankBetween(recordBefore.field(fieldName), recordAfter.field(fieldName)); moved = true; } } // IMPORTANT!!! You need to save the record to make the new rank value permanent if (moved) { sys.data.save(record); } Transitions # Transitions outline the process by which cards can be relocated from one column to another. Without a defined transition for card movement between columns, such movements cannot be facilitated within the user interface.
The following settings pertain to transitions:
Label: This serves as a label for identifying the transition. Source Column: Indicates the column from which cards will be dragged. Target Column: Specifies the column to which cards will be dropped. Action: This pertains to the action executed upon card drop. If the action encompasses parameters, a modal will prompt the user to complete the form and confirm the action. In cases where the action lacks a confirmation requirement, it will automatically execute, bypassing the confirmation flag. It&rsquo;s crucial to note that the action bears the responsibility of altering the record in a manner that situates it in the new column. For example, if the transition enables the transfer of a record from the To do column to the In progress column, the action must modify the task&rsquo;s state from toDo to inProgress. Failure to update the record within the action, for any reason, will result in the record being returned to its original column.
Card settings # Card settings dictate the visual presentation of cards, encompassing elements such as headers, content, and tags.
Header # The header is located at the top of the card. It should be concise (commensurate with the column&rsquo;s configured width) and provide sufficient information for users to identify the record.
Two methods exist for defining the header:
Field: Selection of a field within the entity, with the field&rsquo;s value serving as the header.
Script: In instances where a more intricate header, combining different fields, is necessary, a script can be employed. The script&rsquo;s context is as follows:
Parameters # Name Type Description record sys.data.Record The record that the card is representing. Returns # string - Plain text that will be used as the header.
Samples # // builds the header using the task number and summary return record.field('number').val() + '. ' + record.field('summary').val(); Summary # The summary is displayed within the card&rsquo;s body. While it should offer more comprehensive details about the record, an effort should be made to maintain brevity, ideally limiting the content to three lines or fewer. In cases where content exceeds this limit, vertical scrolling will be enabled within the card&rsquo;s body.
Two approaches exist for defining the summary:
Field: Selection of a field within the entity, with the field&rsquo;s value serving as the summary.
Script: In instances where a more intricate summary, involving the combination of different fields, is necessary, a script can be employed. The script&rsquo;s context is as follows:
Parameters # Name Type Description record sys.data.Record The record that the card is representing. Returns # string - HTML code that will be rendered in the body of the card. Keep in mind that HTML tags allowed are the same as for HTML type.
Samples # // builds the summary using different fields var summary = ''; if (record.field('description').isEmpty()) { summary += 'No description'; } else { summary += record.field('description').val(); } if (!record.field('attachments').isEmpty()) { summary += 'Attachments' summary += ''; record.field('attachments').each(function(attachment) { var url = sys.app.getUrl()+'/api/files/'+attachment.id(); summary += ''+attachment.name()+'' }); summary += ''; } return summary; Tags groups # Tags are situated at the base of the card, comprised of a label and a color. They serve as a means to swiftly highlight aspects within the card. For instance, urgent tasks could be designated with a red tag labeled &lsquo;urgent,&rsquo; allowing users to promptly identify them.
Label # This label designates the tags group, providing a means of signifying the significance of the tag group.
Filter # This filter specifies which records may possess this tag. However, the presence of this filter does not necessarily guarantee that records will bear the tag. Additional considerations might stem from the label script or the absence of content within the label field.
For comprehensive information and guidance on configuring filters, consult the Expressions documentation.
Color # This denotes the color employed for the tag. These colors are aligned with the theme.
Tags # The subsequent options are available for tags:
Fixed Text: A single tag with the provided text.
Field: The value of the designated field serves as the tag label. If the field is multi-valued, a tag will be added for each value. Should the field be empty, no tags will be appended.
Script: This option allows the definition of tags using a script. Essentially, the script should return either a string (a single tag) or a list of strings (multiple tags).
Parameters # Name Type Description record sys.data.Record The record that the card is representing. Returns # string|string[] - This is the text to show in the tag. If the script returns a string, it will considered one tag. If the script returns an array of strings, many tags will be added.
Samples # // adds the company state as tag return record.field('company').fetch().field('state').val(); Record Highlight # This option empowers you to designate records that should stand out through the application of colors. This proves invaluable when seeking to draw users&rsquo; swift attention to specific aspects. For instance, in a task listing, urgent tasks could be highlighted in red, facilitating rapid identification.
Multiple highlight rules can be established. For each rule, a color must be selected, and an associated expression must be defined. Any records that satisfy the expression will be presented with the chosen color.
For comprehensive details and guidance on expressions, refer to the Expressions documentation.
Alternatively, a script can be employed in place of an expression:
Parameters # Name Type Description record sys.data.Record The record that the card is representing and that will be evaluated to see if it has to be highlighted. Returns # boolean - You should return true if the record has to be highlighted, false otherwise.
Samples # // the task will be highlighted if it is urgent return record.field('urgent').val() == true; Main menu # This option governs the actions that can be executed from the view header.
The available options are:
All: All available action views associated with the entity will be displayed in the context menu. Some: A customized selection of actions will be accessible. This introduces a new selector called Available actions, which is employed to choose which actions will be listed (the corresponding views of these actions are selected here). Custom menu: This option provides developers with the ability to customize how actions are presented. Actions can be grouped into logical categories. Top-level groups will appear as dropdown buttons, while nested groups will form nested dropdowns. Several runtime behavior configurations for buttons are available: Label: Solely applicable to Groups. Groups can be assigned a label. Default options: If disabled, certain configuration aspects of the action views can be overridden. Only icon: Relevant to top-level elements. Buttons can be displayed with only icons. Icon: Overrides the predefined icon associated with the action. If left empty, the icon is not overridden. Style: Overrides the predefined style associated with the action. If left empty, the style is not overridden. Label of action: Overrides the label of the action. If left empty, the label is not overridden. System Actions Only: Only system actions such as CRUD, Import, Refresh, etc., will be shown. None: No actions will be available. In all cases, permissions and preconditions of actions will be verified, potentially resulting in the hiding of certain actions if the user lacks the requisite permissions or preconditions are not met.
Record menu # This option governs the actions that can be executed from each card. These actions will be displayed in the context menu associated with each card (identifiable through the three vertical dots in the upper-right corner of the card).
The available options are:
All: All available action views associated with the entity will be displayed in the context menu of the cards. Some: A customized selection of actions will be accessible. This introduces a new selector called Available actions, which is employed to choose which actions will be listed (the corresponding views of these actions are selected here). System Actions Only: Only system actions such as CRUD, Import, Refresh, etc., will be displayed. None: No actions will be available. In all cases, permissions and preconditions of actions will be verified, potentially resulting in the hiding of certain actions if the user lacks the requisite permissions or preconditions are not met.
Automatic refresh # When this flag is enabled, a dynamic listener will be established to enable automatic refreshing of this view for all users whenever a record belonging to the entity to which this view is directed is created, updated, or deleted. Whether the event is initiated by a user or a script, this feature remains effective. By enabling this feature on a card view, it is simultaneously enabled on its corresponding CRUD read-only view.
CRUD actions # Workflow views support the creation, reading, updating, and deletion of records. In this section, you can configure these actions.
If the entity encompasses child entities, distinct views can be configured for each type of entity. For instance, if Entity A has entities A1 and A2 as its children, creating a record view for A facilitates the configuration of views for entities A1 and A2.
Consequently, a card view for Entity A will display records from A1 and A2. Depending on the type of record opened, the corresponding record view will be displayed.
Create # Allow to create # This action facilitates the creation of new records within the entity. Enabling this option introduces a button that allows the creation of new records within the listing. If the entity associated with the view has child entities, a button dropdown displaying available options will be presented.
The configuration of the record view for creating new records can be accessed by clicking Configure View. For a comprehensive understanding of record views, consult the Record Views documentation.
Open in modal # When enabled, this flag ensures that the view for creating a new record is displayed in a modal window rather than replacing the listing as the primary content.
Show next button # Enabling this option introduces a Next button alongside the Cancel and Save buttons when creating a new record. Selecting Next not only saves the current record but also promptly displays the form to create a new record. This feature streamlines the process of creating multiple records.
Read # Allow to view details # This action enables users to access a detailed view of a record from the listing. Enabling this option permits users to click on a record within the listing to view additional details. Furthermore, the View action will be available in the action column (if enabled).
The configuration of the record view for detailed viewing can be accessed by clicking Configure View. For detailed insights into record views, refer to the Record Views documentation.
Open in modal # When enabled, this flag ensures that the detailed view of records is displayed in a modal window rather than replacing the listing as the primary content.
Update # Allow to edit # This action facilitates the editing of records from within the listing. Enabling this option will present an Edit button within the detailed view of a record (which requires the read action to be enabled). Additionally, the Edit action will be available in the action column (if enabled).
The configuration of the record view for editing can be accessed by clicking Configure View. For a comprehensive understanding of record views, consult the Record Views documentation.
Open in modal # When enabled, this flag ensures that the view for editing records is displayed in a modal window rather than replacing the listing as the primary content. It&rsquo;s important to note that if the read view is configured to not show in a modal, this setting will not be applied when accessing the edit view from the read view. This setting primarily applies when clicking on Edit in the action column of the listing.
Delete # Allow to delete # This action empowers users to delete records. When enabled, a Delete button will be visible within the listing, allowing users to delete selected records. This button will also appear in the action column&rsquo;s dropdown and in the detailed view.
Filters # Global Filters # If the Allow Global Filters flag is enabled, users can filter cards on the board based on the fields specified in Global Filter Fields.
Override label # When Allow Global Filters is enabled, the Override Label flag is available on Global Filter Fields, allowing for the customization of the filter label (by default, the label corresponds to the field label).
For entities with enabled global search, it is possible to activate the Allow Global Search flag.
Quick filters # Quick filters enable effortless card filtering through the simple act of clicking or unclicking buttons.
For more information, consult Expressions.
Permissions # Permissions determine which groups can access this view.
While permissions for a view can be configured directly within the view definition, it mirrors the capabilities available in group configuration. The objective is to facilitate easy permission configuration for all existing groups.
Upon the creation of a new view, if a group holds permissions for the entity associated with that view, the view will inherently be granted permission for use by that group.
For a comprehensive understanding of permissions, refer to the Groups documentation.
`}),e.add({id:82,href:"/dev-reference/user-interface/calendar-views/",title:"Calendar views",description:`Calendar views enable you to display records from an entity on a calendar, where each record represents an editable event. By default, the current month is displayed, but you can navigate through different months and switch between various views to see weeks and days.
From within calendar views, you can perform actions such as creating new records, viewing details of individual records, editing records, and executing actions—similar to the functionalities available in grid and card views.`,content:`Calendar views enable you to display records from an entity on a calendar, where each record represents an editable event. By default, the current month is displayed, but you can navigate through different months and switch between various views to see weeks and days.
From within calendar views, you can perform actions such as creating new records, viewing details of individual records, editing records, and executing actions—similar to the functionalities available in grid and card views. The key distinction is that instead of presenting records as a list or arranging them as cards in columns, they are presented as events on a calendar.
Furthermore, you have the capability to configure the appearance of events by customizing their titles and colors.
Entity # This specifies the entity to which the view is linked. Only records belonging to this entity will be listed within the grid view.
Label # This represents the human-readable name of the view. You can use spaces, special characters, and a mixture of uppercase and lowercase letters.
The label will be displayed at the top of the grid view, so choose something comprehensible to users.
Name # The internal name of the view. This name must exclude special characters and spaces.
Commonly, this view name is utilized in scripts and the REST API. Altering it may impact your application and necessitate manual adjustments.
Calendar settings # Allow event editing # This flag indicates whether the duration of an event can be edited from the calendar view.
Record filters # Filters allow you to specify which records will be displayed as events on the calendar. Only records that match the expressions specified in the filters will be included in the view. For instance, if the calendar is intended to show events in a To do status, you would likely apply a filter to include records where the state field equals toDo (or any relevant criteria).
Please refer to the Expressions documentation for detailed information on configuring these filters.
Automatic refresh # Mark this option to enable automatic refreshing of the view when a record event occurs.
Record settings # Here you can configure the record events. This configuration will be applied to each displayed record in the view.
From field # Select the From field from the entity to be used for determining the event start on the view. This field is mandatory.
To field # Select the To field from the entity to be used for determining the event end on the view. This field is mandatory.
All day record field # Select a field from the entity that indicates whether this record represents an All day event. This field can only be of boolean type.
Title # Choose the event title type. It can be either Field or Script.
Field # Select the Title from the entity to be used as the event label on the view. This field is available and required only if Title is set to Field.
Script # Manually set the event label on the view by providing a script that must return a String value. This field is available and required only if Title is set to Script. The script operates in the following context:
Parameters # Name Type Description record sys.data.Record The record where the event title is being calculated. Returns # string - You should return a string to be used as event title.
Samples # // builds the title using last name and description return record.field('lastName').val() + ': ' + record.field('description').val(); Highlight default color # Define the record color for each event.
Main menu # This option controls the actions that can be executed from the view header.
The available options are:
All: Show all available actions for the entity in the event context menu. Some: Allow a custom selection of actions. A new selector called Available actions will appear. This can be used to choose which actions to list (you select the action views here). Custom Menu: Developers can customize how actions are displayed. Actions can be grouped, with root-level groups shown as dropdown buttons and nested groups as nested dropdowns. There are additional options to configure button behavior at runtime. Label: For Groups only. Groups can have labels. Default Options: If false, it allows the override of certain action view configurations. Only Icon: For root-level elements only. Buttons can be displayed with only the icon. Icon: Overrides the predefined icon of the action. If empty, the icon won&rsquo;t be overridden. Style: Overrides the predefined style of the action. If empty, the style won&rsquo;t be overridden. Label of Action: Overrides the label of the action. If empty, the label won&rsquo;t be overridden. System Actions Only: Display only system actions like CRUD, Import, Refresh, etc. None: No actions will be available. In all cases, permissions and preconditions of actions will be checked. Some actions might be hidden if the user lacks permissions or if preconditions aren&rsquo;t met.
Record menu # This option controls the actions that can be executed from each event. These actions will be shown in the context menu belonging to each event.
The available options are:
All: Show all available entity actions in the event context menu. Some: Allow a custom selection of actions. A new selector called Available actions will appear. This can be used to choose which actions to list (you select the action views here). System Actions Only: Display only system actions like CRUD, Import, Refresh, etc. None: No actions will be available. In all cases, permissions and preconditions of actions will be checked. Some actions might be hidden if the user lacks permissions or if preconditions aren&rsquo;t met.
Record highlight # In this section, you can configure various record colors to distinguish records on the calendar. This differentiation can be based on defined preconditions. If no conditions are met, the record will adopt the highlight default color.
Color # Select the color to be applied to the event.
Color activation type # Choose how the color precondition will be expressed. Available options are Expression and Script.
Filter # Only records matching the expressions specified in the filter will be assigned the selected color. Please refer to the Expressions documentation for comprehensive guidance on configuring these filters. This setting is available and required only if Color activation type is set to Expression.
Script # Manually determine whether the color should be applied to the event. Provide a script that returns a Boolean value. This setting is available and required only if Color activation type is set to Script. The script operates within the following context:
Parameters # Name Type Description record sys.data.Record The record where the event title is being calculated. Returns # boolean - You should return a boolean to know if the color should be applied.
Samples # // apply the color only to the records that has a description return record.field('description').val() !== ''; CRUD actions # From calendar views, you can perform the create, read, update, and delete actions on records. This section allows you to configure these actions.
If the entity has child entities, you can configure different views for each type of entity. For example, if you have entity A, and entities A1 and A2 are its children, creating a record view for entity A enables configuring the view for entities A1 and A2.
In this manner, if you create a calendar view for entity A, it will display records from A1 and A2. Depending on the record type you open, the corresponding record view will be displayed.
Create # Allow creation # This action is used to create new records in the entity. Enabling this will provide a button to create new records in the listing. If the entity associated with the view has child entities, a button dropdown with available options will be displayed.
You can configure the record view for creating a new record by clicking on Configure view. Please refer to the documentation on Record Views.
Open in modal # If this flag is set, the view for creating a new record will appear in a modal instead of replacing the listing as the main content.
Show next button # If this option is enabled, while creating a new record, in addition to the Cancel and Save buttons, a Next button will be shown. This button will save the current record and immediately display the form for creating the next record. This is useful when users need to create multiple records rapidly.
Read # Allow viewing details # This action is used to open a record from the listing to view details. Enabling this allows users to click on a record in the listing to see its details. The View action will be displayed in the action column (if enabled).
You can configure the record view for viewing details by clicking on Configure view. Please refer to the documentation on Record Views.
Open in modal # If this flag is set, the view for displaying record details will be shown in a modal instead of replacing the listing as the main content.
Update # Allow editing # This action is used to edit a record from the listing. Enabling this displays an Edit button in the read view of the record (this requires the read action to be enabled), and it also shows the Edit action in the action column (if enabled).
You can configure the record view for editing by clicking on Configure view. Please refer to the documentation on Record Views.
Open in modal # If this flag is set, the view for editing records will be displayed in a modal instead of replacing the listing as the main content.
Please note that if the read view isn&rsquo;t configured to display as a modal, it won&rsquo;t be displayed in a modal when accessing the edit view from the read view. This setting only applies when clicking on the Edit action in the listing&rsquo;s action column.
Filters # Global filters # When the Allow Global Filters flag is enabled, the UI permits users to filter cards on the board by the fields specified in Global Filter Fields.
Override label # When Allow Global Filters is enabled, within Global Filter Fields, a flag called Override Label allows overriding the default filter label (which is the field label).
Quick Filters # Quick filters enable you to further filter the collection of cards easily by clicking/unclicking buttons.
Permissions # Permissions define which groups can access this view.
While permissions for a view can be managed directly in the view definition, they can also be configured within groups. This approach makes it easy to configure permissions for all existing groups specifically on the view.
When a new view is created, if a group has permissions for the entity associated with that view, then the view inherits permission to be used for that group.
For more detailed information about permissions, please refer to the Groups documentation.
`}),e.add({id:83,href:"/dev-reference/user-interface/record-views/",title:"Records views",description:`Record views enable you to display the content of a record. You can specify which fields are shown, override default display options, and indicate which actions can be performed, among other things.
Label # This represents a human-readable name for the view. You can utilize spaces, special characters, and a mixture of upper and lower case letters.
This label will appear at the top of the grid view, so ensure you choose something that users will readily comprehend.`,content:`Record views enable you to display the content of a record. You can specify which fields are shown, override default display options, and indicate which actions can be performed, among other things.
Label # This represents a human-readable name for the view. You can utilize spaces, special characters, and a mixture of upper and lower case letters.
This label will appear at the top of the grid view, so ensure you choose something that users will readily comprehend.
Name # This serves as the internal name of the view. It must exclude special characters and spaces.
Typically, you&rsquo;ll employ the view name in scripts and the REST API. Changing it might impact your app, necessitating manual adjustments.
Entity # This designates the entity that the view will be associated with. Only records from this entity can be displayed within the view.
Type # The type specifies the purpose of the record view. The available options are:
Read only: In this scenario, the view won&rsquo;t include editable fields (they will be restricted to read-only). Nonetheless, this type of record view is the only one that supports executing actions on the record (actions like edit or create views cannot be executed). Consequently, when this feature is enabled, the &ldquo;Main menu&rdquo; option becomes accessible, offering these choices: All: All action views available in the entity will be presented in the context menu. Some: A personalized selection of actions will be available. A new selector, &ldquo;Available actions,&rdquo; will emerge. This selector can be used to pick the actions that will be listed (you choose the action views here). Custom menu: Developers can customize how actions are displayed using this option. Actions can be organized into groups. At the root level, groups will be showcased as dropdown buttons, while nested groups will form nested dropdowns. Several options are available to configure button behavior during runtime: Label: Applicable to Groups only. Groups can include a label. Default options: If this flag is set to false, it permits overriding certain action view configurations. Only icon: Applicable to root-level elements. Buttons can be displayed solely with an icon. Icon: Overrides the predefined icon for the action. If left empty, the icon won&rsquo;t be overridden. Style: Overrides the predefined style of the action. If left empty, the style won&rsquo;t be overridden. Label of action: Overrides the action&rsquo;s label. If left empty, the label won&rsquo;t be overridden. System Actions Only: Only system actions such as CRUD, Import, Refresh, etc., will be presented. None: No actions will be available. Create: Allows the creation of a new record. In this case, fields can be editable (you can also have read-only fields), and buttons to create the record or cancel the action will be available. Edit: Permits the modification of an existing record. You can have both editable and read-only fields, and buttons to save or cancel the changes will be provided. Managed # Enabling this feature results in new fields added to the entity being automatically added to the view.
By default, this flag is set, as it greatly facilitates development, eliminating the need to be overly concerned with views and allowing you to focus on the model.
Disabling this feature means you need to manually handle the addition of new fields. Changes to or deletion of fields in the entity will still propagate to the view, but new fields must be managed manually.
Show refresh button # Displays a Refresh button, which enables refreshing record data without needing to reload the entire page.
This flag is enabled by default.
Automatic refresh # When enabled, a dynamic listener will be established to facilitate the automatic refreshing of this view for all users whenever a record belonging to the entity associated with this view is updated—whether the event is initiated by a user or a script. This configuration option will be accessible only if the parent collection view (grid or card) hasn&rsquo;t already enabled this feature or if there is no parent view.
Alert for unsaved changes # Enabling this flag triggers a user message whenever an attempt is made to leave the form after modifying a field. Leaving the form with unsaved changes without encountering the warning is only possible using the cancel button. The message offers the choice to proceed with the record edit or discard changes and proceed with navigation. This feature is functional for both create and edit views and is enabled by default.
Form layout # Allows the definition of how labels and fields are presented on the form. Options include Horizontal, where the label is positioned to the left of the input field, or Vertical, where the label appears above the field.
Fields # This represents the list of fields to be displayed in the view. It is possible to sort, remove unnecessary fields, and more.
At this point, you can override default display options. For further details, consult the documentation on General Display Options.
Events # Events permit customization of the UI&rsquo;s behavior.
These events only apply to the view. Consequently, they are triggered only when interacting with the app through the UI and not via the REST API.
Before show # This event is triggered before presenting the record to the user. For instance, you could effect changes to the record or log that the user accessed the record before its display.
Parameters # Name Type Description record sys.data.Record This is the record that will be shown in the view. Any modifications you make here will be reflected in the UI. You don&rsquo;t need to explicitly save these changes; they will be applied instantly. However, if you choose to save these changes, they will become permanent. Samples # // suggests a new value for a field sys.logs.info('attempt to set a task as urgent'); record.field('urgent').val(true); record.field('assignee').val(sys.context.getCurrentUser()); After create # This event is triggered after a user successfully creates a record. This can be valuable in scenarios where it&rsquo;s necessary to navigate to another view or display a custom message.
Parameters # Name Type Description record sys.data.Record This is the record that will be shown in the view. Any modifications you make here will be reflected in the UI. You don&rsquo;t need to explicitly save these changes; they will be applied instantly. However, if you choose to save these changes, they will become permanent. Samples # // logs message and navigate to other view sys.logs.info('Record '+record.field('name').val()+' created successfully'); sys.ui.sendMessage({ scope: 'global', name: 'navigate', view: 'dashboard' }); On record change # This event is triggered whenever a field&rsquo;s value changes. For instance, you could apply alterations to a record field based on the value of another field.
Parameters # Name Type Description record sys.data.Record This is the record that will be displayed in the view. You can make changes to it and they will be applied in the UI. You don’t need to save those changes. If you do, those changes will be made permanent. modifiedField string This is the field path that fires the record refresh in the view. Samples # // suggests a new value for a field if (!record.field('myLabel').isEmpty() &amp;&amp; record.field('name').isEmpty()) { record.field('name').val(record.field('myLabel').val()); sys.logs.info('Since name is empty and myLabel is not, we will set the value using the one from myLabel field: ' + record.field('myLabel')); } After save # This event is triggered after a user successfully saves a record. For instance, this event can be utilized to navigate to a different view or display a message.
Parameters # Name Type Description record sys.data.Record Updated record from the view. Samples # // logs message and navigate to the dashboard view sys.logs.info('Record '+record.field('name').val()+' saved successfully'); sys.ui.sendMessage({ scope: 'global', name: 'navigate', view: 'dashboard' }); Permissions # Permissions allow you to define which groups can access this view.
Permissions for a view can be managed directly within the view definition. However, this approach is just an alternate way of configuring permissions compared to using groups. It is designed to provide an easy means of configuring permissions for the view across all existing groups.
When a new view is created, if a group has permissions to access the entity associated with that view, the view automatically inherits permission for use within that group.
For detailed information about permissions, please consult the Groups documentation.
`}),e.add({id:84,href:"/dev-reference/user-interface/action-views/",title:"Action views",description:`To enable the execution of an action from the UI, it&rsquo;s necessary to define a corresponding view for it. Simplifying this process, when an action is created, a default view is also generated. This default view is fully managed, meaning new parameters will be automatically added and removed as you modify your actions. In many cases, you can simply disregard action views and utilize the default view.
Nevertheless, it&rsquo;s possible to create multiple views for a single action, each configured based on different requirements within different UI components.`,content:`To enable the execution of an action from the UI, it&rsquo;s necessary to define a corresponding view for it. Simplifying this process, when an action is created, a default view is also generated. This default view is fully managed, meaning new parameters will be automatically added and removed as you modify your actions. In many cases, you can simply disregard action views and utilize the default view.
Nevertheless, it&rsquo;s possible to create multiple views for a single action, each configured based on different requirements within different UI components. For instance, in a grid view, you might want to prompt for user confirmation before executing an action when multiple records can be selected. In a read-only view, you might skip the confirmation step to expedite the process.
Each action view is equipped with the following settings:
Label # A user-friendly name for the action view. This name is displayed to users as the action&rsquo;s identifier. Uniqueness is not necessary.
Name # An exclusive name for the action view. It should not include spaces or special characters.
Default view # Indicates whether this is the default view for the action. Default views are employed, for example, in grid views when you choose to display all available actions. In such cases, only the default view for each action is listed, as showing all views for each action within the same context would be impractical.
Managed # When this flag is set, new parameters are automatically incorporated into the view, and the parameter order aligns with that of the action.
Confirmation prompt # When enabled, this prompts the user to confirm their intention before executing the action. This is particularly relevant when no parameters are defined in the view.
Display success message # This flag, enabled by default, triggers the display of a success message following the successful execution of the action. Disabling it omits this message.
Style # This pertains to the visual style of the action when presented as a button in the UI.
Icon # This specifies the icon to represent the action when displayed in the UI.
Confirmation button # A user-friendly label for the action confirmation button. This label replaces the default Action label.
Cancel button # A user-friendly label for the cancel button. This label replaces the default Cancel.
Help message # A human-readable explanation of the action&rsquo;s behavior. This message is displayed at the top of the action modal.
Parameters # This encompasses the list of parameters shown in the view. You can sort, remove unnecessary ones, and more.
In this context, you have the flexibility to override default display options. For more details, consult the documentation on General Display Options.
Events # Before show # The before show script is evaluated prior to action execution. In the UI, it is triggered before presenting the user with the action popup. This enables adjustments to parameters based on specific conditions.
When multiple records are selected, the script is evaluated only once. You can determine the records affected by using the query parameter in the script.
Parameters # Name Type Description record sys.data.Record The record on which the action will be executed. This variable is exclusively accessible if the action type is set to &quot;One record&quot; or if you are applying the action to multiple records. query sys.data.Query A query object containing filters to locate all records affected by this action. This is applicable only for the &quot;Many records&quot; action type. action sys.data.Action This provides access to the parameters of the action. Changes made here will be reflected in the UI when the action is executed from the user interface. Samples # // sets the default value as the email of the current user action.field('sendTo').val(sys.context.getCurrentUser().email()); On action change # The On Action Change script is executed whenever a view parameter changes its value. This enables making adjustments to the parameters based on specific conditions.
You can identify the parameter that triggered the event by utilizing the modifiedParameter parameter within the script.
Parameters # Name Type Description record sys.data.Record The record on which the action will be executed. This variable is exclusively accessible if the action type is set to &quot;One record&quot; or if you are applying the action to multiple records. action sys.data.Action This provides access to the parameters of the action. Changes made here will be reflected in the UI when the action is executed from the user interface. modifiedParameter string A string with the name of the field that fires the event. Samples # // sets the value as the email of the current user only if the field 'sendTo' has changed and is empty if (modifiedParameter == 'sendTo' &amp;&amp; action.field('sendTo').isEmpty()) { action.field('sendTo').val(sys.context.getCurrentUser().email()); } After action executed # The After Action Executed script is executed immediately after the user confirms the execution of the action (or when they trigger the action, if the Ask for confirmation flag is not enabled). It&rsquo;s important to note that this only occurs when the action is executed from the UI using this specific view.
In situations where multiple records are selected, the script is evaluated only once. You can determine the affected records by utilizing the query parameter within the script.
Furthermore, if the action is executed in the background, a job object becomes available, referencing the job responsible for executing the action over the record(s).
Parameters # Name Type Description record sys.data.Record The record on which the action will be executed. This variable is exclusively accessible if the action type is set to &quot;One record&quot; or if you are applying the action to multiple records. query sys.data.Query A query object containing filters to locate all records affected by this action. This is applicable only for the &quot;Many records&quot; action type. action sys.data.Action This provides access to the parameters of the action. Changes made here will be reflected in the UI when the action is executed from the user interface. job sys.jobs.Job This is the job object, exclusively accessible when the action is executed in the background. Keep in mind that the After Action Executed script is run immediately after triggering the action from the UI. At this point, the associated job might still be pending or running. Samples # // after action is executed redirect to read only view of given record var record = sys.data.findOne(query); sys.ui.sendMessage({ scope: 'global', name: 'navigate', view: '590ce2e38a2....', recordId: record.id() }); `}),e.add({id:85,href:"/getting-started/getting/first-steps/event-planner/actioninactions/",title:"Actions in action",description:`In this section, we will explore how the actions implemented in the previous section work. To get started, follow these steps:
👉 Go to the &quot;All Events&quot; view.
👉 Click on a record to view its details. You should see the read-only view.
👉 In the header, you will notice a new button labeled &ldquo;Actions.&rdquo; Click on it to proceed.
👉 Both actions should now be visible, but please note that you will only see them if the status of the event is &ldquo;Active.`,content:`In this section, we will explore how the actions implemented in the previous section work. To get started, follow these steps:
👉 Go to the &quot;All Events&quot; view.
👉 Click on a record to view its details. You should see the read-only view.
👉 In the header, you will notice a new button labeled &ldquo;Actions.&rdquo; Click on it to proceed.
👉 Both actions should now be visible, but please note that you will only see them if the status of the event is &ldquo;Active.&rdquo;
Execute &ldquo;Cancel event&rdquo; action # 👉 Locate and click on the &quot;Cancel Event&quot; action. A confirmation popup will appear. Click on &quot;Cancel Event&quot; again to confirm the action.
👉 Once the action has completed, the status of the event should be Cancel, and the actions should no longer be visible. It should look something like this:
Execute &ldquo;End event&rdquo; action # 👉 Now let&rsquo;s select another active event to execute the other action. In the read-only view of the other event, click on Actions, and then on End Event.
👉 A confirmation popup will appear, click on End Event. When the action completes, the status of the event should be Done. It should look something like this:
That&rsquo;s it! We have finished this small tutorial.
The purpose of this tutorial was to guide you through your first steps with Slingr. If you&rsquo;re interested, there&rsquo;s an additional section where we make a small improvement to our app.
Feel free to join me in the next section: Small Improvement (Optional).
`}),e.add({id:86,href:"/dev-reference/user-interface/custom-views/",title:"Custom views",description:`Custom views enable you to embed a completely customized HTML page within your app. This proves invaluable when you encounter requirements that aren&rsquo;t supported by the built-in view types.
These custom views will be displayed as iframes within the main content area of your app. This grants you the freedom to integrate any CSS and libraries you require, without needing to be concerned about conflicts with the app&rsquo;s components.
Custom views provide a Javascript API, simplifying interaction with the app.`,content:`Custom views enable you to embed a completely customized HTML page within your app. This proves invaluable when you encounter requirements that aren&rsquo;t supported by the built-in view types.
These custom views will be displayed as iframes within the main content area of your app. This grants you the freedom to integrate any CSS and libraries you require, without needing to be concerned about conflicts with the app&rsquo;s components.
Custom views provide a Javascript API, simplifying interaction with the app. This API facilitates tasks such as fetching information, executing operations, and redirecting to other views.
Please note that to use the Javascript API, it&rsquo;s essential to include jQuery within the view. Achieve this by adding the following line to the HTML header block:
&lt;html&gt; &lt;head&gt; ... &lt;script src=&quot;https://code.jquery.com/jquery-1.11.2.min.js&quot;&gt;&lt;/script&gt; ... &lt;/head&gt; ... If you haven&rsquo;t included jQuery, you will encounter the following console warning in your browser: UI API won't be available because jQuery is not loaded.
You can find different versions of jQuery here.
Label # This represents a human-readable name for the view. You can utilize spaces, special characters, and a combination of upper and lower case letters.
This label will be displayed at the top of the grid view, so make sure you choose a label that users can easily understand.
Name # This serves as the internal name of the view. It should not contain special characters or spaces.
Commonly, you will employ the view&rsquo;s name in scripts and the REST API. Changing it could potentially impact your app, requiring manual adjustments.
Available REST API variables # The following variables are accessible in your custom view&rsquo;s scripts and are necessary for accessing your app&rsquo;s REST API:
sys.ws.TOKEN: Token required for making calls to the REST API. It needs to be included in the token header. sys.ws.API_URL: This is the URL used to access your app&rsquo;s REST API. It&rsquo;s typically something like https://&lt;app&gt;.slingrs.io/&lt;env&gt;/runtime/api. Keep in mind that there might be a slight delay in setting these variables. If your JavaScript executes immediately after the view loads, these variables might initially be null.
In most scenarios, direct use of these variables won&rsquo;t be necessary, as you&rsquo;ll likely employ the provided utilities for interacting with the REST API.
REST API utils # These utilities are designed to facilitate seamless access to your app&rsquo;s REST API from scripts within the custom view. For additional information regarding the app&rsquo;s REST API, refer to this resource.
get(params) # get(urlOrParameters, done, error)** # This function carries out a GET operation on the provided URL or parameters. It automatically handles the necessary headers and conversions.
Parameters # Name Type Required Description urlParameters string or object yes This can be either a simple string containing the URL, e.g., /data/companies, or an object with parameters: {
url: &lsquo;/data/companies&rsquo;,
params: {state: &lsquo;active&rsquo;, _size: 100}
}
It&rsquo;s important to note that the URL represents the path after /api. The base of the URL and headers are calculated automatically, so there&rsquo;s no need to worry about them. Parameters are encoded automatically. done function yes A callback function that is invoked if the request is successful. It will receive a parameter containing the result of the call. Although the REST API returns a JSON string, this method automatically converts it into a JavaScript object. Please refer to the REST API documentation to understand the response. error function no A callback function that is triggered if the request fails. An object containing the error code and error message will be provided as a parameter. Please consult the REST API documentation to comprehend the response. Samples # // logs the label of the app sys.ws.get('/data/companies', function(res) { console.log('Total companies: ' + res.total); res.items.forEach(function(company) { console.log('Company: ' + company.name); }); }, function(errorInfo) { console.log('There was an error getting companies. Code: ' + errorInfo.code + ', message: ' + errorInfo.message); }); post(params) # post(urlOrParameters, data, done, error)** # This function initiates a POST operation to the provided URL. It handles the necessary headers and conversions as required.
Parameters # Name Type Required Description urlParameters string or object yes This can be either a simple string containing the URL, e.g., /data/companies, or an object with parameters: {
url: &lsquo;/data/companies&rsquo;
}
It&rsquo;s important to note that the URL represents the path after /api. The base of the URL and headers are calculated automatically, so there&rsquo;s no need to worry about them. Parameters are encoded automatically. data object no This refers to the content of the request&rsquo;s body. You can provide a JavaScript object as input, and it will be automatically converted to JSON format. done function yes A callback function that is invoked if the request is successful. It will receive a parameter containing the result of the call. Although the REST API returns a JSON string, this method automatically converts it into a JavaScript object. Please refer to the REST API documentation to understand the response. error function no A callback function that is triggered if the request fails. An object containing the error code and error message will be provided as a parameter. Please consult the REST API documentation to comprehend the response. Samples # // logs the label of the app var company = { name: 'test company', state: 'active' }; sys.ws.post('/data/companies', company, function(company) { console.log('Company created successfully: ' + JSON.stringify(company)); }, function(errorInfo) { console.log('Error creating company. Code: ' + errorInfo.code + ', message: ' + errorInfo.message); }); put(params) # put(urlOrParameters, data, done, error)** # This function initiates a PUT operation on the specified URL. It manages the necessary headers and conversions as required.
Parameters # Name Type Required Description urlParameters string or object yes This can be either a simple string containing the URL, e.g., /data/companies, or an object with parameters: {
url:&rsquo;/data/companies/56e81f68e4b0001caf8837a4&rsquo;
}
It&rsquo;s important to note that the URL represents the path after /api. The base of the URL and headers are calculated automatically, so there&rsquo;s no need to worry about them. Parameters are encoded automatically. data object no This refers to the content of the request&rsquo;s body. You can provide a JavaScript object as input, and it will be automatically converted to JSON format. done function yes A callback function that is invoked if the request is successful. It will receive a parameter containing the result of the call. Although the REST API returns a JSON string, this method automatically converts it into a JavaScript object. Please refer to the REST API documentation to understand the response. error function no A callback function that is triggered if the request fails. An object containing the error code and error message will be provided as a parameter. Please consult the REST API documentation to comprehend the response. Samples # // logs the label of the app sys.ws.put('/data/companies/' + company.id, {name: 'new name'}, function(company) { console.log('Company updated successfully: ' + JSON.stringify(company)); }, function(errorInfo) { console.log('Error updating company. Code: ' + errorInfo.code + ', message: ' + errorInfo.message); }); delete(params) # delete(urlOrParameters, done, error)** # Performs a DELETE operation to the given URL, sending the correct headers and doing the needed conversions.
Parameters # Name Type Required Description urlParameters string or object yes This can be either a simple string containing the URL, e.g., /data/companies, or an object with parameters: {
url: &lsquo;/data/companies/56e81f68e4b0001caf8837a4&rsquo;,
params: {async: true}
}
It&rsquo;s important to note that the URL represents the path after /api. The base of the URL and headers are calculated automatically, so there&rsquo;s no need to worry about them. Parameters are encoded automatically. done function yes A callback function that is invoked if the request is successful. It will receive a parameter containing the result of the call. Although the REST API returns a JSON string, this method automatically converts it into a JavaScript object. Please refer to the REST API documentation to understand the response. error function no A callback function that is triggered if the request fails. An object containing the error code and error message will be provided as a parameter. Please consult the REST API documentation to comprehend the response. Samples # // logs the label of the app sys.ws.del('/data/companies/' + company.id, function(company) { console.log('Company deleted successfully: ' + JSON.stringify(company)); }, function(errorInfo) { console.log('Error delting company. Code: ' + errorInfo.code + ', message: ' + errorInfo.message); }); createRecord(params) # createRecord(entityName, data, done, error)** # This function utilizes the previously described POST method to create a new record for a specified entity. Once the record is created, it reports back to the platform.
Parameters # Name Type Required Description entityName string yes This indicates the name of the entity in which the new record will be created. You can obtain this information from the context sent to the custom view after it has been fully rendered. data object no This refers to the content of the request&rsquo;s body. You can provide a JavaScript object as input, and it will be automatically converted to JSON format. done function yes A callback function that is invoked if the request is successful. It will receive a parameter containing the result of the call. Although the REST API returns a JSON string, this method automatically converts it into a JavaScript object. Please refer to the REST API documentation to understand the response. error function no A callback function that is triggered if the request fails. An object containing the error code and error message will be provided as a parameter. Please consult the REST API documentation to comprehend the response. Samples # // creates a new record in an entity Contacts var newRecord = { company: 'test company name', firstName: 'test first name', lastName: 'test last name', email: 'test email', } sys.ui.createRecord(&quot;contacts&quot;, newRecord, function (contact) { console.log('Contact created successfully: ' + JSON.stringify(contact)); }, function (errorInfo) { console.log('Error creating contact. Code: ' + errorInfo.code + ', message: ' + errorInfo.message); }) updateRecord(params) # updateRecord(entityName, data, done, error)** # This function employs the previously described PUT method to update a specific record within a designated entity. After the update is performed, it reports back to the platform.
Parameters # Name Type Required Description entityName string yes This indicates the name of the entity in which the new record will be created. You can obtain this information from the context sent to the custom view after it has been fully rendered. recordId string yes This refers to the ID of the record that will undergo an update. You can obtain this ID from the context sent to the custom view after it has been fully rendered. data object no This refers to the content of the request&rsquo;s body. You can provide a JavaScript object as input, and it will be automatically converted to JSON format. done function yes A callback function that is invoked if the request is successful. It will receive a parameter containing the result of the call. Although the REST API returns a JSON string, this method automatically converts it into a JavaScript object. Please refer to the REST API documentation to understand the response. error function no A callback function that is triggered if the request fails. An object containing the error code and error message will be provided as a parameter. Please consult the REST API documentation to comprehend the response. Samples # // updates a record of the entity Contacts var newValues = { company: 'test company name', firstName: 'test first name', lastName: 'test last name', email: 'test email', } sys.ui.updateRecord(&quot;contacts&quot;, &quot;5dbb1d5836e3bd27bd640ff3&quot; ,newValues, function (contact) { console.log('Contact updated successfully: ' + JSON.stringify(contact)); }, function (errorInfo) { console.log('Error updating contact. Code: ' + errorInfo.code + ', message: ' + errorInfo.message); }) goToView(params) # goToView(viewIdOrName, params)** # Allows to navigate to an app specific view.
Parameters # Name Type Required Description viewIdOrName string yes The view ID or name to navigate to. params object no Certain views may accept supplementary parameters. For instance, grid and workflow views may include a recordId parameter to navigate to the read-only view of a specific record. Samples # // goes to a grid view sys.ui.goToView('companies'); // goes to the read only view of a record in a grid view sys.ui.goToView('companies', {recordId: '5506fc43c2eee3b1a7026948'}); executeAction(params) # executeAction(entityNameOrId, actionNameOrId, recordIds, successCallback, errorCallback, canceledCallback)** # Allows to execute a certain action from a custom view
Parameters # Name Type Required Description entityNameOrId string yes The name or ID of the entity. actionNameOrId string yes The name or ID of the action to execute. recordIds object[] no These are the IDs of the records on which the action will be executed. It can be a single string containing an ID or an array of strings representing multiple IDs. successCallback function yes This script runs after the action has been successfully executed. It receives the result of the action as a parameter. errorCallback function yes It runs when the action fails. canceledCallback function yes It runs when the action is canceled. Samples # // execute an action for employees sys.ui.executeAction('employees', 'timeTrack', &quot;xxxxx&quot;, function(result) { console.info(&quot;&gt; success&quot;, result); }, function(result) { console.info(&quot;&gt; error&quot;, result); }, function(result) { console.info(&quot;&gt; canceled&quot;, result); }); // execute a global action sys.ui.executeAction('sampleEntity', 'globalAction', null, function(result) { console.info(&quot;&gt; success&quot;, result); }, function(result) { console.info(&quot;&gt; error&quot;, result); }, function(result) { console.info(&quot;&gt; canceled&quot;, result); }); Context API # Using these utilities, you gain access to the parameters sent by the service:
sys.ui.sendMessage({ name: 'navigate', view: 'customViewId', parameters: { ... } }) Within the custom view code, you have access to parameters through the following utilities: sys.context.PARAMS: This represents a key-value object map of parameters available in the custom view context. sys.context.getParam(paramName): This utility method allows you to retrieve the value of a specific parameter. Files # These files collectively constitute the custom view. They encompass HTML, CSS, and JavaScript files.
However, there is a particular file that is automatically generated: mainFile.html. This file is an HTML page and serves as the central point that loads when a user accesses the custom view. It cannot be deleted or renamed. You have the freedom to integrate any necessary HTML tags, CSS, or JavaScript code into this page, as well as include other files, as elaborated below.
The content of this page is displayed within an iframe within the main content area of your application. This design ensures that there are no conflicts with the remainder of the application.
Apart from the main file, you have the option to craft additional files to segment the custom view into more manageable sections, thus maintaining organization. These files can be JavaScript, CSS, or HTML files. Subsequently, you can integrate these files into the main custom view file. For instance, assume you possess the following files:
styles.css utils.js templates.html You can amalgamate them within the main file in this manner:
&lt;html&gt; &lt;head&gt; ... \${styles.css} \${utils.js} &lt;/head&gt; &lt;body&gt; ... \${templates.html} &lt;/body&gt; &lt;/html&gt; CSS files will be encapsulated within a &lt;style&gt; tag, while JavaScript files will be enclosed within the &lt;script&gt; tag. Consequently, there&rsquo;s no need to include these tags within the files themselves. HTML contents are inserted exactly as they appear in the file.
Permissions # Permissions allow you to specify which groups have access to a particular view.
While permissions for a view can be managed directly within the view definition, it&rsquo;s essentially another approach to configuring permissions at the group level. This approach simplifies the process of setting permissions on the view for all existing groups.
For more comprehensive details on permissions, please consult the Groups documentation.
In a ReadOnly View # You have the option to designate a custom view as a readOnly CRUD action view within a Grid View. If chosen, a context containing pertinent information will be conveyed as JSON through a message event. This event can be monitored by adding an event listener within the main file of the custom view. Consequently, the custom view can access the provided information for display. Additionally, selecting the Refresh action button will trigger a message event to notify the custom view about the refresh action. This empowers the custom view to react to the event and execute necessary actions. This refresh event will also be triggered after executing other custom actions.
Sample of a listener in the custom view
// Logs the context and the event type window.addEventListener('message', function (event) { if(event.data.eventType){ var eventType = event.data.eventType; sys.logs.info(&quot;EVENT: &quot; + JSON.stringify(eventType)); }else if(event.data.context){ var context = event.data.context; sys.logs.info(&quot;CONTEXT: &quot; + JSON.stringify(context)); } }); As a create type view # You can designate a custom view as a create CRUD action view within a Grid View. If you choose a Custom View for this purpose, a context containing relevant information will be conveyed as JSON through a message event. You can monitor and respond to this event by adding an event listener in the main file of the custom view. Consequently, the custom view can access the provided information for display. Furthermore, selecting the Create action button will also trigger a message event to notify the custom view about the button press. This enables the custom view to react to the event and carry out necessary actions. This add event will also be triggered after executing other custom actions.
Sample of a listener set in a custom view in order to obtain some context information
window.addEventListener('message', function (event) { //We wait for a message from the platform to let us know the Create Button has been pressed if (event.data.eventType) { if (event.data.eventType === 'add') { //This is a method we should implement to save the new data and then comunicate it back to the platform self.createRecord(); } // Logs the context. This happened once the custom view is fully rendered }else if(event.data.context){ var context = event.data.context; var entity = event.data.context.entity; sys.logs.info(&quot;CONTEXT: &quot; + JSON.stringify(context)); } }); Once you&rsquo;re listening to the add event, it&rsquo;s time to implement the required functionality. Custom views provide a utility method for creating new records and subsequently notifying the platform. For further details, refer to the Custom View section.
Sample of an implementation of a createRecord() method
self.createRecord = function () { console.log('creating new record from REST API'); //Custom view method to create a record and inform back to the platform sys.ui.createRecord(entity.name, newRecord, function (recordCreated) { console.log(&quot;ON SUCCESS RECORD: &quot; + JSON.stringify(recordCreated)); }, function (error) { console.log(&quot;ON ERROR :&quot; + JSON.stringify(error)); }) }; As an Edit type view # You have the option to designate a custom view as an edit CRUD action view within a Grid View. If you choose a Custom View for this purpose, a context containing pertinent information will be conveyed as JSON through a message event. You can listen to and handle this event by adding an event listener within the main file of the custom view. Consequently, the custom view can access the provided information for display. Furthermore, selecting the Save action button will also trigger a message event to notify the custom view about the button press. This enables the custom view to respond to the event and execute necessary actions. This edit event will also be triggered after executing other custom actions.
Sample of a listener set in a custom view in order to obtain some context information
window.addEventListener('message', function (event) { //We wait for a message from the platform to let us know the Save Button has been pressed if (event.data.eventType) { if (event.data.eventType === 'edit') { //This is a method we should implement to save the new data and then comunicate it back to the platform self.updateRecord(); } // Logs the context. This happened once the custom view is fully rendered }else if(event.data.context){ var context = event.data.context; var entity = event.data.context.entity; var contextRecord = event.data.context.record; sys.logs.info(&quot;CONTEXT: &quot; + JSON.stringify(context)); } }); Once you&rsquo;re listening to the edit event, it&rsquo;s time to implement the required functionality. Custom views offer a utility method for updating records and subsequently notifying the platform. For further details, refer to the Custom View section.
Sample of an implementation of a updateRecord() method
self.createRecord = function () { console.log('creating new record from REST API'); //Custom view method to create a record and inform back to the platform sys.ui.createRecord(entity.name, newRecord, function (recordCreated) { console.log(&quot;ON SUCCESS RECORD: &quot; + JSON.stringify(recordCreated)); }, function (error) { console.log(&quot;ON ERROR :&quot; + JSON.stringify(error)); }) }; Resize container # To ensure that the custom view container doesn&rsquo;t exceed the size of the containing view and display incorrectly, you can adjust its size accordingly. This can be achieved by utilizing the sys.ui.resizeContainer method as outlined below.
Firstly, you need to assign an ID to the &lt;div&gt; element that encompasses all the HTML code. This ID will be used to determine the height of the custom view container. Here&rsquo;s an example:
&lt;body&gt; &lt;div id=&quot;allContent&quot; class=&quot;container-fluid&quot;&gt; Finally, the subsequent code should be added to the JavaScript file of the custom view. This code snippet is responsible for extracting the content of the HTML code to determine the appropriate height and then passing it as a parameter to the sys.ui.resizeContainer() method.
$(document).ready(function() { listenToHeightChanges(); }); const listenToHeightChanges = function() { const content = document.getElementById('allContent'); const resizeObserver = new ResizeObserver((entries) =&gt; { for (let entry of entries) { sys.ui.resizeContainer(entry.contentRect.height + 'px'); } }); resizeObserver.observe(content); }; Refresh custom view # sys.ui.refreshCustomView(): This method instructs the UI to initiate a refresh of the custom view. This functionality becomes valuable when any modification within the custom view impacts the actions that should be accessible in the header.
`}),e.add({id:87,href:"/dev-reference/user-interface/dashboard-views/",title:"Dashboard views",description:`Dashboard views allow you to host various widget views, organizing them in rows and columns similar to a grid system. These widgets can appear in multiple dashboards. The available widgets include:
Indicator widget. Table widget. Line chart widget. Bar chart widget. Pie chart widget. Custom widget. Label # This is a human-readable name of the view. You can use spaces, special characters, and mix upper case and lower case letters. This label will be displayed at the top of the dashboard view, so make sure you use something users will understand.`,content:`Dashboard views allow you to host various widget views, organizing them in rows and columns similar to a grid system. These widgets can appear in multiple dashboards. The available widgets include:
Indicator widget. Table widget. Line chart widget. Bar chart widget. Pie chart widget. Custom widget. Label # This is a human-readable name of the view. You can use spaces, special characters, and mix upper case and lower case letters. This label will be displayed at the top of the dashboard view, so make sure you use something users will understand.
Name # This is the internal name of the view. It cannot contain special characters or spaces. Usually, you will use the name of the view in scripts and the REST API. Changing it might affect your app, and you may need to make manual adjustments.
Description # This is a human-readable description that explains the purpose of the dashboard.
On event # This event is triggered after refreshing the dashboard. It receives information about where the refresh was initiated, whether it&rsquo;s from a user clicking the refresh button or via sending UI messages.
Parameters # Name Type Description event object This event object contains information about where the refresh was triggered. It can occur when a user clicks the refresh button in the UI or when UI messages are sent from the other side. Samples # // register external messages sys.logs.info(JSON.stringify(event)); if(event.sourceType == 'UI_MESSAGE') { // register action } Refresh using UI Message # You can refresh the dashboard view by sending UI messages. This action will refresh all its containers.
Example # In the following example, you can refresh the dashboard view called salesDashboard:
sys.ui.sendMessage({ scope: 'view', name: 'refresh', views: ['salesDashboard'] }); If you want to refresh just one container, you can send the parameter widgetContainers as an array of container names to be updated.
sys.ui.sendMessage({ scope: 'view', name: 'refresh', views: ['salesDashboard'], widgetContainers: ['sales', 'salesPerDepartment'] }); Layouts # Layouts are designed to contain widgets within rows and columns, following a grid system. You can build layouts of various shapes and sizes, utilizing a twelve-column system similar to Bootstrap.
A dashboard view contains a root layout in which you can add rows, and these rows serve as wrappers for columns or widgets. Columns, in turn, can wrap new rows or contain widgets. This hierarchical structure allows you to create a tree-like arrangement to organize your widgets effectively.
Each row and column has the following properties:
Label # This is a human-readable name for the node. You can use spaces, special characters, and a mix of uppercase and lowercase letters.
Name # This is the internal name of the view. It cannot contain special characters or spaces.
Widget # You can select one of the created widget views to be placed within the row or column.
Type # This indicates whether it is a column or a row.
Column size # For columns, users can select their size within the twelve-column system, similar to Bootstrap&rsquo;s grid system. Sizes can be designated as large, medium, or small, depending on the device size.
On event # This event is triggered after refreshing the specified widget. It receives information about where the refresh was initiated, which could be triggered by the user clicking the refresh button or sending UI messages.
Parameters # Name Type Description event object This event object contains information about where was the refresh fired, it can be when user click the refresh button of the UI or when send UI messages from other side. Samples # // register external messages sys.logs.info(JSON.stringify(event)); if(event.sourceType == 'UI_MESSAGE') { // register action } Refresh using UI Message # You can refresh each dashboard container by sending UI messages. The container will respond to this message and refresh its content using the default settings of its widget. Additionally, you can enhance this functionality by including additional information, such as filters, in the message. Please refer to the allowed UI message configurations in each type of widget for more details.
In the following example, you can see how to refresh the container named salesProgress within the dashboard named salesDashboard:
sys.ui.sendMessage({ scope: 'view', name: 'refresh', views: ['salesDashboard'], widgetContainers: ['salesProgress'] }); Permissions # Permissions determine which groups can access this view.
While permissions for a view can be configured directly within the view definition, it mirrors the capabilities available in group configuration. The objective is to facilitate easy permission configuration for all existing groups.
Upon the creation of a new view, if a group holds permissions for the entity associated with that view, the view will inherently be granted permission for use by that group.
For a comprehensive understanding of permissions, refer to the Groups documentation.
`}),e.add({id:88,href:"/dev-reference/user-interface/ui-plugins/",title:"UI Plugins",description:`Plugins are components that operate on the client side and enable the expansion of the platform&rsquo;s UI features.
A common scenario for plugins is facilitating interaction with external applications on the client side. For instance, a Twilio UI plugin could display incoming calls and provide users the ability to answer them.
A comprehensive list of official plugins can be accessed here.
Configuration # While plugins may have specific settings, they all share certain common settings.`,content:`Plugins are components that operate on the client side and enable the expansion of the platform&rsquo;s UI features.
A common scenario for plugins is facilitating interaction with external applications on the client side. For instance, a Twilio UI plugin could display incoming calls and provide users the ability to answer them.
A comprehensive list of official plugins can be accessed here.
Configuration # While plugins may have specific settings, they all share certain common settings. Refer to the respective plugin&rsquo;s documentation for its unique settings.
Here, we will outline the general settings.
Label # This label serves as the human-readable name of the plugin. Its utilization isn&rsquo;t involved in app execution.
Name # The internal name of the plugin, used when dispatching messages to the plugin from the backend through the Javascript API.
The name must comprise only letters and numbers, excluding special characters or spaces.
Sending messages to plugins # You can send messages to UI plugins from a backend script using the Javascript API. For instance, to communicate with the sample plugin for the event1 event, you would proceed as follows: Feel free to integrate this enhanced version into your documentation.
sys.ui.sendMessage({ scope: 'plugin:sample', name: 'event1', companyId: record.id(), callbacks: { callback1: function(originalMessage, callbackData) { sys.logs.debug(&quot;Here is the original message for callback 1&quot;); sys.logs.debug(JSON.stringify(originalMessage)); sys.logs.debug(&quot;Here is the callback data for callback 1&quot;); sys.logs.debug(JSON.stringify(callbackData)); }, callback2: function(originalMessage, callbackData) { //do something } } }); Events # Plugins have the capability to transmit events to the backend. These events can be captured by listeners with the type set to UI Plugin, and the corresponding event should be selected.
For more details, refer to the UI plugin listeners documentation.
`}),e.add({id:89,href:"/dev-reference/user-interface/line-chart-widget/",title:"Line chart widget",description:`A line chart is an effective way to visualize data points along a line. It is commonly used to display trend data or compare two data sets. There are three types of line charts:
Category: The horizontal axis represents labels (categories) for each value. This chart type is defined using data from a single entity. Linear: Numerical data is plotted for each point. The scatter chart type automatically configures a line chart to use one of these scales for the x-axis.`,content:`A line chart is an effective way to visualize data points along a line. It is commonly used to display trend data or compare two data sets. There are three types of line charts:
Category: The horizontal axis represents labels (categories) for each value. This chart type is defined using data from a single entity. Linear: Numerical data is plotted for each point. The scatter chart type automatically configures a line chart to use one of these scales for the x-axis. Linear interpolation is used to position a value along the axis. Time: Points are defined with date-number pairs. The time scale is used for displaying dates. The ticks are automatically determined based on the scale&rsquo;s size. Category line chart # The horizontal axis labels are derived from the values&rsquo; categories. This type of chart is built using data from a single entity.
Entity # This refers to the entity that the view is associated with. Only records from this entity will be displayed in the line chart widget.
Label # A human-readable name for the view. Special characters, spaces, and a mix of uppercase and lowercase letters can be used.
This label is displayed at the top of the widget view. Make sure it&rsquo;s user-friendly.
Name # The internal name of the view. It should not include special characters or spaces. You often use this view&rsquo;s name in scripts and the REST API. Changing it might impact your app, necessitating manual adjustments.
Description # A human-readable description of the widget. Special characters, spaces, and a mix of uppercase and lowercase letters can be used. Internationalization is possible.
This description appears at the top of the added widget on your dashboard.
Allow refresh # This option controls whether to show or hide the refresh button. Enabling this allows users to update the widget&rsquo;s information. It&rsquo;s enabled by default.
List settings # Dataset # These settings define how the listing behaves.
Sort Field: The default sorting field for the listing. If allowed, users might change the default sorting by column.
Sort Type: The sorting direction. If allowed, users might change the default sorting by column.
Filter Type: Can be an expression or a script. For expression selection, set record filters. For the script selection, the script should be returned.
Record Filters: Defines which records are listed. Only records matching the given expression will appear in the table widget view.
Script: Returns a query parameter or queryMap. The query map object is used to filter records. See the Query Language documentation for query map usage.
Size: The maximum number of records to fetch when the view loads or when clicking &ldquo;More&rdquo; to fetch additional records.
Horizontal axis settings # View type # Specifies the field type used for generating the horizontal axis values. It can be an entity field or a calculated field.
Entity field # Allows selection of an existing entity field. The value is stored as metadata reference, updating accordingly with changes.
Calculated field # Generates field values by script for the horizontal axis.
Grid lines # When set to false, grid lines for this axis are hidden.
Vertical axis settings # Label # A human-readable name displayed on the vertical axis. Special characters, spaces, and a mix of uppercase and lowercase letters can be used.
Ticks suggested min / max # The suggestedMax and suggestedMin settings affect the data values used for axis scaling. They extend the axis range while maintaining auto-fit behavior.
Grid lines # When set to false, grid lines for this axis are hidden.
Series # You can add series based on entity fields or calculated series.
Entity field # Allows selection of an existing entity field. The value is stored as metadata reference, updating accordingly with changes. The default value is effective when creating new records, not when editing existing ones.
Calculated field # A field&rsquo;s value generated by script for the vertical axis.
Line styling settings # Settings Mode: Can be simple or advanced. In simple mode, only the line color needs setting; other settings are calculated or set by default. Advanced mode requires developers to define each value.
Color: Specifies the line color using a hexadecimal code.
Line Tension: Bezier curve tension of the line. Set to 0 to draw straight lines. Default value is 0.4.
Background Color: Fill color for the line. Use a hexadecimal code.
Border Width: Width of the line (in pixels).
Border Dash: Length and spacing of dashes.
Stepped Line: Supported values for stepped lines: None, Before, Middle, After.
Point styling settings # Settings Mode: Can be simple or advanced. In simple mode, only the background color needs setting; other settings are calculated or set by default. Advanced mode requires developers to define each value.
Background Color: Fill color for points. Use a hexadecimal code.
Style: Point style, options include circle, cross, crossRot, dash, line, rect, rectRounded, rectRot, star, triangle.
Radius: Radius of the point shape.
Hover Background Color: Point background color on hover.
Border Width: Width of the point border (in pixels).
Border Color: Border color for points.
UI messages # Widgets can respond to UI messages, such as data refresh or filter application.
Refresh and filter # You can send a message to refresh the widget with default settings. These messages are sent to the dashboard container and propagated to each widget.
Additionally, you can send a filter parameter to apply it to the query used for data retrieval. The query can be a query object or a query map. If using a query object, the filter is applied only when the entity matches that set in the widget. Refer to the Query Language for more information.
To apply filters, set the widgetContainer with a list of objects, each describing the container name and the filter to be applied to each widget. The title can also be sent to update the widget title.
Example # In this example, you can refresh and apply a filter by sending the filter parameter to a specified widget container.
var query = sys.data.createQuery('salesInfoPeriod'); query.field('department').equals('Department A'); sys.ui.sendMessage({ scope: 'view', name: 'refresh', views: ['salesDashboard'], widgetContainers: [ { name: 'salesPerDepartment', filter: query } ] }); Example # Use case # A line chart is designed by connecting a series of data points with a solid line. Examples of data types suitable for representation in a line chart include annual sales rates and monthly rainfall. This type of chart allows trends in the data to be clearly observed over a continuous period.
Precondition # To set up information in a line chart, you need to have an entity. You can utilize a calculated entity to store aggregated information.
For instance, consider the entity salesInLastYear. It possesses a year-month field named period and an integer field named totalSales. This example assumes that the entity is calculated and is updated on a monthly basis.
Creating a Line Chart # The following steps illustrate how to create a line chart:
Step 1: Within the root layout of the designated dashboard, navigate to Assign Widget. Step 2: You can assign an existing widget or create a new one. In this scenario, we&rsquo;re creating a new widget. Step 3: Provide a label and name for the new widget. Select Line Chart as the widget type and choose subtype category. Additionally, specify the salesInLastYear entity mentioned in the preconditions. Save the changes to proceed to widget configurations. Step 4: In the Dataset configuration, arrange the sorting information. In this example, the sorting should be based on the period field. This is where you can also filter information from the salesInLastYear entity. Step 5: Configure the continuous variable for the Horizontal Axis. In our case, this would be the period field. You can customize display options for the selected field and opt to show or hide grid lines as needed. Refer to the documentation for further details. Step 6: Customize settings for the Vertical Axis Settings, allowing adjustments to the vertical axis appearance. More information can be found in the documentation. Step 7: Under the Series node, you can add fields (series) representing measurement information. For instance, you can add a new series using the button in the secondary menu. Step 8: In the Model Settings, add the field representing the measure. In our example, this would be the totalSales field. Step 9: For the added series, you have the ability to customize colors for lines and points. Additionally, advanced options are available for more nuanced customization. These steps guide you through the process of creating a line chart.
`}),e.add({id:90,href:"/dev-reference/user-interface/linear-chart-widget/",title:"Linear line chart widget",description:`A line chart is a method of visualizing data points on a line, commonly used to illustrate trends or compare two data sets.
There are three types of line charts:
Category: The horizontal axis is defined using labels (categories) for each value. This type of chart is created from a single entity. Linear: Numerical data is plotted for each point. The scatter chart type automatically configures a line chart to use one of these scales for the x-axis.`,content:`A line chart is a method of visualizing data points on a line, commonly used to illustrate trends or compare two data sets.
There are three types of line charts:
Category: The horizontal axis is defined using labels (categories) for each value. This type of chart is created from a single entity. Linear: Numerical data is plotted for each point. The scatter chart type automatically configures a line chart to use one of these scales for the x-axis. Linear interpolation is employed to determine the value&rsquo;s position on the axis. Time: A point is defined by a date-number pair. The time scale displays date types, and its ticks are calculated based on the scale&rsquo;s size. Linear chart # Numerical data is plotted for each point. The scatter chart type automatically configures a line chart to use one of these scales for the x-axis. Linear interpolation is employed to determine the value&rsquo;s position on the axis.
This chart type is defined using a list of series. Each series is constructed from an independent data source, specifying numerical points for both the horizontal and vertical axes.
View settings # Label # A human-readable name for the view. You can use spaces, special characters, and a mix of upper and lower case letters. This label will be displayed at the top of the widget view, ensuring user comprehension.
Name # The internal name of the view. It cannot contain special characters or spaces. This name is commonly used in scripts and the REST API. Changing it might impact your app, necessitating manual adjustments.
Description # A human-readable description of the widget. You can use spaces, special characters, and a mix of upper and lower case letters. This description will be shown at the top of the added widget on your dashboard.
Allow refresh # This setting toggles the display of the refresh button. It allows updating the widget&rsquo;s information and is enabled by default.
Horizontal axis settings # Label # A human-readable name for the view&rsquo;s horizontal axis. You can use spaces, special characters, and a mix of upper and lower case letters. This label will be displayed below the horizontal axis.
Grid lines # If disabled, grid lines for this axis will not be displayed.
Vertical axis settings # Label # A human-readable name for the view&rsquo;s vertical axis. You can use spaces, special characters, and a mix of upper and lower case letters. This label will be displayed beside the vertical axis.
Ticks suggested min / max # These settings influence the data values used for scaling the axis. They are helpful for extending the axis range while preserving the auto-fit behavior.
Grid lines # If disabled, grid lines for this axis will not be displayed.
Series # Dataset # These settings dictate how the data source collects information.
Entity: Specifies the entity to which the view refers. Only records from this entity are included to define the horizontal and vertical axes.
Filter Type: Can be expression or script. Selecting &ldquo;expression&rdquo; requires setting record filters, while choosing other options requires scripting.
Filters: Defines the records to be included. Only records meeting the provided expression will be part of the table widget view.
Script: Returns a query parameter or queryMap, with the query map object used for filtering records. Refer to the Query language documentation for the query map version.
Size: Sets the maximum number of records to fetch during view loading and when clicking &ldquo;More&rdquo; to fetch additional records.
Sort Field: The default sorting field for the listing. Users might be able to change the default sorting by enabling it in any column.
Sort Type: Specifies the sorting direction. Users might be able to change the default sorting by enabling it in any column.
Point settings # Horizontal value # View Type: Represents the field type used to generate horizontal axis values. It can be an entity field or a calculated field.
Entity Field: Allows selection of an existing entity field. The value is stored as a metadata reference, which is updated similarly to field changes.
Calculated Field: The value is generated by a script for the horizontal axis.
Vertical value # View Type: Represents the field type used to generate vertical axis values. It can be an entity field or a calculated field.
Entity Field: Allows selection of an existing entity field. The value is stored as a metadata reference, which is updated similarly to field changes.
Calculated Field: The value is generated by a script for the vertical axis.
Point styling settings # Settings Mode: Can be simple or advanced. In simple mode, set the line color; other settings are calculated or set by default. In advanced mode, developers define each value.
Background Color: The fill color for points, specified as a hexadecimal color code.
Style: Style of the point, such as circle, cross, dash, line, rect, star, or triangle.
Radius: The radius of the point shape.
Hover Background Color: Point background color when hovered.
Border Width: The width of the point border in pixels.
Border Color: The border color for points.
Line styling settings # Settings Mode: Can be simple or advanced. In simple mode, set the line color; other settings are calculated or set by default. In advanced mode, developers define each value.
Color: The line color, specified as a hexadecimal color code.
Line Tension: Bezier curve tension of the line. Set to 0 for straight lines (default is 0.4).
Background Color: The line fill color, specified as a hexadecimal color code.
Border Width: The line width in pixels.
Border Dash: Length and spacing of dashes.
Stepped Line: Supported values include None, Before, Middle, and After.
Example # Use case # This type of chart is ideal for connecting a series of data points with a solid line. For instance, it&rsquo;s helpful to visualize the resistance of different materials at varying temperatures.
Precondition # Entities must be in place to define information for each material. Calculated entities can be used to aggregate information. For example, the materialA entity has integer field types temperature and resistance, similar to an entity for materialB.
Creating a line chart # Here&rsquo;s how to create a line chart:
Access the root layout of your dashboard and navigate to &ldquo;Assign Widget.&rdquo; Choose an existing widget or create a new one, selecting the widget type as &ldquo;Line Chart&rdquo; with subtype &ldquo;Linear.&rdquo; Configure the label, name, and other settings before moving to widget configurations. Customize axis settings in the &ldquo;Horizontal and Vertical Axis Settings&rdquo; section. Add series for each material, defining labels, dataset settings, and point styling settings. Configure the line styling settings or use default values. Repeat the process to add more series, each with unique dataset settings. Save your changes. UI message # Widgets can respond to UI messages, especially for refreshing data or applying filters.
Refresh and filter # Sending a refresh message updates the widget based on its default settings. You can also send a filter parameter to apply specific filters to the query fetching data. The filter can be a query object or query map.
To apply filters, set the widgetContainer with objects detailing the container&rsquo;s name and the filter to be applied to each widget. The parameter can also include title to update the widget title.
For charts with multiple series from different entities, the filter parameter should be an array of objects specifying the series name and the associated filter.
Example # To refresh and apply a filter, send the filter parameter to the target widget container. Each series can define its own query independently, applying only to specific entities.
var query = sys.data.createQuery('polycarbonateInfo'); query.field('temperatureC').greaterOrEquals(100); var query2 = sys.data.createQuery('nylonInfo'); query2.field('temperatureC').greaterOrEquals(50); sys.ui.sendMessage({ scope: 'view', name: 'refresh', views: ['technicalDashboard'], widgetContainers: [ { name: 'col11', filter: [ { name: 'polycarbonate', filter: query }, { name: 'nylon6', filter: query2 } ] } ] }); `}),e.add({id:91,href:"/dev-reference/user-interface/time-line-chart-widget/",title:"Time line chart widget",description:`A line chart presents data points on a continuous line, often used to display trends or compare two datasets.
There are three types of line charts:
Category: The horizontal axis features labels (categories) for each value. This chart type is defined from a single entity. Linear: Numeric data is plotted for each point. The scatter chart type automatically configures a line chart to use one of these scales for the x-axis.`,content:`A line chart presents data points on a continuous line, often used to display trends or compare two datasets.
There are three types of line charts:
Category: The horizontal axis features labels (categories) for each value. This chart type is defined from a single entity. Linear: Numeric data is plotted for each point. The scatter chart type automatically configures a line chart to use one of these scales for the x-axis. Linear interpolation determines the positioning of values on the axis. Time: A point is defined using a date-number pair. The time scale displays date types. It dynamically calculates the most suitable time unit based on the axis scale. Time chart # A time chart is defined using date-number pairs. The time scale is utilized for displaying date types. The chart automatically determines the most suitable time unit for creating ticks based on the scale size.
This type of chart is designed for a list of series. Each series is based on an independent data source, with date-number points specified for the axis.
Label # This is a user-readable name for the view. You can utilize spaces, special characters, and a mix of uppercase and lowercase letters.
This label will appear at the top of the widget view, so ensure it is easily understandable to users.
Name # This is the internal name of the view. It cannot contain special characters or spaces.
You&rsquo;ll often use the view&rsquo;s name in scripts and the REST API. Changing it may impact your app, requiring manual adjustments.
Description # This is a user-readable description for the widget. You can include spaces, special characters, and a mix of uppercase and lowercase letters. Internationalization is supported.
This description will be displayed at the top of the added widget on your dashboard.
Auto refresh # Toggle this option to show or hide the refresh button. Enabling it allows updating the widget&rsquo;s information. It&rsquo;s true by default.
Horizontal axis settings # Label # This is a user-readable name for the view. You can use spaces, special characters, and a mix of uppercase and lowercase letters.
This label will appear below the horizontal axis.
Grid lines # Toggle grid line visibility for this axis.
Vertical axis settings # Label # This is a user-readable name for the view. You can use spaces, special characters, and a mix of uppercase and lowercase letters.
This label will appear next to the vertical axis.
Ticks suggested Min/Max # The suggestedMax and suggestedMin settings alter the data values used to scale the axis. They expand the axis range while maintaining automatic fitting behavior.
Grid lines # Toggle grid line visibility for this axis.
Series # Dataset # These settings determine how the data source collects information.
Entity: This is the entity the view references. Only records from this entity will be listed to define the horizontal and vertical axes.
Filter Type: Can be expression or script. For expressions, set record filters. For scripts, return the query parameter.
Filters: Specify which records will be listed. Only records matching the given expression will appear in the table widget view.
Script: Return query parameter or query map. The query map object is used to filter records. Check the Query Language documentation for query map details.
Size: The maximum number of records fetched when the view is loaded or when clicking &ldquo;More&rdquo; to load more records.
Sort Field: Default sorting field for the listing. Users might change default sorting if enabled in any column.
Sort Type: Sorting direction. Users might change default sorting if enabled in any column.
Point settings # Horizontal value # View Type: Represents the field type used to generate horizontal axis values. It can be an entity field or a calculated field.
Entity Field: Select an existing entity field. The value is metadata referenced and updated with changes.
Calculated Field: Value generated by script for the horizontal axis.
Vertical value # View Type: Represents the field type used to generate vertical axis values. It can be an entity field or a calculated field.
Entity Field: Select an existing entity field. The value is metadata referenced and updated with changes.
Calculated Field: Value generated by script for the vertical axis.
Point styling settings # Settings Mode: Can be simple or advanced. Simple mode requires setting the line color, with other settings calculated or set by default. Advanced mode requires developers to define each value.
Background Color: Fill color for points in hexadecimal.
Style: Point style, such as circle, cross, rect, star, etc.
Radius: Radius of the point shape.
Hover Background Color: Point background color when hovered.
Border Width: Point border width in pixels.
Border Color: Point border color.
Line styling settings # Settings Mode: Can be simple or advanced. Simple mode requires setting the line color, with other settings calculated or set by default. Advanced mode requires developers to define each value.
Color: Line color in hexadecimal.
Line Tension: Bezier curve tension of the line. Set to 0 for straight lines. Default value is 0.4.
Background Color: Line fill color in hexadecimal.
Border Width: Line width in pixels.
Border Dash: Length and spacing of dashes.
Stepped Line: Supported values: None, Before, Middle, After.
Example # Use case # This chart type is ideal for illustrating trends in various diseases over time, such as salmonella and campylobacter occurrences in the past year.
Precondition # You need entities to set up information for each series. Calculated entities are necessary for aggregated information. For instance, entities like salmonella and campylobacter with fields like period (date-year) and quantity (integer).
Creating a line chart # Here are the steps to create a line chart:
Access the root layout of the desired dashboard, either in columns or rows, and go to Assign Widget. Choose an existing widget or create a new one. In this case, let&rsquo;s create a new widget. Enter the label and name for the new widget, set the widget type as Line Chart, and subtype as Linear. Save changes to proceed to widget configurations. Customize the axis settings under Horizontal and Vertical Axis Settings as needed. Add new series for each disease. Define the label to identify the disease and configure the dataset source. For instance, configure the entity source like salmonella, and set filter and order conditions. Define the date-number point. For horizontal value, select period entity field; for vertical value, select quantity entity field. Customize point style. Customize the line style or use default values. Repeat steps 5, 6, and 7 to add a new series for campylobacter. UI Messages # Widgets can react to UI messages, commonly used for refreshing data or applying filters.
Refresh and filter # You can send a message to refresh the widget using its default settings. These messages are sent to the dashboard container and propagated to each widget.
Additionally, you can include a filter parameter to be applied to the data query. This query can be a [query]({{site.baseurl}}/app
-development-js-api-data.html#sys.data.Query) object or a query map. The filter is applied only if the entity matches the widget&rsquo;s entity. Refer to the Query Language for details.
To apply filters, set the widgetContainer with a list of objects, each describing the container&rsquo;s name and the filter to be applied to each widget. You can also send a title to update the widget title.
For line charts with multiple series from different entities, the filter parameter is an array of objects, each describing the series name and the filter to apply exclusively to that series.
Example # In the following example, you refresh and apply a filter by sending the filter parameter to the given widget container. Note how each series defines its own query and applies it to a specific entity.
var query = sys.data.createQuery('chinaInfo'); query.field('date').greaterOrEquals('2020-01-28'); var query2 = sys.data.createQuery('chinaInfo'); query2.field('date').greaterOrEquals('2020-01-28'); sys.ui.sendMessage({ scope: 'view', name: 'refresh', views: ['technicalDashboard'], widgetContainers: [ { name: 'chinaInfo', filter: [ { name: 'cases', filter: query }, { name: 'deaths', filter: query2 } ] } ] }); `}),e.add({id:92,href:"/dev-reference/user-interface/bar-chart-widget/",title:"Bar chart widget",description:`A bar chart provides a method of displaying data values using vertical bars. It is commonly employed to illustrate trend data and compare multiple datasets side by side.
Entity # This refers to the entity that the view will target. Only records from this entity will be listed in the bar chart widget.
Label # This is a human-readable name for the view. You can use spaces, special characters, and a mixture of upper and lower case letters.`,content:`A bar chart provides a method of displaying data values using vertical bars. It is commonly employed to illustrate trend data and compare multiple datasets side by side.
Entity # This refers to the entity that the view will target. Only records from this entity will be listed in the bar chart widget.
Label # This is a human-readable name for the view. You can use spaces, special characters, and a mixture of upper and lower case letters.
This label will appear at the top of the widget view, so ensure you use language that users will understand.
Name # This is the internal name of the view. It cannot contain special characters or spaces.
You will usually utilize the view&rsquo;s name in scripts and the REST API. Changing it may impact your app, necessitating manual adjustments.
Description # This is a human-readable description of the widget. You can use spaces, special characters, and a mixture of upper and lower case letters. Internationalization is possible.
This description will be visible at the top of the added widget in your dashboard.
Allow refresh # This option determines whether the refresh button is displayed or hidden. This button facilitates the update of widget information. It&rsquo;s enabled by default.
Filtering settings # These settings define how the listing behaves.
Sort field # This is the default sorting field for the listing.
Users might be able to alter the default sorting if that functionality is enabled in any of the columns.
Sort type # This indicates the sorting direction.
Users might be able to change the default sorting if that&rsquo;s enabled in any of the columns.
Filter type # It can be either an expression or a script. If &ldquo;expression&rdquo; is selected, record filters should be set. Otherwise, a script should be returned.
Record filters # This defines which records will appear in the list. Only records that match the given expression will be listed in the table widget view.
Script # Returns a query parameter or queryMap. The query map object is used to filter records. For query map version, refer to the Query Language documentation.
Size # The maximum number of records to fetch when the view is initially loaded and when clicking &ldquo;More&rdquo; to fetchadditional records.
Horizontal axis settings # View type # Represents the field type used to generate the horizontal axis values. It can be an entity field or a calculated field.
Entity field # Allows selection of an existing entity field. The value will be stored as a reference to metadata, being updated similarly when changes occur. The default value applies only when creating a new record, thus having no effect on editing an existing record.
Calculated field # Values for this type of field are generated by a script for the horizontal axis.
Horizontal bar # Configuration options for the horizontal bar chart mirror those of the bar chart. However, options specified on the horizontal axis in a bar chart are applied to the vertical axis in a horizontal bar chart.
Grid lines # If set to false, grid lines for this axis are not displayed.
Vertical axis settings # Label # This is a human-readable name displayed on the vertical axis. You can use spaces, special characters, and a mixture of upper and lower case letters.
Ticks suggested Min/Max # The suggestedMax and suggestedMin settings adjust the data values used to scale the axis. These settings extend the axis range while maintaining the auto-fit behavior.
Grid lines # If set to false, grid lines for this axis are not displayed.
Series # You can add series based on an entity field or a calculated series.
Entity field # Allows selection of an existing entity field. The value will be stored as a reference to metadata, being updated similarly when changes occur. The default value applies only when creating a new record, thus having no effect on editing an existing record.
Calculated field # Values for this type of field are generated by a script for the vertical axis.
Bar styling settings # Settings mode # This can be either simple or advanced. In simple mode, only the bar color needs to be set; other settings are calculated or set by default. For advanced mode, developers define each value.
Background color # This sets the line color. It should be a hexadecimal color code.
Border color # The bar&rsquo;s border color. It should be a hexadecimal color code.
Border skipped # Indicates the edge to skip when drawing the bar.
Border width # The bar&rsquo;s border width (in pixels).
Hover background color # The bar&rsquo;s background color when hovered over.
Hover border width # The bar&rsquo;s border width when hovered over (in pixels).
UI messages # Widgets can respond to UI messages. A common use case is when data needs refreshing or filters need applying.
Refresh and filter # You can send a message to refresh the widget using its default settings. These messages are sent to the dashboard container and propagated to each widget.
Additionally, you can send a filter parameter to apply to the query used to retrieve data. This query can be a query object or a query map. When using a query object, the filter is only applied if the entity matches the one set in the widget. For more information, consult the Query Language.
To apply filters, set the widgetContainer with a list of objects. Each object describes the container name and the filter to be applied to each widget. You can also include title to update the widget title.
Example # In the following example, you can refresh and apply a filter by sending the filter parameter to a specific widget container.
var query = sys.data.createQuery('salesInfoPeriod'); query.field('department').equals('Department A'); sys.ui.sendMessage({ scope: 'view', name: 'refresh', views: ['salesDashboard'], widgetContainers: [ { name: 'salesPerDepartment', filter: query } ] }); `}),e.add({id:93,href:"/dev-reference/scripting/",title:"Scripting",description:"",content:""}),e.add({id:94,href:"/dev-reference/user-interface/custom-widget/",title:"Custom widget",description:`This widget allows rendering a custom view inside a dashboard view.
Label # This is a human-readable name for the view. You can use spaces, special characters, and a mixture of upper and lower case letters.
This label will appear at the top of the widget view, so ensure you use language that users will understand.
Name # This is the internal name of the view. It cannot contain special characters or spaces.`,content:`This widget allows rendering a custom view inside a dashboard view.
Label # This is a human-readable name for the view. You can use spaces, special characters, and a mixture of upper and lower case letters.
This label will appear at the top of the widget view, so ensure you use language that users will understand.
Name # This is the internal name of the view. It cannot contain special characters or spaces.
You will usually utilize the view&rsquo;s name in scripts and the REST API. Changing it may impact your app, necessitating manual adjustments.
Description # This is a human-readable description of the widget. You can use spaces, special characters, and a mixture of upper and lower case letters. Internationalization is possible.
This description will be visible at the top of the added widget in your dashboard.
Allow refresh # This option determines whether the refresh button is displayed or hidden. This button facilitates the update of widget information. It&rsquo;s enabled by default.
View settings # Custom view # Render a custom view inside the widget.
Show title # Display the widget&rsquo;s title at the top of the container.
Permissions # Permissions determine which groups can access this view.
While permissions for a view can be configured directly within the view definition, it mirrors the capabilities available in group configuration. The objective is to facilitate easy permission configuration for all existing groups.
Upon the creation of a new view, if a group holds permissions for the entity associated with that view, the view will inherently be granted permission for use by that group.
For a comprehensive understanding of permissions, refer to the Groups documentation.
`}),e.add({id:95,href:"/dev-reference/scripting/overview/",title:"Overview",description:`Javascript API Overview # Scripts provide a highly flexible means of extending and customizing your apps. While a declarative approach is often preferred, we recognize that in certain situations, it may not be feasible to cover all scenarios. Sometimes, writing a few lines of code is more straightforward than navigating a complex and time-consuming user interface to express certain functionalities in a declarative manner.
The primary objective is for you to write scripts solely to define your application&rsquo;s behavior.`,content:`Javascript API Overview # Scripts provide a highly flexible means of extending and customizing your apps. While a declarative approach is often preferred, we recognize that in certain situations, it may not be feasible to cover all scenarios. Sometimes, writing a few lines of code is more straightforward than navigating a complex and time-consuming user interface to express certain functionalities in a declarative manner.
The primary objective is for you to write scripts solely to define your application&rsquo;s behavior. You won&rsquo;t need to write boilerplate or infrastructure code. The platform handles these aspects, enabling you to focus on what truly matters: solving problems and delivering business value.
This document offers general insights into scripts, but you should consult the documentation to understand the various locations where scripts can be written and how they are employed in each scenario.
To simplify script writing, we&rsquo;ve developed a Javascript API that provides services for seamless access to your application&rsquo;s features and data. When writing scripts, you will extensively utilize this API. Make sure to have it accessible; however, you&rsquo;ll also find numerous links from the app builder leading to the documentation.
In addition to the Javascript API, you can also tap into endpoint features and custom libraries.
With the endpoints API, you can invoke functions within endpoints, sending messages to external services as though it were a straightforward method call. More information on using endpoints through scripts can be found here.
Custom libraries empower you to centralize reusable code. This code can be referenced throughout your app. For more details on custom libraries, refer to this link.
Permissions # When executing scripts, permissions are not rigorously enforced. For example, if a user has permissions to execute action A but lacks permissions to access entity E, yet the script within action A involves operations on entity E, this action will still proceed without issue when executed by the user.
This approach is rooted in the idea that developers are in command of scripts. If they grant permission to execute a script, the platform assumes the script&rsquo;s actions align with what the user is allowed to perform.
Exception handling # In case of an error, an exception will be raised. For instance, calling a method in the Javascript API with invalid parameters triggers an exception. Similarly, an exception will be thrown if there is an error executing an endpoint function.
If you do not catch the exception, it will propagate until it&rsquo;s captured by the platform, where it will be logged. You can then view the error in the app monitor. Here, you&rsquo;ll see the point where the exception occurred, a snippet of your code, and a stack trace to help trace the sequence of calls made.
There are instances where you might want to manage the exception to prevent script execution from halting. In such cases, you can employ standard Javascript tools to achieve this:
... try { app.endpoints.slack.sendMessage(params); } catch (e) { sys.logs.warn('There were errors sending message to Slack: '+sys.exceptions.getMessage(e), e); } The Javascript API provides several tools to assist in obtaining error messages and codes from exceptions. This is particularly beneficial because certain exceptions may have varying internal structures. These tools are available within the sys.exceptions package.
Also, remember that you can log exceptions even when using the INFO log level. This can prove to be valuable during the app debugging process. You can find this capability in the logging methods provided by the sys.logs package.
Throwing exceptions # If your code necessitates throwing exceptions, we strongly recommend using the throwException(code, message) method within the sys.exceptions package. When invoking this method, an exception will be thrown while retaining the stack trace.
Using the Javascript throw keyword and subsequently capturing it in your code will lead to the stack trace being lost. Consequently, you won&rsquo;t have visibility into the exact location of the problem.
For this reason, it is highly recommended to consistently use throwException(code, message) instead of just throw. As an example, rather than writing this code:
if (record.field('state').val() != 'new') { throw 'Task must be in state new'; } we recommend to write this code:
if (record.field('state').val() != 'new') { sys.exceptions.throwException('invalidState', 'Task must be in state new'); } Context # When scripts are executed, a context object will be available, offering information about the execution environment of your script. For instance, when working with a library, you might want to differentiate actions between different contexts or ensure that a listener is only executed under specific circumstances.
Comprehensive information about working with context can be found in the sys.context package.
It&rsquo;s crucial to comprehend the scope of the context. This scope initiates when an external event occurs, such as a REST API call or an endpoint event. The scope persists as long as we remain in the same thread. This implies that if a script triggers a background job, that job will execute in a separate scope, distinct from the original context.
For instance, consider an action that, when its script runs, saves a record. If this record belongs to an entity with a listener attached for record changes, and this listener is designated to execute in the background, the listener won&rsquo;t possess knowledge of the original action. This is because the background job runs in a distinct thread and lacks awareness of the action.
However, in the above scenario, if the listener isn&rsquo;t set to execute in the background, it can identify that it was triggered during the execution of the action. This is because it runs immediately in the same thread as the action.
Execution limitations # Scripts running outside of a background job (those executed as part of a REST API call) are subject to a maximum execution time of 30 seconds. Beyond this threshold, an exception will be thrown, halting the script.
For scripts with the potential for extended runtime, it&rsquo;s advisable to execute them in the background to prevent disruptions.
`}),e.add({id:96,href:"/dev-reference/user-interface/indicator-widget/",title:"Indicator widget",description:`An indicator widget is designed to showcase a single crucial value. In this context, the displayed value represents a significant measure of the business&rsquo;s equity, providing a robust and prominent indication.
Label # This is a human-readable name for the view. You can use spaces, special characters, and a mixture of upper and lower case letters.
This label will appear at the top of the widget view, so ensure you use language that users will understand.`,content:`An indicator widget is designed to showcase a single crucial value. In this context, the displayed value represents a significant measure of the business&rsquo;s equity, providing a robust and prominent indication.
Label # This is a human-readable name for the view. You can use spaces, special characters, and a mixture of upper and lower case letters.
This label will appear at the top of the widget view, so ensure you use language that users will understand.
Name # This is the internal name of the view. It cannot contain special characters or spaces.
You will usually utilize the view&rsquo;s name in scripts and the REST API. Changing it may impact your app, necessitating manual adjustments.
Description # This is a human-readable description of the widget. You can use spaces, special characters, and a mixture of upper and lower case letters. Internationalization is possible.
This description will be visible at the top of the added widget in your dashboard.
Allow refresh # This option determines whether the refresh button is displayed or hidden. This button facilitates the update of widget information. It&rsquo;s enabled by default.
Value calculation # Calculated # Define the method for calculating values. There are two approaches to value calculation:
Script: In this scenario, you can supply a script to perform the value calculation. The script operates within the following context:
Returns # string - you should return a string value as result
Samples # // displays a label based on the status of the contract var contract = sys.data.findOne('contracts', {number: '001'}); if (contract.field('status').val() === 'deployed') { return 'Active'; } return 'Inactive'; Aggregate: In this case, you can calculate a value based on an aggregate query involving other records. For instance, consider having an entity named departments and another named employees with a field named salary. To calculate the average salary for each department, you could add a field where the calculation involves aggregating data from the employees entity. This would be done for records with the department field pointing to the corresponding department record, and performing an average calculation on the salary field. This aggregation will be automatically updated whenever a salary changes or an employee is added or removed from the department. When the calculation is Aggregate, you can choose from the following options:
Aggregate entity: This refers to the entity containing the records that need to be aggregated. In the aforementioned example, it would be the employees entity. Expression: This expression defines the criteria that records in the Aggregate entity must meet to be included in the aggregation. In the above example, the expression was based on a field where the Current record was equal to the department field. This ensures that only employees from the current department are included in the aggregation. Aggregate operation: This operation specifies the calculation to be performed. It could be: Count: This counts the number of records matching the expression. Sum: This sums the values in the Aggregate field (see below) for the records matching the expression. Avg: This calculates the average of the values in the Aggregate field (see below) for the records matching the expression. Aggregate field: If the Aggregate operation is anything other than Count, a field must be selected for the operation to be applied. In the example above, the chosen field is salary. Content settings # Icon # Select an icon to be displayed in the indicator.
Color # Choose the indicator color for the icon and value. It should be a hexadecimal color code.
Permissions # Permissions determine which groups can access this view.
While permissions for a view can be configured directly within the view definition, it mirrors the capabilities available in group configuration. The objective is to facilitate easy permission configuration for all existing groups.
Upon the creation of a new view, if a group holds permissions for the entity associated with that view, the view will inherently be granted permission for use by that group.
For a comprehensive understanding of permissions, refer to the Groups documentation.
`}),e.add({id:97,href:"/dev-reference/scripting/namespaces/",title:"Namespaces",description:`Overview # The JavaScript API enables access to various components of your application through scripts. For instance, you can conduct queries, manipulate data, execute actions, or assess the status of background jobs.
The API is structured into packages, each catering to distinct functions such as data manipulation, user management, or background job monitoring.
Subsequent sections delve into comprehensive information about each segment of the JavaScript API.
Namespaces # App Common classes Context Data Legacy Services Events Exceptions Files Internationalization Jobs Logs Storage [UI](/dev-reference/scripting/sys-ui/ Users Utils `,content:`Overview # The JavaScript API enables access to various components of your application through scripts. For instance, you can conduct queries, manipulate data, execute actions, or assess the status of background jobs.
The API is structured into packages, each catering to distinct functions such as data manipulation, user management, or background job monitoring.
Subsequent sections delve into comprehensive information about each segment of the JavaScript API.
Namespaces # App Common classes Context Data Legacy Services Events Exceptions Files Internationalization Jobs Logs Storage [UI](/dev-reference/scripting/sys-ui/ Users Utils `}),e.add({id:98,href:"/getting-started/getting/first-steps/event-planner/small/",title:"Small change (optional)",description:"One use that we could make with the field we have just created is to keep a correct track of all the events in the app. Currently, the Admin user of the app can delete events, which might be suitable in some cases, but let&rsquo;s suppose that you want to manage it only with the &ldquo;Cancel&rdquo; status for better metrics in the future. We need to remove the permission for deleting an event from the Admin users.",content:`One use that we could make with the field we have just created is to keep a correct track of all the events in the app. Currently, the Admin user of the app can delete events, which might be suitable in some cases, but let&rsquo;s suppose that you want to manage it only with the &ldquo;Cancel&rdquo; status for better metrics in the future. We need to remove the permission for deleting an event from the Admin users.
Remove deleting permissions for Admins # Let&rsquo;s proceed with the following steps:
👉 Click on the node Model &gt; Entities &gt; Events &gt; Permissions.
👉 You should see a table with the permissions that the two default groups have on the entity &quot;Events&quot;.
👉 As you can see, only admins can delete events in our app. Maybe that&rsquo;s what you want, and it&rsquo;s a great way to manage it. However, now that we have our field &quot;Status&quot; we are going to utilize that. So, let&rsquo;s prevent Admin from deleting events.
👉 On the column &quot;Can delete&quot;, make sure that both groups are set to &quot;Never&quot;.
👉 Click on &quot;Save&quot;.
Great news!
With these small improvements, many potential problems in the future can be avoided. Let&rsquo;s proceed with pushing the changes to the app.
Impersonate an Admin # Once you have made the necessary changes, head over to the runtime tab and refresh the screen. You might be eager to verify if the modifications were implemented correctly.
Please be aware that you are currently logged in as a developer user, granting you extensive permissions, including the ability to delete events. Exercise caution.
To observe the changes, let&rsquo;s switch groups and emulate an Admin user.
👉 In the main header, click on the button with your name, a dropdown will be shown, click on &quot;Switch groups&quot;.
👉 A popup will appear, select only the Admin Group, and click on Switch.
👉 Now, go to All events and check that the option to delete an event is no longer available when you select an event. This should also be the case in the read-only view.
🥳
Congratulations on completing the tutorial!
Great job, wasn&rsquo;t it?
Looking forward to seeing you in the next tutorial!
`}),e.add({id:99,href:"/dev-reference/scripting/sys-app/",title:"sys.app",description:`sys.app # This package encompasses methods for retrieving information about the app, such as its name, URL, current environment, and more.
getLabel() # Returns the label of the app currently in execution.
Returns # string - The label of the app.
Samples # // logs the label of the app log('app: '+sys.app.getLabel()); getName() # Returns the name of the app currently in execution.
Returns # string - The name of the app.`,content:`sys.app # This package encompasses methods for retrieving information about the app, such as its name, URL, current environment, and more.
getLabel() # Returns the label of the app currently in execution.
Returns # string - The label of the app.
Samples # // logs the label of the app log('app: '+sys.app.getLabel()); getName() # Returns the name of the app currently in execution.
Returns # string - The name of the app.
Samples # // logs the name of the app log('app: '+sys.app.getName()); getEnv() # Returns the name of the environment in execution. It could be prod or dev.
Returns # string - The label of environment in execution.
Samples # // logs the name of the environment log('env: '+sys.app.getEnv()); getUrl() # Returns the URL of the app currently in execution. This URL might resemble something like https://yourapp.slingrs.io/dev/runtime or https://yourapp.slingrs.io/prod/runtime.
Returns # string - The URL of the app.
Samples # // logs the URL of the app log('app url: '+sys.app.getUrl()); getVersion() # Returns the version of app in execution. It is a timestamp.
Returns # string - The version of the app.
Samples # // logs the version of the app log('app version: '+sys.app.getVersion()); getDefaultLanguage() # Return the language code of the default language used in the app.
Returns # string - Language code used in the app
Samples # // logs the default language of the app log('app language: ' + sys.app.getDefaultLanguage()); getDefaultTimezone() # Return the id and label of the default timezone used in the app.
Returns # string - ID and label of the default timezone used in the app.
Samples # // logs the default timezone of the app log('app timezone: ' + JSON.stringify(sys.app.getDefaultTimezone())); `}),e.add({id:100,href:"/dev-reference/scripting/sys.auth/",title:"sys.auth",description:`sys.auth # This package contains some utilities to work with authentication of the API REST.
sendOtpCode(options) # Request an OTP code for a specific email or phone with the permission of the current user.
Parameters # Name Type Required Description options object yes These options allow you to configure the validity of the code and token to be generated and the destination to which it will be sent. Available option is:`,content:`sys.auth # This package contains some utilities to work with authentication of the API REST.
sendOtpCode(options) # Request an OTP code for a specific email or phone with the permission of the current user.
Parameters # Name Type Required Description options object yes These options allow you to configure the validity of the code and token to be generated and the destination to which it will be sent. Available option is:
- email: where the user should be notified by email.
- phone: where the user should be notified by SMS.
- inactivity: value in hours of the time in which it will be possible to exchange the code once it has been generated. (default 24 hours - Max 7 days)
- expiration: value in hours of the time in which the token could be used. (default and max 30 days). Returns # boolean - True if the code was sent successfully. False if something went wrong.
Samples # // request an OTP code var operationResult = sys.auth.sendOtpCode({email: &quot;email@slingr.io&quot;, inactivity: 1, expiration: 24}); if (operationResult) { sys.logs.info('OTP code was sent successfully'); } else { sys.logs.error('Error the OTP code was not sent'); } createToken(idOrEmailUser, code) # Create an api token for the user represented by the given record (Only available for admins). | Exchange a valid OTP code for a token (Available for any user).
Parameters # Name Type Required Description idOrEmailUser string yes ID or email of the user with which the token will be created. code string no The OTP code received by email or phone. Returns # object - An api token object for the user requested or for the email or phone number that was used to request the otp code.
Samples # // request an api token. // Only available for admins or devs users var tokenForSpecificUser = sys.auth.createToken('user@email.com'); if (tokenForSpecificUser) { sys.logs.info('The token for the user is: ' + JSON.stringify(tokenForSpecificUser)); } else { sys.logs.error('Error generating token'); } // Any user than have a valid OTP code previously generated var tokenFromOtpExchange = sys.auth.createToken(null, 'codeSent'); if (tokenFromOtpExchange) { sys.logs.info('The token for the user is: ' + JSON.stringify(tokenFromOtpExchange)); } else { sys.logs.error('Error generating token'); } `}),e.add({id:101,href:"/dev-reference/scripting/sys-commons/",title:"sys.commons",description:`sys.commons.ResultSet # ResultSet is an iterator designed for traversing API service call results. The ResultSet object retains a cursor that indicates the current object it&rsquo;s pointing to. Initially, the cursor is positioned before the first object. The next() method advances the cursor to the next available object.
The cursor can only move forward.
hasNext() # Checks whether there are more objects.
Returns # boolean - true if there are more objects, false otherwise.`,content:`sys.commons.ResultSet # ResultSet is an iterator designed for traversing API service call results. The ResultSet object retains a cursor that indicates the current object it&rsquo;s pointing to. Initially, the cursor is positioned before the first object. The next() method advances the cursor to the next available object.
The cursor can only move forward.
hasNext() # Checks whether there are more objects.
Returns # boolean - true if there are more objects, false otherwise.
Samples # // prints the name of 10 companies var query = sys.data.createQuery('companies').size(10); var resultSet = sys.data.find(query); while (resultSet.hasNext()) { var company = resultSet.next(); log(company.label()); } next() # Returns a single object and advances the cursor.
Returns # object - Typically a sys.data.Record.
Exceptions # badRequest
Thrown when there are no more objects.
Samples # // prints the name of 10 companies var query = sys.data.createQuery('companies').size(10); var resultSet = sys.data.find(query); while (resultSet.hasNext()) { var company = resultSet.next(); log(company.label()); } nextAndLock() # Returns and locks single object and advances the cursor.
Returns # object - Typically a sys.data.Record.
Exceptions # badRequest
Thrown when there are no more objects.
Samples # // prints the name of 10 companies var query = sys.data.createQuery('companies').size(10); var resultSet = sys.data.find(query); while (resultSet.hasNext()) { var company = resultSet.nextAndLock(); log(company.label()); } count() # Calculates the count of objects that match the query. This count is not influenced by the limit (_size parameter).
Returns # number - The count of objects that match the query.
Samples # // counts number of companies of type 'a' var query = sys.data.createQuery('companies').field('type').equals('a'); var resultSet = sys.data.find(query); log('count: '+resultSet.count()); toArray() # Iterates through all objects and returns them as an array. If the number of objects exceeds 1,000, the method will raise an exception to prevent memory overload.
Returns # object[] - An array containing all objects. Typically, these objects are of type sys.data.Record, but this depends on what you are iterating over.
Exceptions # systemException
Thrown when the result set contains more than 1,000 objects.
Samples # // prints the name of 10 companies var query = sys.data.createQuery('companies').size(10); var resultSet = sys.data.find(query); var companies = resultSet.toArray(); companies.forEach(function(company) { log(company.label()); }); `}),e.add({id:102,href:"/dev-reference/scripting/sys-context/",title:"sys.context",description:`sys.context # This package provides methods to retrieve information about the execution context of the script, such as the current user or the call stack.
getCurrentUserRecord() # Returns a sys.data.Record object containing the extended user fields for the user in the ongoing execution context. If there is no user defined in the current execution context, this method will return null.
Returns # sys.data.record - The user in the current execution context, or null if not set.`,content:`sys.context # This package provides methods to retrieve information about the execution context of the script, such as the current user or the call stack.
getCurrentUserRecord() # Returns a sys.data.Record object containing the extended user fields for the user in the ongoing execution context. If there is no user defined in the current execution context, this method will return null.
Returns # sys.data.record - The user in the current execution context, or null if not set.
Exceptions # badRequest
Thrown if extended user fields are not configured.
Samples # // prints the extended user information for the current user var record = sys.context.getCurrentUserRecord(); log('current user extra info: ' + JSON.stringify(sys.utils.text.recordToString(record))); getCurrentIp() # Retrieves the IP address of the current request. If the script is running in a context without an associated request, this method will return null.
Returns # string - The IP address of the current request.
Samples # // logs the current request IP var ip = sys.context.getCurrentIp(); log('IP: '+ip); setCurrentUserRecord(user) # Sets the current user in the context of execution using a sys.data.Record object.
Please note that if you don&rsquo;t manually restore the current user in the execution context, it will be automatically restored after the script snippet is executed.
Parameters # Name Type Required Description user sys.data.Record The user to set as the current one in the context of execution. Samples # // sets the current user and then logs the email of the current user var test1 = sys.data.findOne('sys.users', {email: 'test1.docs@slingr.io'}); sys.context.setCurrentUserRecord(test1); var currentUser = sys.context.getCurrentUserRecord(); log('current user: '+currentUser.field('email').val()); setCurrentUserRecordById(userId) # Sets the current user in the context of execution using a user ID.
Please bear in mind that if you don&rsquo;t manually restore the current user in the execution context, it will be automatically restored after the script snippet is executed.
Parameters # Name Type Required Description userId string The ID of the user to set as the current one in the context of execution. Samples # // sets the current user and then logs the email of the current user var test1 = sys.data.findOne('sys.users', {email: 'test1.docs@slingr.io'}); sys.context.setCurrentUserRecordById(test1.id()); var currentUser = sys.context.getCurrentUserRecord(); log('current user: '+currentUser.field('email').val()); setCurrentUserRecordByEmail(userEmail) # Sets the current user in the context of execution using a user email.
Please bear in mind that if you don&rsquo;t manually restore the current user in the execution context, it will be automatically restored after the script snippet is executed.
Parameters # Name Type Required Description userEmail string The email of the user to set as the current one in the context of execution. Samples # // sets the current user and then logs the email of the current user sys.context.setCurrentUserRecordByEmail('test1.docs@slingr.io'); var currentUser = sys.context.getCurrentUserRecord(); log('current user: '+currentUser.field('email').val()); root() # Returns an object that provides utilities to determine the root context. To comprehend the functioning of contexts, please refer to the &ldquo;Context&rdquo; section.
The root context represents the highest level in the call stack. For instance, if you execute an action through the REST API, and within that action&rsquo;s script a record is created, during the record creation, the current context would be the record&rsquo;s creation context. However, the root context in this scenario would be the execution of the action itself, as it&rsquo;s the operation that initiated the request.
The method is utilized as follows:
if (sys.context.root().entity('companies').create().check()) { // we are in the context of the creation of a record in the 'companies' entity ... } else { ... } So, the typical sequence begins with sys.context.root(), followed by a sequence of methods that define the context. At the end of this sequence, there&rsquo;s a call to check(), which assesses whether the context is the root context.
Here are the available methods for context checking:
sys.context.root().entity('entityName').create().check() sys.context.root().entity('entityName').update().check() sys.context.root().entity('entityName').delete().check() sys.context.root().entity('entityName').import().check() sys.context.root().entity('entityName').action('actionName').check() sys.context.root().listener('listenerName').check() sys.context.root().users().create().check() sys.context.root().users().update().check() sys.context.root().users().delete().check() sys.context.root().users().import().check() Certain contexts permit the addition of supplementary information to enhance precision regarding the executing context:
sys.context.root().entity('entityName').create().check() sys.context.root().entity('entityName').update().with({recordId: id}).check() sys.context.root().entity('entityName').delete().with({recordId: id}).check() sys.context.root().entity('entityName').import().with({fileName: 'file.csv'}).check() sys.context.root().entity('entityName').action('actionName').with({recordId: id}).check() sys.context.root().users().create().with({email: 'email@test.com'}).check() sys.context.root().users().update().with({email: 'email@test.com'}).check() sys.context.root().users().update().with({id: '56cf0945ee42cf00064c105e'}).check() sys.context.root().users().delete().with({email: 'email@test.com'}).check() sys.context.root().users().delete().with({id: '56cf0945ee42cf00064c105e'}).check() sys.context.root().users().import().with({fileName: 'file.csv'}).check() Returns # object - An object that can be used to define the context to check; see description.
Samples # // checks that the script isn't running in the context of an import if (!sys.context.root().entity('companies').import().check()) { // do something here } any() # Returns an object that provides utilities for context evaluation across the call stack. To comprehend the functionality of contexts, please refer to the &ldquo;Context&rdquo; section.
This method is essentially identical to root(), but instead of solely checking the root context, the check() method will yield true if any context within the call stack matches. For instance, if you execute an action via the REST API, and within that action&rsquo;s script a record is created, during the record&rsquo;s creation, the current context would pertain to the record creation. By employing any() for context checking, as opposed to root(), assessing the context for both the action and the record creation would yield true:
sys.context.any().entity('companies').action('createAnotherRecord').check(); // returns true sys.context.any().entity('companies').create().check(); // returns true Please refer to the documentation of root() for more comprehensive information on defining a context and verifying it.
Returns # object - An object that can be utilized to define the context to be checked. Please see the description above for details.
Samples # // checks we are in the context of the creation of a record, no matter if it is the root or not if (sys.context.().entity('companies').create().check()) { // do something here } `}),e.add({id:103,href:"/dev-reference/scripting/sys-data/",title:"sys.data",description:`sys.data # This package contains methods and classes for working with data in your application. You&rsquo;ll find utilities for querying data, creating, updating, or deleting records, as well as more advanced operations like aggregation and executing actions.
findById(entityName, id) # This function finds a record by its ID. If the record is not found, null will be returned.
Parameters # Name Type Required Description entityName string yes The name of the entity id string yes ID of the record to find Returns # sys.`,content:`sys.data # This package contains methods and classes for working with data in your application. You&rsquo;ll find utilities for querying data, creating, updating, or deleting records, as well as more advanced operations like aggregation and executing actions.
findById(entityName, id) # This function finds a record by its ID. If the record is not found, null will be returned.
Parameters # Name Type Required Description entityName string yes The name of the entity id string yes ID of the record to find Returns # sys.data.Record - Record or null if not found
Exceptions # badRequest
This exception is raised if entityName is not valid or if ID is not a valid record ID.
Samples # // finds one company by its ID var company = sys.data.findById('companies', '57fd2d65e4b0ce322b0c8665'); if (company) { log(company.label()); } else { log('company not found'); } findByIdAndLock(entityName, id) # This function finds and lock a record by its ID. If the record is not found, null will be returned.
Parameters # Name Type Required Description entityName string yes The name of the entity id string yes ID of the record to find Returns # sys.data.Record - Record or null if not found
Exceptions # badRequest
This exception is raised if entityName is not valid or if ID is not a valid record ID.
Samples # // finds one company by its ID var company = sys.data.findByIdAndLock('companies', '57fd2d65e4b0ce322b0c8665'); if (company) { log(company.label()); } else { log('company not found'); } find(entityName, queryMap) # This function retrieves records from the specified entity based on a query map object. It returns a result set that can be iterated to fetch records.
It&rsquo;s important to note that during iteration, records may be returned more than once. This can occur if records are updated either within the iteration itself or by another thread. Be prepared to handle this scenario if it arises.
Parameters # Name Type Required Description entityName string yes The name of the entity queryMap object no The query map object used to filter records. Check the Query language documentation for the query map version. Returns # sys.commons.ResultSet - A result set that returns sys.data.Record objects when iterated.
Exceptions # badRequest
This exception is raised if entityName or queryMap are invalid
Samples # // iterates over all companies var companies = sys.data.find('companies', {}); while (companies.hasNext()) { log(companies.next().label()); } // finds using a query var companies = sys.data.find('companies', {type: 'a', _sortField: 'name', _sortType: 'asc'}); while (companies.hasNext()) { log(companies.next().label()); } find(queryBuilder) # This function retrieves records based on a query builder object. It returns a result set that can be iterated to fetch records.
It&rsquo;s important to note that during iteration, records may be returned more than once. This can occur if records are updated either within the iteration itself or by another thread. Be prepared to handle this scenario if it arises.
Parameters # Name Type Required Description queryBuilder [sys.data.Query] yes The query builder object used to filter records. Check the Query language documentation for the query builder version. Returns # sys.commons.ResultSet - A result set that returns sys.data.Record objects when iterated.
Exceptions # badRequest
This exception is raised if queryBuilder is invalid
Samples # // iterates over all companies var query = sys.data.createQuery('companies'); var companies = sys.data.find(query); while (companies.hasNext()) { log(companies.next().label()); } // finds using a query var query = sys.data.createQuery('companies') .field('type').equals('a') .sortBy('name', 'asc'); var companies = sys.data.find(query); while (companies.hasNext()) { log(companies.next().label()); } findOne(entityName, queryMap) # This function retrieves one record from the specified entity based on a query map object. If there query returns more than one result, the first one will be returned.
Parameters # Name Type Required Description entityName string yes The name of the entity queryMap object no The query map object used to filter records. Check the Query language documentation for the query map version. Returns # sys.data.Record - The first record found or null if there are no matching records for the given query.
Exceptions # badRequest
This exception is raised if entityName or queryMap are invalid
Samples # // finds one company where type is 'b' var company = sys.data.findOne('companies', {type: 'b'}); log(company.label()); findOneAndLock(entityName, queryMap) # This function retrieves and locks one record from the specified entity based on a query map object. If there query returns more than one result, the first one will be returned.
Parameters # Name Type Required Description entityName string yes The name of the entity queryMap object no The query map object used to filter records. Check the Query language documentation for the query map version. Returns # sys.data.Record - The first record found or null if there are no matching records for the given query.
Exceptions # badRequest
This exception is raised if entityName or queryMap are invalid
Samples # // finds one company where type is 'b' var company = sys.data.findOneAndLock('companies', {type: 'b'}); log(company.label()); findOne(queryBuilder) # This function retrieves one record based on a query builder object. If there query returns more than one result, the first one will be returned.
Parameters # Name Type Required Description queryBuilder sys.data.Query yes The query builder object used to filter records. Check the Query language documentation for the query builder version. Returns # sys.data.Record - The first record found or null if there are no matching records for the given query.
Exceptions # badRequest
This exception is raised if queryBuilder is invalid
Samples # // finds one company where type is 'b' var query = sys.data.createQuery('companies') .field('type').equals('b'); var company = sys.data.findOne(query); log(company.label()); findOneAndLock(queryBuilder) # This function retrieves and locks one record based on a query builder object. If there query returns more than one result, the first one will be returned.
Parameters # Name Type Required Description queryBuilder sys.data.Query yes The query builder object used to filter records. Check the Query language documentation for the query builder version. Returns # sys.data.Record - The first record found or null if there are no matching records for the given query.
Exceptions # badRequest
This exception is raised if queryBuilder is invalid
Samples # // finds one company where type is 'b' var query = sys.data.createQuery('companies') .field('type').equals('b'); var company = sys.data.findOneAndLock(query); log(company.label()); count(queryBuilder) # This function counts the number of records that match the criteria specified in the query builder object. Please note that certain options in the query language, such as size and offset, will be ignored when using this function.
Parameters # Name Type Required Description queryBuilder sys.data.Query no The query builder object used to filter records. Check the Query language documentation for the query builder version. Returns # number - The number of records matching the criteria.
Exceptions # badRequest
This exception is raised if queryBuilder is invalid
Samples # // counts companies where type is 'a' var query = sys.data.createQuery('companies') .field('type').equals('b'); var count = sys.data.count(query); log('count: '+count); aggregate(entityName, aggregateQueryMap) # This function allows you to perform aggregation operations such as sum, average, and count over an entity. It uses an aggregate query map for specifying the aggregation criteria. For more detailed information on how to construct aggregate queries, please refer to the documentation on Aggregate queries.
Parameters # Name Type Required Description entityName string yes The name of the entity aggregateQueryMap object no This is the aggregate query map object that defines the operations to perform. Check the documentation for Aggregate queries. Returns # sys.commons.ResultSet - A result set that returns JSON objects when iterated. The structure of this object depends on the aggregation operations performed. Check the documentation for Aggregate queries.
Exceptions # badRequest
This exception is raised if entityName or aggregateQueryMap are invalid
Samples # // sums up the total number of skills per customer var resultSet = sys.data.aggregate('contacts', [ {match: {'company.isCustomer': true}}, {group: {by: 'company', totalSkills: 'sum(numberOfSkills)'}} ]); while (resultSet.hasNext()) { var result = resultSet.next(); // the format of the result is a simple object you can stringify log(JSON.stringify(result)); } // finds contacts with more skills on each company var resultSet = sys.data.aggregate('contacts', [ {sort: {'numberOfSkills': 'desc'}}, {group: { by: 'company', firstName: 'first(firstName)', lastName: 'first(lastName)', skills: 'first(numberOfSkills)' } } ]); while (resultSet.hasNext()) { var result = resultSet.next(); // the format of the result is a simple object you can stringify log(JSON.stringify(result)); } aggregate(aggregateQueryBuilder) # This function allows you to perform aggregation operations such as sum, average, and count over an entity. It uses an aggregate query builder object for specifying the aggregation criteria. For more detailed information on how to construct aggregate queries, please refer to the documentation on Aggregate queries.
Parameters # Name Type Required Description aggregateQueryBuilder object yes This is the aggregate query builder object that defines the operations to perform. Check the documentation for Aggregate queries. Returns # sys.commons.ResultSet - A result set that returns JSON objects when iterated. The structure of this object depends on the aggregation operations performed. Check the documentation for Aggregate queries.
Exceptions # badRequest
This exception is raised if aggregateQueryBuilder is invalid
Samples # // sums up the total number of skills per customer var query = sys.data.createAggregateQuery('contacts'); query.match().field('company.isCustomer').equals(true); query.group().accumulate('totalNumberOfSkills').sum('numberOfSkills'); var resultSet = sys.data.aggregate(query); while (resultSet.hasNext()) { log(JSON.stringify(resultSet.next())); } // finds contacts with more skills on each company var query = sys.data.createAggregateQuery('contacts'); query.sort().by('numberOfSkills', 'desc'); query.group() .by('company') .accumulate('firstName').first('firstName') .accumulate('lastName').first('lastName') .accumulate('skills').first('numberOfSkills'); var resultSet = sys.data.aggregate(query); while (resultSet.hasNext()) { log(JSON.stringify(resultSet.next())); } refresh(record) # This function retrieves the latest version of a record to ensure it is up-to-date. This is particularly useful to confirm that you have the most recent version of the record, preventing potential optimistic locking exceptions when saving it.
Parameters # Name Type Required Description record sys.data.Record yes The record to be refreshed. Returns # sys.data.Record - The latest version of the record. It could return null if the record doesn’t exist anymore.
Exceptions # badRequest
This exception is raised if record is invalid
Samples # // refreshes a company record var company = sys.data.findById('companies', '57fd2d65e4b0ce322b0c8665'); // ... // some long operation happens in the middle // ... company = sys.data.refresh(company); if (company) { log(company.label()); } else { log('company was deleted'); } save(record,options) # This function saves a record in the database, making changes permanent. If the record was already saved (it has an ID that exists in the entity), it will be updated.
This method will execute all validation rules defined in the entity and its fields. Additionally, it will verify the version of the record to ensure that no changes are overwritten. If the version doesn&rsquo;t match, an optimistic locking exception will be thrown.
Once the record is successfully saved, the following events will be triggered:
On record create: If the record is new and was created, this event is triggered. You can check the parameter options to modify this behavior. On record change: If the record already existed in the database, this event is triggered. You can check the parameter options to modify this behavior. Cascade updates: If the modification or creation of the record impacts other records, a background job will be created to update them. You can check the parameter options to modify this behavior. Parameters # Name Type Required Description record sys.data.Record yes The record to save into the database. Please note that this object will be updated with the saved version of the record. For instance, if an ID is not present, it will be set, and calculated fields will also be included. options object no This is a map containing options that can modify the behavior of the save operation, some of which can enhance import performance when dealing with a large number of records. These are the available options:
- calculateFields: When set to false, calculated fields won&rsquo;t be evaluated and will remain as null in the saved record. Default is true.
- performValidations: Indicates whether validations should be executed on the record before saving. Note that type validations are always performed. This option works in conjunction with validations defined in type rules. Default is true. - filterByReadWriteAccess: When set to false, the save process will disregard the read/write access options defined for the fields. This means that all fields will be saved into the database. Default is true.
- triggerEvents: If set to false, events such as &ldquo;on record create&rdquo; or &ldquo;on record change&rdquo; will not be triggered during the save operation. Default is true.
- defaultValues: When set to false, default values will not be set during the save operation. Default is true. - cascadeOperations: If set to false, cascade updates for relationship fields or aggregate fields won&rsquo;t be executed. Default is true.
- lockRecord: If set to false, the record won&rsquo;t have concurrency protection. This means that listeners or actions could be executed concurrently. Default is true.
To configure these settings as defaults, you can use the following parameter:
- mode: Possible values are &ldquo;standard&rdquo; and &ldquo;raw.&rdquo; &ldquo;Standard&rdquo; executes the operation using the default values for the parameters described above (this is the default mode). In cases where high performance is required and it&rsquo;s not critical to apply all metadata rules during the save operation, a special &ldquo;raw&rdquo; mode is available. In &ldquo;raw&rdquo; mode, the record is directly stored in the database without applying validations, permissions, read/write rules, default values, expression calculations, event triggering, cascading, or locking. No result is returned in &ldquo;raw&rdquo; mode. Returns # sys.data.Record - The saved or updated record. The ID will be set and calculated or default values will be there.
Exceptions # validationErrors
This exception is raised if record does not meet validation rules defined for the entity.
optimisticLocking
This exception is raised if record is an old version
badRequest
This exception is raised if record is invalid
notFound
This exception is raised if the record is being updated (it has an ID) and it is not found in the database.
Samples # // updates a field in a company var company = sys.data.findById('companies', '57fd2d65e4b0ce322b0c8665'); company.field('notes').val('modified notes'); // you don't need to reassign the 'company' variable because the parameter will be updated sys.data.save(company); // ... // do some other changes and save again company.field('notes').val('another modification'); sys.data.save(company); // catches validation errors var company = sys.data.findById('companies', '57fd2d65e4b0ce322b0c8665'); company.field('type').val('invalid'); try { sys.data.save(company); } catch (e) { log(e.code()+': '+e.message()); } // optimistic locking exception var company1 = sys.data.findById('companies', '57fd2d65e4b0ce322b0c8665'); var company2 = sys.data.findById('companies', '57fd2d65e4b0ce322b0c8665'); company1.field('notes').val('modified notes'); sys.data.save(company1); try { // this will throw an optimistic locking exception because the record was modified in the middle sys.data.save(company2); } catch (e) { log(e.code()+': '+e.message()); } // high performant update a company record var company = sys.data.findById('companies', '57fd2d65e4b0ce322b0c8665'); company.field('type').val('typeA'); company.field('notes').val('This is a note'); sys.data.save(company, {mode: 'raw'}); createRecord(entityName) # This function creates a new, empty sys.data.Record object. Please note that this record is not saved into the database until you explicitly call save().
Parameters # Name Type Required Description entityName string yes The name of the entity. Returns # sys.data.Record - The empty record object.
Exceptions # badRequest
If entityName is not valid
Samples # // creates a new company var company = sys.data.createRecord('companies'); company.field('name').val('test company '+parseInt(Math.random()*999)); // saves the new company into the database sys.data.save(company); company = sys.data.findById('companies', company.id()); log('saved company: '+company.label()); // clean up the created company sys.data.remove(company); remove(record) # This function deletes a record from the database.
Upon successful deletion of the record, the following events are triggered:
On record delete Cascade updates: If the deletion of the record has an impact on other records, a background job will be created to update them. Parameters # Name Type Required Description record sys.data.Record yes The record to remove from the database. Returns # sys.data.Record - The record that was removed.
Exceptions # badRequest
If record is not valid.
notFound
If record is not found in the database.
Samples # // creates and deletes a company var company = sys.data.createRecord('companies'); company.field('name').val('test company '+parseInt(Math.random()*999)); // saves the new company into the database sys.data.save(company); // deletes the just created company var deletedCompany = sys.data.remove(company); log('company ['+deletedCompany.label()+'] was deleted'); delete(entityName, queryMap, options) # This function deletes records that match the criteria specified in the query map object. Please note that certain options in the query language, such as size and offset, will be ignored when using this function.
Parameters # Name Type Required Description entityName string yes The name of the entity queryMap object no The query map object used to filter records. Check the Query language documentation for the query map version. options object no This is a map containing options that can modify the behavior of the deletion operation, and some of them can enhance delete performance when dealing with a large number of records. These are the available options:
- triggerEvents: If set to false, deletion events will not be triggered. Default is true. - cascadeOperations: If set to false, cascade updates for updating relationship fields or aggregate fields will not be executed. Default is true.
- lowPrioriyt: Setting this option to true will mark the job as low priority, causing the deletion to occur only when there are not many jobs running. Default is false. Returns # string - Identifier of deletion job.
Exceptions # badRequest
This exception is raised if entityName or queryMap are invalid
Samples # // deletes active companies var jobId = sys.data.delete('companies', {active: true}); log('jobId: '+jobId); sys.jobs.waitForJob(jobId, 'FINISHED', 1000*10); delete(queryBuilder, options) # This function deletes records that match the criteria specified in the query builder object. Please note that certain options in the query language, such as size and offset, will be ignored when using this function.
Parameters # Name Type Required Description queryBuilder sys.data.Query no The query builder object used to filter records. Check the Query language documentation for the query builder version. options object no This is a map containing options that can modify the behavior of the deletion operation, and some of them can enhance delete performance when dealing with a large number of records. These are the available options:
- triggerEvents: If set to false, deletion events will not be triggered. Default is true. - cascadeOperations: If set to false, cascade updates for updating relationship fields or aggregate fields will not be executed. Default is true.
- lowPrioriyt: Setting this option to true will mark the job as low priority, causing the deletion to occur only when there are not many jobs running. Default is false. Returns # string - Identifier of deletion job.
Exceptions # badRequest
This exception is raised if queryBuilder is invalid
Samples # // deletes companies where type is 'b' var query = sys.data.createQuery('companies') .field('type').equals('b'); var jobId = sys.data.delete(query); log('jobId: '+jobId); sys.jobs.waitForJob(jobId, 'FINISHED', 1000*10); importRecords(entityName, fileId, options) # This function allows you to import records from a CSV file that must already be uploaded. The file can be stored in a field inside a record, retrieved from an endpoint like FTP or HTTP, or created within the script.
The rules for importing from a CSV file are the same as when you import a CSV using the app runtime UI. Please refer to the documentation on imports to understand how they work.
It&rsquo;s important to note that for each record you import, the same events as those triggered by the save() method will also be triggered.
Parameters # Name Type Required Description entityName string yes The name of the entity. fileId string yes The ID of the file to import. This should be a private file that has been uploaded into the app previously. For example, it could have been uploaded through the app runtime UI into a file field, uploaded from an HTTP or FTP endpoint, or created as a file using a script. You can refer to the samples to see the various options. options object no This is a map containing options that can modify the behavior of the import operation, and some of them can enhance import performance when dealing with a large number of records. These are the available options: - skipRecordsWithInvalidFields: When set to true, if some fields cannot be converted or are not valid, they will be set to null, and an attempt to save the record will still be made. If set to false, an exception will be thrown, and the record won&rsquo;t be imported. Default is true. - calculateFields: If set to false, calculated fields will not be evaluated when records are imported and will remain as null. Default is true. - performValidations: Indicates whether validations should be executed during the import process. Please note that type validations are always performed. This option works in conjunction with validations defined in type rules. Default is true. - filterByReadWriteAccess: When set to false, the import process will disregard the read/write access options defined for fields, and all fields will be imported into the database. Default is true. - triggerEvents: If set to false, events like &ldquo;on record create&rdquo; or &ldquo;on record change&rdquo; will not be triggered during the import process. Default is true. - defaultValues: If set to false, default values in imported records will not be set. Default is true.
- cascadeOperations: If set to false, cascade updates for updating relationship fields or aggregate fields will not be executed during the import process. Default is true. - lowPriority: Setting this option to true marks the job as low priority, causing the import to occur only when there are not many jobs running. Default is false. Returns # string - The ID of the background job responsible for the import. To monitor the progress of the import, including any errors, you should check the status of the background job.
Exceptions # badRequest
This exception is raised if entitiName or fileId are invalid.
Samples # // creates a CSV file, imports it into 'companies' entity using low priority and then does a clean up to remove those records var total = 10; var fileWriter = sys.files.create('companies.csv', 'text/csv'); try { fileWriter.writeHeaders(['name', 'state', 'type']); for (var i = 0; i &lt; total; i++) { log('writting row '+i); fileWriter.writeRow(['test'+i, 'active', 'a']); } } finally { fileWriter.close(); } // import data var jobId = sys.data.importRecords('companies', fileWriter.descriptor().id(), {lowPriority: true}); sys.jobs.waitForJob(jobId, 'FINISHED', 60*1000); log(total+' records imported!'); // clean up var testRecords = sys.data.find('companies', {name: 'like(test)'}); var recordsRemoved = 0; while (testRecords.hasNext()) { sys.data.remove(testRecords.next()); recordsRemoved++; } log(recordsRemoved+' records removed!'); // imports records from a file field // find record with file var fileRecord = sys.data.findOne('files', {code: 'test-companies'}); // import data var jobId = sys.data.importRecords('companies', fileRecord.field('file').id(), {lowPriority: true}); sys.jobs.waitForJob(jobId, 'FINISHED', 60*1000); log('records imported!'); // clean up var testRecords = sys.data.find('companies', {name: 'like(test)'}); var recordsRemoved = 0; while (testRecords.hasNext()) { sys.data.remove(testRecords.next()); recordsRemoved++; } log(recordsRemoved+' records removed!'); executeAction(entityName, queryMap, actionName, params) # Executes an action in the background over the records returned by the query.
Parameters # Name Type Required Description entityName string yes The name of the entity queryMap object yes The query map object used to filter records. Check the Query language documentation for the query map version. actionName string yes The name of the action to be executed. params object no If the action has parameters you should put them here. The format is the same used by the REST API. Returns # string - The ID of the background job responsible for executing the action over all records. To monitor progress (including any errors), you should check the status of the background job.
Exceptions # badRequest
This exception is raised if entityName or queryMap or actionName are invalid
Samples # // executes the action 'logSomething' over 10 company records of type 'a' var jobId = sys.data.executeAction('companies', {type: 'a', _size: 10}, 'logSomething'); sys.jobs.waitForJob(jobId, 'FINISHED', 60*1000); log('completed!'); // executes the action 'logSomething' over 10 company records of type 'a', sending a parameter var jobId = sys.data.executeAction('companies', {type: 'a', _size: 10}, 'logSomething', {param1: 'a', param2: 'b'}); sys.jobs.waitForJob(jobId, 'FINISHED', 60*1000); log('completed!'); executeAction(queryBuilder, actionName, body) # Executes an action in the background over the records returned by the query.
Parameters # Name Type Required Description queryBuilder sys.data.Query yes The query builder object used to filter records. Check the Query language documentation for the query builder version. actionName string yes The name of the action to be executed. body object no If the action has parameters you should put them here. The format is the same used by the REST API. Returns # string - The ID of the background job responsible for executing the action over all records. To monitor progress (including any errors), you should check the status of the background job.
Exceptions # badRequest
This exception is raised if queryBuilder or actionName are invalid
Samples # // executes the action 'logSomething' over 10 company records of type 'a' var query = sys.data.createQuery('companies') .field('type').equals('a') .size(10); var jobId = sys.data.executeAction(query, 'logSomething'); sys.jobs.waitForJob(jobId, 'FINISHED', 60*1000); log('completed!'); // executes the action 'logSomething' over 10 company records of type 'a', sending a parameter var query = sys.data.createQuery('companies') .field('type').equals('a') .size(10); var jobId = sys.data.executeAction(query, 'logSomething', {param1: 'a', param2: 'b'}); sys.jobs.waitForJob(jobId, 'FINISHED', 60*1000); log('completed!'); executeAction(entityName, actionName, params) # Performs the execution of a global action.
Parameters # Name Type Required Description entityName string yes The name of the entity actionName string yes The name of the action to be executed. params object no If the action has parameters you should put them here. The format is the same used by the REST API. Returns # string - The ID of the background job responsible for executing the action over all records. To monitor progress (including any errors), you should check the status of the background job.
Exceptions # badRequest
This exception is raised if entityName or actionName are invalid
Samples # // executes the global action 'quickAdd' on companies entity and then finds the created company and log some properties var actionParams = {'name': 'Quick company', 'address': {'addressLine1': 'Siempre viva street'}}; var jobId = sys.data.executeGlobalAction('companies', 'quickAdd', actionParams); sys.jobs.waitForJob(jobId, 'FINISHED', 1000*10); var dataCursor = sys.data.find('companies', {name: 'Quick company'}); var dataFound = dataCursor.next(); log(dataFound.id()); log(dataFound.label()); log(dataFound.field('address.addressLine1').val()); tryLock(record, timeout) # This function attempts to acquire a lock for a specified record. It should be used when multiple threads are trying to access the same record, especially in cases where you have listeners or actions that could be executed concurrently.
If the lock has already been acquired, this method will wait until it is released. If the lock cannot be acquired within the specified timeout, it will return null instead of the record.
It&rsquo;s important to note that if you attempt to lock the same record within the same execution context, the lock will be granted immediately. This follows the concept of a reentrant lock.
You should always release the lock using unlock(), and it&rsquo;s recommended to do so in a finally block to ensure it happens. However, in case you forget to release the lock, the platform will automatically release the locks at the end of the script execution if they were not released manually.
Important!: The lock will be held for a maximum of 30 minutes, after which it will be automatically released.
Parameters # Name Type Required Description record sys.data.Record yes The record object. timeout number yes The maximum time in seconds to wait for the lock be acquired. If the lock cannot be acquired it returns a null. Returns # sys.data.Record - The updated version of the record when the lock was acquired, otherwise a null object.
Exceptions # badRequest
This exception is raised if record or timeout are invalid
notFound
If record is not found in the database
Samples # // locks a record for 20 seconds var company = sys.data.findOne('companies', {name:'Blogpad'}); company = sys.data.tryLock(company); try { // write some code here to update the company // if from the app you try to update the record it will be blocked // until the lock is released log('do something'); sys.utils.script.wait(20000); } finally { sys.data.unlock(company); } lock(record, timeout) # This function acquires a lock for a specified record. It should be used when multiple threads are trying to access the same record, especially in cases where you have listeners or actions that could be executed concurrently.
If the lock has already been acquired, this method will wait until it is released. If the lock cannot be acquired within the specified timeout, it will return null instead of the record.
It&rsquo;s important to note that if you attempt to lock the same record within the same execution context, the lock will be granted immediately. This follows the concept of a reentrant lock.
You should always release the lock using unlock(), and it&rsquo;s recommended to do so in a finally block to ensure it happens. However, in case you forget to release the lock, the platform will automatically release the locks at the end of the script execution if they were not released manually.
Important!: The lock will be held for a maximum of 30 minutes, after which it will be automatically released.
Parameters # Name Type Required Default Description record sys.data.Record yes - The record object. timeout number yes 300000 (5 minutes) The maximum time in seconds to wait for the lock be acquired. If the lock cannot be acquired it returns a null. Returns # sys.data.Record - The updated version of the record when the lock was acquired, otherwise a null object.
Exceptions # badRequest
This exception is raised if record or timeout are invalid
notFound
If record is not found in the database
timeout
If the lock couldn’t be acquiered within the specified timeout.
Samples # // locks a record for 20 seconds var company = sys.data.findOne('companies', {name:'Blogpad'}); try { company = sys.data.lock(company); try { // write some code here to update the company // if from the app you try to update the record it will be blocked // until the lock is released log('do something'); sys.utils.script.wait(20000); } finally { sys.data.unlock(company); } } catch (le) { sys.logs.error('Error acquiring lock'); } // locks a record several times var company = sys.data.findOne('companies', {name:'Blogpad'}); company = sys.data.lock(company); // you can lock again in the same context as it is a reentrant lock company = sys.data.lock(company); // you need to unlock twice to release it sys.data.unlock(company); sys.data.unlock(company); tryLockById(entityName, recordId, timeout) # This function attempts to acquire a lock for a specified record using its ID (useful when you don’t have the record object but just the ID). It should be used when multiple threads are trying to access the same record, especially in cases where you have listeners or actions that could be executed concurrently.
If the lock has already been acquired, this method will wait until it is released. If the lock cannot be acquired within the specified timeout, it will return null instead of the record.
It&rsquo;s important to note that if you attempt to lock the same record within the same execution context, the lock will be granted immediately. This follows the concept of a reentrant lock.
You should always release the lock using unlock(), and it&rsquo;s recommended to do so in a finally block to ensure it happens. However, in case you forget to release the lock, the platform will automatically release the locks at the end of the script execution if they were not released manually.
Important!: The lock will be held for a maximum of 30 minutes, after which it will be automatically released.
Parameters # Name Type Required Description entityName string yes The name of the entity. recordId string yes The ID of the record to acquire the lock. timeout number yes The maximum time in milliseconds to wait for the lock be acquired. If the lock cannot be acquired it returns a null. Returns # sys.data.Record - The updated version of the record when the lock was acquired.
Exceptions # badRequest
This exception is raised if record or timeout are invalid.
notFound
If record with ID recordId is not found in the database.
Samples # // locks a record for 20 seconds var company = sys.data.lockById('companies', '57fd2d65e4b0ce322b0c8565'); try { if (company) { log('company ['+company.label()+'] is locked'); // write some code here to update the company // if from the app you try to update the record it will be blocked // until the lock is released log('do something'); sys.utils.script.wait(20000); } } finally { log('unlocking company ['+company.label()+']'); sys.data.unlock(company); } lockById(entityName, recordId, timeout) # This function acquires a lock for a specified record using its ID (useful when you don’t have the record object but just the ID). It should be used when multiple threads are trying to access the same record, especially in cases where you have listeners or actions that could be executed concurrently.
If the lock has already been acquired, this method will wait until it is released. If the lock cannot be acquired within the specified timeout, it will return null instead of the record.
It&rsquo;s important to note that if you attempt to lock the same record within the same execution context, the lock will be granted immediately. This follows the concept of a reentrant lock.
You should always release the lock using unlock(), and it&rsquo;s recommended to do so in a finally block to ensure it happens. However, in case you forget to release the lock, the platform will automatically release the locks at the end of the script execution if they were not released manually.
Important!: The lock will be held for a maximum of 30 minutes, after which it will be automatically released.
Parameters # Name Type Required Default Description entityName string yes - The name of the entity. recordId string yes - The ID of the record to acquire the lock. timeout number yes 300000 (5 minutes) The maximum time in milliseconds to wait for the lock be acquired. If the lock cannot be acquired it returns a null. Returns # sys.data.Record - The updated version of the record when the lock was acquired.
Exceptions # badRequest
This exception is raised if recordId or timeout are invalid.
notFound
If record with ID recordId is not found in the database.
timeout
If the lock couldn’t be acquiered within the specified timeout.
Samples # // locks a record for 20 seconds try { var company = sys.data.lockById('companies', '57fd2d65e4b0ce322b0c8565'); log('company ['+company.label()+'] is locked'); try { // write some code here to update the company // if from the app you try to update the record it will be blocked // until the lock is released log('do something'); sys.utils.script.wait(20000); } finally { log('unlocking company ['+company.label()+']'); sys.data.unlock(company); } } catch(le) { sys.logs.error('Log could not have been acquired', le); } unlock(record) # This function releases a lock that was previously acquired.
If the lock was acquired multiple times, it needs to be released an equivalent number of times as well.
Parameters # Name Type Required Description record sys.data.Record yes The record object. Exceptions # badRequest
This exception is raised if record is invalid.
notFound
If record is not found in the database.
Samples # // locks a record for 20 seconds und unlocks it at the end var company = sys.data.findOne('companies', {name:'Blogpad'}); company = sys.data.lock(company); try { // write some code here to update the company // if from the app you try to update the record it will be blocked // until the lock is released log('do something'); sys.utils.script.wait(20000); } finally { sys.data.unlock(company); } unlockById(entityName, recordId) # This function releases a lock that was previously acquired.
If the lock was acquired multiple times, it needs to be released an equivalent number of times as well.
Parameters # Name Type Required Description entityName string yes The name of the entity. recordId string yes The ID of the record to unlock. Exceptions # badRequest
This exception is raised if record is invalid.
notFound
If record with ID: recordId is not found in the database.
Samples # // locks a record for 20 seconds und unlocks it at the end var company = sys.data.lockById('companies', '57fd2d65e4b0ce322b0c8565'); log('company ['+company.label()+'] is locked'); try { // write some code here to update the company // if from the app you try to update the record it will be blocked // until the lock is released log('do something'); sys.utils.script.wait(20000); } finally { log('unlocking company ['+company.label()+']'); sys.data.unlockById('companies', '57fd2d65e4b0ce322b0c8565'); } replaceRefs(from, to) # This function replaces all references pointing to the from entity with references to the to entity. For example, if you have two companies, each with contacts and orders, and you want to merge those two companies, this function allows you to change all relationship fields pointing to company1 to instead point to company2.
sys.data.replaceRefs(company1, company2); 🚨 Important!!! This change will be applied to all records in all entities, and there is no way to roll it back. Parameters # Name Type Required Description from sys.data.Record yes The record you want to replace its references. to sys.data.Record no The record you want to reference instead of from. This can be null and reference will be removed. Returns # string - The ID of the background job responsible for replacing references over all records. To monitor progress (including any errors), you should check the status of the background job.
Exceptions # badRequest
This exception is raised if from or to are invalid
notFound
If toId is provided and record with ID: toId is not found in the database.
Samples # // locks a record for 20 seconds und unlocks it at the end // create 2 companies var company1 = sys.data.createRecord('companies'); company1.field('name').val('testA'); sys.data.save(company1); var company2 = sys.data.createRecord('companies'); company2.field('name').val('testB'); sys.data.save(company2); // create 2 contacts associated to company1 var contact1 = sys.data.createRecord('contacts'); contact1.field('company').val(company1); contact1.field('firstName').val('contact1'); contact1.field('lastName').val('test'); contact1.field('email').val('contact1@test.com'); sys.data.save(contact1); var contact2 = sys.data.createRecord('contacts'); contact2.field('company').val(company1); contact2.field('firstName').val('contact2'); contact2.field('lastName').val('test'); contact2.field('email').val('contact2@test.com'); sys.data.save(contact2); // replace references from company1 to company2 var jobId = sys.data.replaceRefs(company1, company2); sys.jobs.waitForJob(jobId, 'FINISHED', 60*1000); // check if references were modified contact1 = sys.data.refresh(contact1); contact2 = sys.data.refresh(contact2); log(contact1.field('company').label()); log(contact2.field('company').label()); createQuery(entityName) # This function initializes and returns a sys.data.Query object. Please refer to the documentation for the Query language for more information.
Parameters # Name Type Required Description entityName string yes The name of the entity. Returns # sys.data.Query - The query builder object for the given entity.
Exceptions # badRequest
If entityName is not valid
Samples # // creates a query to find companies with type 'a' var query = sys.data.createQuery('companies'); query.field('type').equals('a'); log('total A companies: '+sys.data.count(query)); createAggregateQuery(entityName) # This function initializes and returns a sys.data.AggregateQuery object. Please refer to the documentation for the Query language for more information.
Parameters # Name Type Required Description entityName string yes The name of the entity. Returns # sys.data.AggregateQuery - The aggregate query builder object for the given entity.
Exceptions # badRequest
If entityName is not valid
Samples # // creates an aggregate query to find the contact with more skills per company var query = sys.data.createAggregateQuery('contacts'); query.sort().by('numberOfSkills', 'desc'); query.group() .by('company') .accumulate('firstName').first('firstName') .accumulate('lastName').first('lastName') .accumulate('skills').first('numberOfSkills'); var resultSet = sys.data.aggregate(query); while (resultSet.hasNext()) { log(JSON.stringify(resultSet.next())); } sys.data.Record # sys.data.Record represents a record of an entity. It contains methods to read and write fields, execute actions, and perform various other operations.
All operations that retrieve data will return objects of this type. For example, sys.data.findOne() or sys.data.findById() return objects of sys.data.Record.
You can also create Record objects using the method sys.data.createRecord():
var company = sys.data.createRecord('companies'); company.field('name').val('test company'); sys.data.save(company); id() # Returns the ID of the record. If this is a new record that hasn’t been saved into the database, this will return null.
Returns # string - The ID of the record.
Samples # // finds 10 companies and logs their ID var companies = sys.data.find('companies', {type: 'a', _size: 10}); while (companies) { var company = companies.next(); log('ID: '+company.id()); } label() # This function returns the label of the record based on the instance label expression defined in the entity. Please note the following:
The label is calculated when the record is saved into the database. New records that haven&rsquo;t been saved won&rsquo;t have a label. Records that were modified but not updated might have an outdated label. Returns # string - The label of the record.
Samples # // finds 10 companies and logs their label var companies = sys.data.find('companies', {type: 'a', _size: 10}); while (companies.hasNext()) { var company = companies.next(); log('Label: '+company.label()); } entityName() # Returns the name of the entity the record belongs to.
Returns # string - The name of the entity.
Samples # // prints the name of the entity var company = sys.data.findOne('companies', {type: 'a'}); log('Entity name: '+company.entityName()); entityId() # Returns the ID of the entity the record belongs to.
Returns # string - The ID of the entity.
Samples # // prints the name of the entity var company = sys.data.findOne('companies', {type: 'a'}); log('Entity name: '+company.entityId()); field(path) # This function returns a wrapper for the field at the specified path. Wrappers provide various methods for accessing data in different ways, and they are type-specific. This means that each data type will offer different methods. Please refer to the documentation of sys.data.Wrapper for more information.
It&rsquo;s important to note that this method doesn&rsquo;t return the actual value of the field. Instead, it returns an object of type sys.data.Wrapper, which you can use to read and manipulate the value. For example:
// 'company' is a record in entity 'companies' // get the name of the company var name = company.field('name').val(); // set the name of the company record.field('name').val('new name'); It is possible to access nested fields:
// 'contact' is a record in entity 'contacts' // get the state of contacts var state = company.field('address.state').val(); // set the state of the contact record.field('address.state').val('NY'); If fields are multi-valued you can access them using an index:
// 'company' is a record in entity 'companies' // get the first state for a company var state = company.field('addresses[0].state').val(); // the above line is the same as this one: var state = company.field('addresses').first().field('state').val(); // set a value in a multi-valued field company.field('addresses[1].state').val('CA'); If the index is out of bounds, no exception will be thrown. Instead, if you are trying to read the value, you will get null. If you are trying to set the value, a new element will be created.
When you attempt to access a multi-valued field, you will receive a sys.data.ManyWrapper object. This object provides several methods for accessing the items inside:
// 'company' is a record in entity 'companies' // gets the state of the first address company.field('addresses').first().field('state').val(); // gets the state of the last address company.field('addresses').last().field('state').val(); // iterates over all addresses company.field('addresses').each(function(address) { log('State: '+address.field('state').val()); }); Please check the documentation of sys.data.ManyWrapper for more information.
Finally, if the path is not a valid field, an exception will be thrown.
Parameters # Name Type Required Description path string yes The path of the field. It could be a nested or multi-valued field. Returns # sys.data.Wrapper | sys.data.ManyWrapper - A wrapper that you can use to read and manipulate the value.
Exceptions # badRequest
If path is invalid
Samples # // prints the name of 10 companies var companies = sys.data.find('companies', {_size: 10}); while (companies.next()) { var company = companies.next(); log('name: '+company.field('name').val()); } // creates a new company and sets the name var company = sys.data.createRecord('companies'); company.field('name').val('test company'); sys.data.save(company); parent() # This is particularly useful when you are working with records that have a prefix set. For example, let&rsquo;s consider an entity with the following structure:
name orderLines (multi-valued) product quantity notes (multi-valued) note date user calculatedField The calculatedField can have a script to calculate its value, and you will find the variable parentField in there. This variable represents a record object, but it has a prefix specific to that particular notes field, like orderLines[2].notes[1]. This prefix is important because you might need to know the path of your field, allowing you to write expressions like this one:
return parentField.parent().parent().field('name').val() + ' ' + parentField.parent().field('product').name() + ' ' + parentField.field('note').val(); Returns # sys.data.Record - The record object with a prefix set to the parent field
Samples # // this is the value expression for a calculated field taken the sample in the description return parentField.parent().parent().field('name').val() + ' ' + parentField.parent().field('product').name() + ' ' + parentField.field('note').val(); copy() # This method allows to get a copy of a record and save it as a new one. This is helpful when creating several similar records just changes a few fields
Returns # sys.data.Record - The record object without identifiers
Samples # // this is the copy of record with name changed and saved. var copy = record.copy(); copy.field('name').val('newOne'); sys.data.save(copy); isNew() # If the record has an ID set, this method will return false. Otherwise it will return true.
Returns # boolean - true if the record doesn’t have an ID, false otherwise.
Samples # // check if record is new before and after saving var company = sys.data.createRecord('companies'); company.field('name').val('test1'); log('new: '+company.isNew()); sys.data.save(company); log('new: '+company.isNew()); action(actionName, prams) # This function executes the specified action over the record. The record must be saved into the database before executing an action.
If the action has parameters, you can provide them as the second argument.
The response will vary based on the action&rsquo;s configuration. There are two possible responses:
Record: If the action doesn&rsquo;t return any custom response, this method will return the updated record.
Custom Action Response: If the action returns a custom response, then that response will be returned.
Parameters # Name Type Required Description actionName string yes The name of the action to execute. params object no If the action has parameters you should put them here. The format is the same used by the REST API. Returns # object - An object of type sys.data.Record or a custom response if the action has been configured to do that.
Samples # // executes the action 'logSomething' over a company var company = sys.data.findOne('companies', {name: 'Blogpad'}); company.action('logSomething'); log('completed!'); // executes the action 'logSomething' over a company with parameters var company = sys.data.findOne('companies', {name: 'Blogpad'}); company.action('logSomething', {param1: 'a', param2: 'b'}); log('completed!'); history() # This function returns an object of type sys.data.RecordHistoryLogs that allows you to query history logs. For more information on how to query a record&rsquo;s history logs, please refer to sys.data.RecordHistoryLogs.
Returns # sys.data.RecordHistoryLogs - An object of type sys.data.RecordHistoryLogs to query history logs
Samples # // prints who created the record var company = sys.data.findOne('companies', {name: 'Blogpad'}); log('creator: '+company.history().createLog().user()); toJson(options) # Converts the record to its native JSON representation.
Parameters # Name Type Required Description options object no These options allow you to control how the record will be converted. The available options are: - fields: By default, all fields will be fetched. If you want to specify which fields you want to fetch, you can pass this parameter. You can specify multiple fields by separating them with commas. System fields will always be returned (e.g., id, version, etc.). - relationshipsToFetch: A comma-separated list of relationship fields that will be fetched within the record. For example, if an entity has relationship fields named &lsquo;company&rsquo; and &lsquo;region&rsquo;, you can fetch those referenced records like this: relationshipsToFetch: &lsquo;company,region&rsquo;
- format: The format to use when fetching the fields. There are two options: &rsquo;native&rsquo; and &lsquo;plainText&rsquo;. The &rsquo;native&rsquo; option shows the raw value of each field, while &lsquo;plainText&rsquo; returns the values of the fields converted using the display option of each field. The default value is &rsquo;native&rsquo;.
- user: If the format is &lsquo;plainText&rsquo;, we may need the user context to convert values with the correct internationalization and timezones. The default is the current user. Returns # object - A key-value JSON structure with the fields of the record converted to their native representation.
Samples # // converts a contact to the JSON representation var record = sys.data.findOne('contacts', {email: 'gowensb1@google.ca'}); var recordJson = record.toJson({relatedFields: 'company'}); log('JSON version of record: ' + recordJson); fromJson(recordJson) # Parses a JSON representation of the record.
Parameters # Name Type Required Description recordJson object yes A key-value object map containing the proper record representation. A partial record representation is allowed. Samples # // copies contact info to a new person record using JSON representation var contact = sys.data.findOne('contacts', {email: 'gowensb1@google.ca'}); var contactJson = record.toJson(); var person = sys.data.createRecord('people'); person.fromJson(contactJson); log('Person after update: ' + person.toJson()); // performs a partial update of a contact var person = sys.data.findOne('people', {sid: '20309721919'}); var contact = sys.data.findOne('contacts', {email: 'gowensb1@google.ca'}); contact.fromJson({ phoneNumber: person.field('phoneNumber').val(), webSite: person.field('webSite').val() }); log('Contact after update: ' + contact.toJson({})); lock(callback) # This function is used to obtain a lock for the current record. It should be employed when multiple threads are vying for access to the same record, particularly in scenarios where listeners or actions might execute concurrently.
If the lock has already been acquired, this method will wait until it becomes available. However, if the lock cannot be acquired within the specified timeout, an exception will be thrown.
It&rsquo;s important to note that if you attempt to lock the same record within the same execution context, the lock will be granted immediately, adhering to the reentrant lock concept.
If you provide the callback parameter, the lock will be automatically released once the callback finishes executing. Furthermore, after the callback execution, if any modifications were made to the record within the callback, the record object will be automatically refreshed.
In cases where you don&rsquo;t specify the callback parameter, it is imperative to release the lock using the unlock() method. The best practice is to do this within a finally block to ensure it always occurs. Nevertheless, in the event that you forget to release the lock, the platform will automatically free the locks at the end of the script execution if they were not released before.
Parameters # Name Type Required Description callback function no This callback function is executed immediately after a successful lock acquisition. The acquired lock is automatically released upon the completion of the defined callback. Samples # // locks a record for 20 seconds und unlocks it at the end var company = sys.data.findOne('companies', {name:'Blogpad'}); company.lock(); try { // write some code here to update the company // if from the app you try to update the record it will be blocked // until the lock is released log('do something'); sys.utils.script.wait(20000); } finally { company.unlock(); } // locks a record for 20 seconds by specifying a callback var company = sys.data.findOne('companies', {name:'Blogpad'}); company.lock(function (record) { // write some code here to update the company // if from the app you try to update the record it will be blocked // until the lock is released log('do something'); sys.utils.script.wait(20000); // at the end lock will be released automatically }); unlock() # This function releases a lock that was previously acquired.
If the lock was acquired multiple times, it must also be released an equivalent number of times.
Samples # // locks a record for 20 seconds und unlocks it at the end var company = sys.data.findOne('companies', {name:'Blogpad'}); company.lock(); try { // write some code here to update the company // if from the app you try to update the record it will be blocked // until the lock is released log('do something'); sys.utils.script.wait(20000); } finally { company.unlock(); } sys.data.Wrapper # Whenever you need to access or manipulate the value of a field using the JavaScript API, you will interact with a wrapper. You should never create a wrapper manually. Instead, objects of this type are created by methods such as sys.data.Record.field()
The wrapper offers several utilities for retrieving and modifying the field&rsquo;s value. Depending on the field type, it may also provide different services. Please refer to the documentation for each field type to understand the specific utilities available in the wrapper.
val() # This method returns the value of the field. It&rsquo;s important to note that this value cannot differ from the value in the REST API. For example, a date-time field in the REST API is represented as a number, indicating milliseconds since the EPOCH. However, this method will return a Date object. Please consult the documentation for each field type to determine its default format.
Keep in mind that if the field you are referencing is multi-valued, this method will return an array of values.
Returns # any or any[] - Returns the value of the field. If it is multi-valued, it will return an array. Please consult the type&rsquo;s documentation to understand what is returned.
Samples # // get the value of different fields var company = sys.data.findOne('companies', {name:'Voonyx'}); var nameWrapper = company.field('name'); log('name: '+nameWrapper.val()); // you could also use a shorter form log('name: '+company.field('name').val()); // the wrapper for nested fields has utilities to access inner fields var firstAddressWrapper = company.field('addresses[0]'); var stateWrapper = firstAddressWrapper.field('state'); log('state: '+stateWrapper.val()); // or you could use the shorter form log('state: '+company.field('addresses[0]').field('state').val()); // or even shorter log('state: '+company.field('addresses[0].state').val()); // some fields, like data time, use a different format from the REST API // in this case the value is returned as a Date object var lastUpdateWrapper = company.field('lastUpdate'); log('last update: '+lastUpdateWrapper.val()); log('last update millis: '+lastUpdateWrapper.val().getTime()); // date time also supports formatting the date log('last update yyyy-MM-dd: '+company.field('lastUpdate').format('yyyy-MM-dd')); // if the field is multi-valued, you will get an array of values log('addresses: '+JSON.stringify(company.field('addresses').val())); // if the field isn't multi-valued, but you the parent is an you don't specify // an index, then the result will be an array as well log('states: '+JSON.stringify(company.field('addresses.state').val())); val(value) # This method sets the value of the field. You should refer to the type&rsquo;s documentation to determine the supported formats. For instance, a date-time field can accept Date objects or milliseconds from the EPOCH to facilitate operations.
If the field is multi-valued, you should provide an array of values. In such cases, it&rsquo;s advisable to consult the documentation for sys.data.ManyWrapper, which contains utilities for handling multi-valued fields.
Parameters # Name Type Required Description value any yes The value to set in the field. Type depends on the field. Exceptions # badRequest
If value is invalid. Validation rules depends on the type.
Samples # // creates a record and changes some of the values var company = sys.data.createRecord('companies'); // sets a text field company.field('name').val('test 1'); // sets a date field using a Date object company.field('startDate').val(new Date()); // you can also set a nested field directly company.field('contactInformation.phoneNumber').val('111-222-3333'); company.field('contactInformation.email').val('test@test.com'); // you could also set nested fields with a map company.field('contactInformation').val({ phoneNumber: '444-555-6666', email: 'john@test.com' }); // you can set a multi-valued field by sending an array company.field('addresses').val([ { addressLine: '63 test', zipCode: '12233' }, { addressLine: '32 street', zipCode: '83672' } ]); // you change a nested field inside a multi-valued field using an index company.field('addresses[0].state').val('NY'); isEmpty() # This method returns true if the field is empty. Typically, a field is considered empty when its value is null. However, certain types may define additional rules; for example, text fields may consider an empty string as an empty value.
For multi-valued fields, this method returns true if the field has no values.
Returns # boolean - Returns true if the field is empty, otherwise false.
isNotEmpty() # This method returns true if the field is not empty. Usually, a field is not empty when it contains a valid value.
For multi-valued fields, this method returns true if the field contains values.
Returns # boolean - Returns true if the field is not empty, otherwise false.
equals(value) # This method checks if the value of the field is equal to the given value.
Parameters # Name Type Required Description value any yes The value to compare with the value of the field. Type depends on the field. Returns # boolean - Returns true if values are equal, false otherwise.
Exceptions # badRequest
If value is invalid. Validation rules depends on the type.
sys.data.ManyWrapper # This class inherits from sys.data.Wrapper and operates on multi-valued fields. It follows the same concept as sys.data.Wrapper, but it is tailored for working with multi-valued fields, providing utilities to add values, check if a value is contained in the list, remove values, and more.
Just like with sys.data.Wrapper, you should not create instances of this class manually. Instead, objects of this type are created using methods like sys.data.Record.field().
add(value) # This method adds an element to the end of the list.
Parameters # Name Type Required Description value any yes The element to add to the list. The type depends on the field. Exceptions # badRequest
If value is invalid. Validation rules depends on the type.
Samples # // adds a few elements to a list var company = sys.data.createRecord('companies'); company.field('addresses').add({ addressLine: '52 street', zipCode: '18231' }); company.field('addresses').add({ addressLine: '73 test', zipCode: '84873' }); add(index, value) # This method adds an element at the specified position in the list. Existing elements will be shifted to the right.
Parameters # Name Type Required Description index number yes The position in the list where the new element should be added. value any yes The element to add to the list. The type depends on the field. Exceptions # badRequest
If value is invalid. Validation rules depends on the type.
Samples # // adds an element at the first position of the list var company = sys.data.createRecord('companies'); company.field('addresses').add({ addressLine: '52 street', zipCode: '18231' }); company.field('addresses').add({ addressLine: '73 test', zipCode: '84873' }); // this value will be inserted at the first position and other values will be shifted company.field('addresses').add(0, { addressLine: '10 road', zipCode: '92743' }); remove(value) # Removes the first occurrence of an element from the list. It doesn’t need to be the exact same object, but in order to compare the value the method sys.data.Wrapper.equals() will be used, which can be overridden by each type.
Parameters # Name Type Required Description value any yes The element to remove from the list. The type depends on the field. Exceptions # badRequest
If value is invalid. Validation rules depends on the type.
Samples # // removes an element from the list var contact = sys.data.createRecord('contacts'); contact.field('skills').add('Firewalls'); log('skills: '+JSON.stringify(contact.field('skills').val())); contact.field('skills').remove('Firewalls'); log('skills: '+JSON.stringify(contact.field('skills').val())); remove(callback) # Removes elements where evaluation of the function returns true.
Parameters # Name Type Required Description callback function yes The function to evaluate if an element needs to be removed. It will receive the element wrapper as parameter and should return true if the element has to be removed or false otherwise. Exceptions # badRequest
If callback is invalid.
Samples # // removes an element from the list var contact = sys.data.createRecord('contacts'); contact.field('skills').add('Firewalls'); contact.field('skills').add('WLAN'); contact.field('skills').add('YouTube'); log('skills: '+JSON.stringify(contact.field('skills').val())); contact.field('skills').remove(function(element) { if (element.label() == 'WLAN' || element.label() == 'YouTube') { return true; } else { return false; } }); log('skills: '+JSON.stringify(contact.field('skills').val())); removeAt(index) # Removes an element from the list from the specified position.
Parameters # Name Type Required Description index number yes The position in the list where the element should be removed. Exceptions # badRequest
If index is invalid.
Samples # // removes an element from the list var contact = sys.data.createRecord('contacts'); contact.field('skills').add('Firewalls'); contact.field('skills').add('WLAN'); contact.field('skills').add('YouTube'); log('skills: '+JSON.stringify(contact.field('skills').val())); contact.field('skills').removeAt(1); log('skills: '+JSON.stringify(contact.field('skills').val())); removeAll() # Removes all elements from the list.
Samples # // removes all elements from the list var contact = sys.data.createRecord('contacts'); contact.field('skills').add('Firewalls'); contact.field('skills').add('WLAN'); contact.field('skills').add('YouTube'); log('skills: '+JSON.stringify(contact.field('skills').val())); contact.field('skills').removeAll(); log('skills: '+JSON.stringify(contact.field('skills').val())); each(callback) # Iterate over all elements in the list.
Parameters # Name Type Required Description callback function yes The function to that will process all elements. It will receive the element wrapper as parameter and should return true if the element has to be removed or false otherwise. Exceptions # badRequest
If callback is invalid.
Samples # // iterates over all elements var contact = sys.data.createRecord('contacts'); contact.field('skills').add('Firewalls'); contact.field('skills').add('WLAN'); contact.field('skills').add('VLAN'); contact.field('skills').each(function(skill, index) { log('skill: '+skill.label()); }); // iterate over the first two elements var contact = sys.data.createRecord('contacts'); contact.field('skills').add('Java'); contact.field('skills').add('.NET'); contact.field('skills').add('Python'); contact.field('skills').add('Golang'); contact.field('skills').each(function(skill, index) { if (index &gt; 1) { return false; } log('skill: '+skill.label()); }); get(index) # Retrieves the element at the specifed position.
Parameters # Name Type Required Description index number yes The position of the element to retrieve. Returns # sys.data.Wrapper - Returns the wrapper of the element at the specified position.
Exceptions # badRequest
If index is invalid.
Samples # // gets an element from a position in the list var contact = sys.data.createRecord('contacts'); contact.field('skills').add('Firewalls'); contact.field('skills').add('WLAN'); contact.field('skills').add('YouTube'); log('skills: '+contact.field('skills').get(1).label()); first() # Retrieves the first element in the list.
Returns # sys.data.Wrapper - Returns the wrapper of the first element. null if list is empty.
Samples # // gets the first element in the list var contact = sys.data.createRecord('contacts'); contact.field('skills').add('Firewalls'); contact.field('skills').add('WLAN'); contact.field('skills').add('YouTube'); log('skills: '+contact.field('skills').first().label()); last() # Retrieves the last element in the list.
Returns # sys.data.Wrapper - Returns the wrapper of the first element. null if list is empty.
Samples # // gets the last element in the list var contact = sys.data.createRecord('contacts'); contact.field('skills').add('Firewalls'); contact.field('skills').add('WLAN'); contact.field('skills').add('YouTube'); log('skills: '+contact.field('skills').last().label()); size() # Returns the number of elements in the list.
Returns # number - The number of elements in the list.
Samples # // counts the number of elements in the list var contact = sys.data.createRecord('contacts'); contact.field('skills').add('Firewalls'); log('size: '+contact.field('skills').size()); contact.field('skills').add('WLAN'); log('size: '+contact.field('skills').size()); contact.field('skills').add('YouTube'); log('size: '+contact.field('skills').size()); contains(value) # This method checks if the given value is already present in the list. It returns true if the value is in the list, otherwise, it returns false. To perform this check, the method uses sys.data.Wrapper.equals(), which can be overridden by each data type.
Parameters # Name Type Required Description value any yes The value to check if it is in the list. The type depends on the field. Returns # boolean - true if value is in the list, false otherwise.
Exceptions # badRequest
If value is invalid. Validation rules depends on the type.
Samples # // checks if a value is in the list var contact = sys.data.createRecord('contacts'); contact.field('skills').add('Firewalls'); contact.field('skills').add('WLAN'); contact.field('skills').add('YouTube'); log('Firewalls: '+contact.field('skills').contains('Firewalls')); log('WLAN: '+contact.field('skills').contains('WLAN')); log('YouTube: '+contact.field('skills').contains('YouTube')); log('Java: '+contact.field('skills').contains('Java')); sys.data.Action # When an action is executed, an object of this class will be accessible in the context of the action&rsquo;s scripts with the name action. This allows access to fields within the action in a similar way to how you would interact with record fields.
name() # Returns the name of the action being executed.
Returns # string - Name of the action being executed.
Samples # // print name of the action; only works inside scripts of an action sys.logs.info('action being executed: '+action.name()); field(path) # Returns the action field at the given path. It works exactly the same as sys.data.Record.field() but it works over the fields defined on the action.
Parameters # Name Type Required Description path string yes The path of the field. It could be a nested or multi-valued field. Returns # sys.data.Wrapper or sys.data.ManyWrapper - A field object that you can use to read and manipulate the value.
Exceptions # badRequest
If path is invalid.
Samples # // logs the value of field 'param1'; only works inside a script of an action that has a 'param1' field sys.logs.info('param1: '+action.field('param1').val()); sys.data.RecordHistoryLogs # This class enables the querying of history logs for a record. It&rsquo;s important to note that the feature to log history must be enabled on the entity to which the record belongs.
find(options) # This method finds history logs based on a specified query.
Parameters # Name Type Required Description options object no This is the query to retrieve history logs. The parameters are as follows:
- eventType: The type of the event. Possible values include: USER_RECORD_CREATED, USER_RECORD_CHANGED, USER_RECORD_DELETED, USER_ACTION_PERFORMED, SCRIPT_RECORD_CREATED, SCRIPT_RECORD_CHANGED, SCRIPT_RECORD_DELETED, SCRIPT_ACTION_PERFORMED, SYSTEM_CASCADE_UPDATE, SYSTEM_REFACTORING. Multiple types can be specified, separated by commas. - from: The minimum timestamp in milliseconds since the Epoch. - to: The maximum timestamp in milliseconds since the Epoch. - size: The maximum number of logs to retrieve. The default value is 20.
- offset: The offset to use when fetching additional logs for pagination. Returns # sys.data.RecordHistoryLog - A field object that you can use to read and manipulate the value.
Exceptions # badRequest
If the query is not valid.
Samples # // finds changes performed by users and logs the user that did it var company = sys.data.findOne('companies', {name: 'Blogpad'}); var historyLogs = company.history().find({ eventType: 'USER_RECORD_CHANGED' }); for (var i = 0; i &lt; historyLogs.length; i++) { var historyLog = historyLogs[i]; log('changed by user: '+historyLog.user()); } createLog() # Returns the create log of the record. It could be null if history log was not enabled when the record was created.
Returns # sys.data.RecordHistoryLog - The create history log or null if not found.
Samples # // prints who created the record var company = sys.data.findOne('companies', {name: 'Blogpad'}); var createLog = company.history().createLog(); if (createLog) { log('creator: '+createLog.user()); } lastModifiedLog() # Returns the last modified log of the record. This value could be null if the history log was not enabled when the record was last modified or if it has not been modified at all. The type of event associated with this log should be USER_RECORD_CHANGE. Consequently, if the record was modified by a script or by a system process, it won&rsquo;t be returned.
Returns # sys.data.RecordHistoryLog - The create history log or null if not found.
Samples # // prints who modified the record for the last time var company = sys.data.findOne('companies', {name: 'Blogpad'}); var modifiedLog = company.history().lastModifiedLog(); if (modifiedLog) { log('user last modified: '+modifiedLog.user()); } sys.data.RecordHistoryLog # Contains information about a history log of a record.
id() # Returns the ID of the history log
Returns # string - ID of the history log
timestamp() # Returns the date in which the history log has been recorded.
Returns # string - The date in which the history log has been recorded.
eventCategory() # Returns the event category of the history log. It could be USER, SCRIPT, or SYSTEM.
Returns # string - The event category of the history log.
eventType() # Returns the event type of the history log. Possible values include: USER_RECORD_CREATED, USER_RECORD_CHANGED, USER_RECORD_DELETED, USER_ACTION_PERFORMED, SCRIPT_RECORD_CREATED, SCRIPT_RECORD_CHANGED, SCRIPT_RECORD_DELETED, SCRIPT_ACTION_PERFORMED, SYSTEM_CASCADE_UPDATE, SYSTEM_REFACTORING
Returns # string - he event type of the history log.
user() # Returns the email of the user that generated the history log.
Returns # string - The email of the user that generated the history log.
ip() # Returns the IP of the user when the history log was generated.
Returns # string - The IP of the user when the history log was generated.
oldRecord() # Returns the old values of the fields that were modified. For each field, it contains both the JSON format and a more human-readable format. Here is a sample:
{ &quot;type&quot;: { &quot;json&quot;: &quot;a&quot;, &quot;text&quot;: &quot;{type:a}&quot; } } Returns # object - The old values of the fields that were modified.
newRecord() # Returns the new values of the fields that were modified. For each field, it contains both the JSON format and a more human-readable format. Here is a sample:
{ &quot;type&quot;: { &quot;json&quot;: &quot;a&quot;, &quot;text&quot;: &quot;{type:a}&quot; } } Returns # object - The new values of the fields that were modified.
sys.data.Query # This class allows you to construct more complex queries with ease. In this section, you&rsquo;ll find information about the methods provided by this class. If you want to learn how to use and write queries, please refer to the documentation on Query Language.
Typically, you will create query objects using the sys.data.createQuery() method instead of directly using the constructor.
field(path) # This method returns a sys.data.QueryField object for the specified field. With this object, you can add filters to the field.
Parameters # Name Type Required Description path string yes The path of the field. It could be a nested or multi-valued field. Returns # sys.data.QueryField - A field object for the given path.
Exceptions # badRequest
If path is invalid.
Samples # // print the name of 10 active companies // create a new sys.data.Query object var query = sys.data.createQuery('companies'); var queryField = query.field('state'); queryField.equals('active'); query.size(10); var records = sys.data.find(query); while (records.hasNext()) { log(records.next().label()); } // this is the same as the sample above, but using a more compact format // create a new sys.data.Query object var query = sys.data.createQuery('companies') .field('state').equals('active') .size(10); var records = sys.data.find(query); while (records.hasNext()) { log(records.next().label()); } size(size) # Sets the maximum number of records to be retrieved.
Parameters # Name Type Required Description size number yes Maximum number of records to be retrieved. Returns # sys.data.Query - The same query object. This is to allow to chain more operations easily.
Exceptions # badRequest
If size is not a number.
Samples # // print the name of 10 companies // create a new sys.data.Query object var query = sys.data.createQuery('companies'); query.size(10); var records = sys.data.find(query); while (records.hasNext()) { log(records.next().label()); } offset(size) # Sets the maximum number of records to be skipped.
Parameters # Name Type Required Description size number yes Maximum number of records to be retrieved. Returns # sys.data.Query - The same query object. This is to allow to chain more operations easily.
Exceptions # badRequest
If size is not a number or string.
Samples # // print the name of 10 companies // create a new sys.data.Query object var query = sys.data.createQuery('companies'); query.size(10); var records = sys.data.find(query); while (records.hasNext()) { log(records.next().label()); } sortBy(sortField, sortType) # Sets the field and direction to sort results.
Parameters # Name Type Required Description sortField string yes The path of the field to be used for sorting. sortType string yes Sort direction. Possible values are asc and desc. Returns # sys.data.Query - The same query object. This is to allow to chain more operations easily.
Exceptions # badRequest
If sortField is not a valid path or sortType is different from asc or desc.
Samples # // print the name of the first 10 companies sorted by name // create a new sys.data.Query object var query = sys.data.createQuery('companies'); query.sortBy('name', 'asc'); var records = sys.data.find(query); while (records.hasNext()) { log(records.next().label()); } includeFields(paths) # Allows to select which fields should be fetched.
Parameters # Name Type Required Description paths string yes The path of the fields that have to be fetched. Returns # sys.data.Query - The same query object. This is to allow to chain more operations easily.
Exceptions # badRequest
If any of the paths provided is not a valid field.
Samples # // only name and email fields will be fetched // create a new sys.data.Query object var query = sys.data.createQuery('companies'); query.includeFields('name', 'type'); var records = sys.data.find(query); while (records.hasNext()) { log(records.next().label()); } globalSearch(value) # This method attempts to match the provided string in any field within the entity, instead of searching in a specific field. Please note that to match a complete sentence, you should enclose it within double quotes. This functionality is only available for entities with global search enabled.
Parameters # Name Type Required Description value string yes The value to search globally. Returns # sys.data.Query - The same query object. This is to allow to chain more operations easily.
Exceptions # badRequest
If value is not a string.
Samples # // finds records where any field has either the word 'lacinia'' or 'erat' // create a new sys.data.Query object var query = sys.data.createQuery('companies'); query.globalSearch('lacinia erat'); var records = sys.data.find(query); while (records.hasNext()) { log(records.next().label()); } query(complexQueryOrFunction) # Allows to specify a complex query where it is possible to mix AND and OR expressions.
Parameters # Name Type Required Description complexQueryOrFunction function or string yes A string representing a complex query or an anonymous function returning a sys.data.ComplexQueryCriteria. Returns # sys.data.Query - The same query object. This is to allow to chain more operations easily.
Exceptions # badRequest
If query is not a string.
Samples # // finds companies with type 'a' or with type 'b' where they are also customers // create a new sys.data.Query object var query = sys.data.createQuery('companies'); query.query(function(q) { return q.or( q.field('type').equals('a'), q.and( q.field('type').equals('b'), q.field('isCustomer').equals(true) ) ); }); var records = sys.data.find(query); log('total: '+records.count()); while (records.hasNext()) { log(records.next().label()); } // same query as above, but using a complex query string instead // create a new sys.data.Query object var query = sys.data.createQuery('companies'); query.query(&quot;or(filter('type','a'),and(filter('type','b'),filter('isCustomer','true')))&quot;); var records = sys.data.find(query); log('total: '+records.count()); while (records.hasNext()) { log(records.next().label()); } sys.data.QueryField # This object is returned by the sys.data.Query.field() method and enables the application of filters to the field.
equals(value) # Adds a filter using equals operator.
Parameters # Name Type Required Description value any yes The value to compare to. Please check the field’s type documentation to see which values are allowed. Returns # sys.data.Query or sys.data.QueryField- Returns the sys.data.Query object to allow chain operations or a sys.data.QueryField in case you are using it in a complex query.
Exceptions # badRequest
If operation is not supported for the field’s type or if the value is not valid for this type. Keep in mind that some invalid values might be detected only once the query is executed.
Samples # // print the name of 10 active companies // create a new sys.data.Query object var query = sys.data.createQuery('companies'); var queryField = query.field('state'); queryField.equals('active'); query.size(10); var records = sys.data.find(query); while (records.hasNext()) { log(records.next().label()); } notEquals(value) # Adds a filter using not equals operator.
Parameters # Name Type Required Description value any yes The value to compare to. Please check the field’s type documentation to see which values are allowed. Returns # sys.data.Query or sys.data.QueryField- Returns the sys.data.Query object to allow chain operations or a sys.data.QueryField in case you are using it in a complex query.
Exceptions # badRequest
If operation is not supported for the field’s type or if the value is not valid for this type. Keep in mind that some invalid values might be detected only once the query is executed.
Samples # // print the name of 10 companies where type is not 'a' // create a new sys.data.Query object var query = sys.data.createQuery('companies'); var queryField = query.field('type'); queryField.notEquals('a'); query.size(10); var records = sys.data.find(query); while (records.hasNext()) { log(records.next().label()); } empty() # Adds a filter using empty operator.
Returns # sys.data.Query or sys.data.QueryField- Returns the sys.data.Query object to allow chain operations or a sys.data.QueryField in case you are using it in a complex query.
Exceptions # badRequest
If operation is not supported for the field’s type or if the value is not valid for this type.
Samples # // print the name of companies where notes are empty // create a new sys.data.Query object var query = sys.data.createQuery('companies'); var queryField = query.field('notes'); queryField.empty(); var records = sys.data.find(query); while (records.hasNext()) { log(records.next().label()); } notEmpty() # Adds a filter using not empty operator.
Returns # sys.data.Query or sys.data.QueryField- Returns the sys.data.Query object to allow chain operations or a sys.data.QueryField in case you are using it in a complex query.
Exceptions # badRequest
If operation is not supported for the field’s type or if the value is not valid for this type.
Samples # // print the name of 10 companies where notes are not empty // create a new sys.data.Query object var query = sys.data.createQuery('companies'); var queryField = query.field('notes'); queryField.notEmpty(); query.size(10); var records = sys.data.find(query); while (records.hasNext()) { log(records.next().label()); } like(value) # Adds a filter using like operator. This filter type has support for regular expressions and also provide shortcuts for filtering by starts with and ends with.
Parameters # Name Type Required Description value any yes The value to compare to. Please check the field’s type documentation to see which values are allowed. Returns # sys.data.Query or sys.data.QueryField- Returns the sys.data.Query object to allow chain operations or a sys.data.QueryField in case you are using it in a complex query.
Exceptions # badRequest
If operation is not supported for the field’s type or if the value is not valid for this type. Keep in mind that some invalid values might be detected only once the query is executed.
Samples # // print the name of companies where name contains 'odo' // create a new sys.data.Query object var query = sys.data.createQuery('companies'); var queryField = query.field('name'); queryField.like('odo'); var records = sys.data.find(query); while (records.hasNext()) { log(records.next().label()); } // print the name of companies where name starts with 't', can have something else in the middle and ends with 'e' using a regular expression // create a new sys.data.Query object var query = sys.data.createQuery('companies'); var queryField = query.field('name'); queryField.like('/^t.*e$/'); var records = sys.data.find(query); while (records.hasNext()) { log(records.next().label()); } // print the name of companies where name starts with 't' using the \`starts with\` shortcut // create a new sys.data.Query object var query = sys.data.createQuery('companies'); var queryField = query.field('name'); queryField.like('/t'); var records = sys.data.find(query); while (records.hasNext()) { log(records.next().label()); } // print the name of companies where name ends with 'e' using the \`ends with\` shortcut // create a new sys.data.Query object var query = sys.data.createQuery('companies'); var queryField = query.field('name'); queryField.like('e/'); var records = sys.data.find(query); while (records.hasNext()) { log(records.next().label()); } greater(value) # Adds a filter using greater operator.
Parameters # Name Type Required Description value any yes The value to compare to. Please check the field’s type documentation to see which values are allowed. Returns # sys.data.Query or sys.data.QueryField- Returns the sys.data.Query object to allow chain operations or a sys.data.QueryField in case you are using it in a complex query.
Exceptions # badRequest
If operation is not supported for the field’s type or if the value is not valid for this type. Keep in mind that some invalid values might be detected only once the query is executed.
Samples # // print the name of companies with more than 500 employees // create a new sys.data.Query object var query = sys.data.createQuery('companies'); var queryField = query.field('numberOfEmployees'); queryField.greater(500); var records = sys.data.find(query); log('total: '+records.count()); while (records.hasNext()) { log(records.next().label()); } greaterOrEquals(value) # Adds a filter using greater or equals operator.
Parameters # Name Type Required Description value any yes The value to compare to. Please check the field’s type documentation to see which values are allowed. Returns # sys.data.Query or sys.data.QueryField- Returns the sys.data.Query object to allow chain operations or a sys.data.QueryField in case you are using it in a complex query.
Exceptions # badRequest
If operation is not supported for the field’s type or if the value is not valid for this type. Keep in mind that some invalid values might be detected only once the query is executed.
Samples # // print the name of companies with more than 500 employees or exactly 500 employees // create a new sys.data.Query object var query = sys.data.createQuery('companies'); var queryField = query.field('numberOfEmployees'); queryField.greaterOrEquals(500); var records = sys.data.find(query); log('total: '+records.count()); while (records.hasNext()) { log(records.next().label()); } less(value) # Adds a filter using less operator.
Parameters # Name Type Required Description value any yes The value to compare to. Please check the field’s type documentation to see which values are allowed. Returns # sys.data.Query or sys.data.QueryField- Returns the sys.data.Query object to allow chain operations or a sys.data.QueryField in case you are using it in a complex query.
Exceptions # badRequest
If operation is not supported for the field’s type or if the value is not valid for this type. Keep in mind that some invalid values might be detected only once the query is executed.
Samples # // print the name of companies with less than 500 employees // create a new sys.data.Query object var query = sys.data.createQuery('companies'); var queryField = query.field('numberOfEmployees'); queryField.less(500); var records = sys.data.find(query); log('total: '+records.count()); while (records.hasNext()) { log(records.next().label()); } lessOrEquals(value) # Adds a filter using less or equals operator.
Parameters # Name Type Required Description value any yes The value to compare to. Please check the field’s type documentation to see which values are allowed. Returns # sys.data.Query or sys.data.QueryField- Returns the sys.data.Query object to allow chain operations or a sys.data.QueryField in case you are using it in a complex query.
Exceptions # badRequest
If operation is not supported for the field’s type or if the value is not valid for this type. Keep in mind that some invalid values might be detected only once the query is executed.
Samples # // print the name of companies with less than 500 employees or exactly 500 employees // create a new sys.data.Query object var query = sys.data.createQuery('companies'); var queryField = query.field('numberOfEmployees'); queryField.lessOrEquals(500); var records = sys.data.find(query); log('total: '+records.count()); while (records.hasNext()) { log(records.next().label()); } between(from, to) # Adds a filter using between operator.
Parameters # Name Type Required Description from any yes The minimum value to match (inclusive). to any yes The maximum value to match (inclusive). Returns # sys.data.Query or sys.data.QueryField- Returns the sys.data.Query object to allow chain operations or a sys.data.QueryField in case you are using it in a complex query.
Exceptions # badRequest
If operation is not supported for the field’s type or if the value is not valid for this type. Keep in mind that some invalid values might be detected only once the query is executed.
Samples # // print the name of companies with a number of employees between 300 and 600 (inclusive) // create a new sys.data.Query object var query = sys.data.createQuery('companies'); var queryField = query.field('numberOfEmployees'); queryField.between(300, 600); var records = sys.data.find(query); log('total: '+records.count()); while (records.hasNext()) { log(records.next().label()); } sys.data.ComplexQueryHelper # This object is passed as a parameter to the function within the sys.data.Query.query() method and aids in the construction of complex queries involving AND and OR operators.
field(path) # This method returns a sys.data.QueryField object for the specified field. With this object, you can add filters to the field.
Parameters # Name Type Required Description path string yes The path of the field. It could be a nested or multi-valued field. Returns # sys.data.QueryField - A query field object for the given path.
Exceptions # badRequest
If path is invalid.
Samples # // print the name of 10 companies of type 'a' var query = sys.data.createQuery('companies') .query(function(q) { // 'q' is an object of type sys.data.QueryComplexHelper return q.and( q.field('type').equals('a') ); }) .size(10); var records = sys.data.find(query); log('total: '+records.count()); while (records.hasNext()) { log(records.next().label()); } and(conditions) # Returns a sys.data.ComplexQueryCriteria object to do an AND with the given parameters.
Parameters # Name Type Required Description conditions sys.data.QueryField or sys.data.ComplexQueryCriteria yes Any number of query fields or other complex query criteria (like an OR) that will be evaluated using the AND operator. Returns # sys.data.ComplexQueryCriteria - A complex query criteria object with an AND between all parameters.
Exceptions # badRequest
If parameters sent to the AND operator are invalid.
Samples # // print the companies where tyep is 'a' or where type is 'b' and are customers var query = sys.data.createQuery('companies') .query(function(q) { // 'q' is an object of type sys.data.QueryComplexHelper return q.or( q.field('type').equals('a'), q.and( q.field('type').equals('b'), q.field('isCustomer').equals(true) ) ); }); var records = sys.data.find(query); log('total: '+records.count()); while (records.hasNext()) { log(records.next().label()); } or(conditions) # Returns a sys.data.ComplexQueryCriteria object to do an OR with the given parameters.
Parameters # Name Type Required Description conditions sys.data.QueryField or sys.data.ComplexQueryCriteria yes Any number of query fields or other complex query criteria (like an AND) that will be evaluated using the OR operator. Returns # sys.data.ComplexQueryCriteria - A complex query criteria object with an OR between all parameters.
Exceptions # badRequest
If parameters sent to the OR operator are invalid.
Samples # // print the companies where tyep is 'a' or where type is 'b' and are customers var query = sys.data.createQuery('companies') .query(function(q) { // 'q' is an object of type sys.data.QueryComplexHelper return q.or( q.field('type').equals('a'), q.and( q.field('type').equals('b'), q.field('isCustomer').equals(true) ) ); }); var records = sys.data.find(query); log('total: '+records.count()); while (records.hasNext()) { log(records.next().label()); } sys.data.ComplexQueryCriteria # This object is returned by the method in sys.data.ComplexQueryHelper. You should avoid using this object directly. For more information, please refer to the documentation on Complex Queries.
toString() # This method returns the string version of the complex query.
Returns # string - The string version of the complex query
sys.data.AggregateQuery # This class facilitates the construction of aggregate queries. In this section, you&rsquo;ll find information about the methods provided by this class. If you want to learn how to use and write aggregate queries, please consult the documentation on Aggregate Queries.
Typically, you will create query objects using the sys.data.createAggregateQuery() method instead of directly using the constructor.
group() # This method adds a sys.data.AggregatedGroup operation to the aggregate query.
Returns # sys.data.AggregatedGroup - The group object added to the aggregate query.
match() # This method adds a sys.data.AggregatedMatch operation to the aggregate query.
Returns # sys.data.AggregatedMatch - The match object added to the aggregate query.
sort() # This method adds a sys.data.AggregatedSort operation to the aggregate query.
Returns # sys.data.AggregatedSort - The sort object added to the aggregate query.
project() # This method adds a sys.data.AggregatedProject operation to the aggregate query.
Returns # sys.data.AggregatedProject - The project object added to the aggregate query.
count() # This method adds a sys.data.AggregatedCount operation to the aggregate query.
Returns # sys.data.AggregatedCount - The count object added to the aggregate query.
skip() # This method adds a sys.data.AggregatedSkip operation to the aggregate query.
Returns # sys.data.AggregatedSkip - The skip object added to the aggregate query.
limit() # This method adds a sys.data.AggregatedLimit operation to the aggregate query.
Returns # sys.data.AggregatedLimit - The limit object added to the aggregate query.
unwind() # This method adds a sys.data.AggregatedUnwind operation to the aggregate query.
Returns # sys.data.AggregatedUnwind - The unwind object added to the aggregate query.
lookup() # This method adds a sys.data.AggregatedLookup operation to the aggregate query.
Returns # sys.data.AggregatedLookup - The lookup object added to the aggregate query.
sys.data.AggregatedGroup # This class allows you to define a group operation in an aggregate query. You should avoid creating an object of this class manually. Instead, use the sys.data.AggregateQuery.group() method.
by(paths) # Indicates which fields will be used to group by.
Parameters # Name Type Required Description paths string&hellip; yes The path of the fields used for grouping. Returns # sys.data.AggregatedGroup - The group object so you can chain more operations.
Exceptions # badRequest
If any of the paths is invalid.
accumulate(path) # Allows to apply an operation for the values in the group for a given field. For example, sum all values in the group or calculate the average.
Parameters # Name Type Required Description path string yes The path of the field to apply the operation to Returns # sys.data.AggregateAccumulator - The accumulator object to configure the operation to perform.
Exceptions # badRequest
If the path is invalid.
Samples # // var query = sys.data.createAggregateQuery('contacts'); query.group() .by('company') .accumulate('totalSkills').sum('numberOfSkills'); var resultSet = sys.data.aggregate(query); while (resultSet.hasNext()) { log(JSON.stringify(resultSet.next())); } sys.data.AggregatedSort # Allows to sort elements in an aggregate query. You should never create an object of this class manually. Instead use sys.data.AggregateQuery.sort() method.
by(path, sortType) # Indicates which field will be used to sort and the direction of the sorting.
Parameters # Name Type Required Description path string yes The path of the field used for sorting. sortType string yes The direction of the sorting. Can be asc or desc. Returns # sys.data.AggregatedSort - The sort object so you can chain more operations.
Exceptions # badRequest
If the path or direction are invalid.
sys.data.AggregatedProject # Allows to filter fields in elements in an aggregate query. You should never create an object of this class manually. Instead use sys.data.AggregateQuery.project() method.
field(path) # Indicates that the given field should be included in the result.
Parameters # Name Type Required Description path string yes The path of the field to include in the results. Returns # sys.data.AggregatedProject - The project object so you can chain more operations.
Exceptions # badRequest
If the path is invalid.
sys.data.AggregatedMatch # Allows to filter fields in elements in an aggregate query. You should never create an object of this class manually. Instead use sys.data.AggregateQuery.match() method.
field(path) # Indicates that the given field should be included in the result.
Parameters # Name Type Required Description path string yes The path of the field to apply a filter to. Returns # sys.data.QueryField - The match object so you can apply filters on that field.
Exceptions # badRequest
If the path is invalid.
sys.data.AggregateAccumulator # Allows to define accumulation operations for groups created using sys.data.AggregatedGroup like sum, average, etc.
sum(path) # Sums all the numeric values in the group for the given field.
Parameters # Name Type Required Description path string yes The path of the field to sum up Returns # sys.data.AggregatedGroup - The group object so you can chain more operations.
Exceptions # badRequest
If the path is invalid.
count() # Counts the number of elements in the group.
Returns # sys.data.AggregatedGroup - The group object so you can chain more operations.
avg(path) # Calculates the average of all the numeric values in the group for the given field.
Parameters # Name Type Required Description path string yes The path of the field to calculate average Returns # sys.data.AggregatedGroup - The group object so you can chain more operations.
Exceptions # badRequest
If the path is invalid or not a numeric field.
first(path) # Selects the value of the first element in the group for the given field.
Parameters # Name Type Required Description path string yes The path of the field to select its value Returns # sys.data.AggregatedGroup - The group object so you can chain more operations.
Exceptions # badRequest
If the path is invalid or not a numeric field.
last(path) # Selects the value of the last element in the group for the given field.
Parameters # Name Type Required Description path string yes The path of the field to select its value Returns # sys.data.AggregatedGroup - The group object so you can chain more operations.
Exceptions # badRequest
If the path is invalid or not a numeric field.
min(path) # Selects the minimum value in the group for the given field.
Parameters # Name Type Required Description path string yes The path of the field to select its minimum value Returns # sys.data.AggregatedGroup - The group object so you can chain more operations.
Exceptions # badRequest
If the path is invalid or not a numeric field.
max(path) # Selects the maximum value in the group for the given field.
Parameters # Name Type Required Description path string yes The path of the field to select its maximum value Returns # sys.data.AggregatedGroup - The group object so you can chain more operations.
Exceptions # badRequest
If the path is invalid or not a numeric field.
sys.data.AggregatedCount # Allows to count elements in an aggregate query. You should never create an object of this class manually. Instead use sys.data.AggregateQuery.count() method.
counterName(fieldName) # Indicates that the given string should be the name of attribute under counter will be stored.
Parameters # Name Type Required Description fieldName string yes The name of field that will store the counter. Returns # sys.data.AggregatedCount - The count object so you can chain more operations.
Exceptions # badRequest
If the fieldName is invalid.
sys.data.AggregatedLimit # Allows to limit the number of elements in an aggregate query. You should never create an object of this class manually. Instead use sys.data.AggregateQuery.limit() method.
step(number) # Indicates that first step number of elements will be retrieved.
Parameters # Name Type Required Description number string yes The positive interger number of records to ommit. Returns # sys.data.AggregatedLimit - The limit object so you can chain more operations.
Exceptions # badRequest
If the number is invalid.
sys.data.AggregatedSkip # Allows to skip elements in an aggregate query. You should never create an object of this class manually. Instead use sys.data.AggregateQuery.skip() method.
step(number) # Indicates that first step number of elements will be retrieved.
Parameters # Name Type Required Description number string yes The positive interger number of records to ommit. Returns # sys.data.AggregatedSkip - The skip object so you can chain more operations.
Exceptions # badRequest
If the number is invalid.
sys.data.AggregatedUnwind # Allows to unwind elements with array attributes in more elements with single attributes in an aggregate query. You should never create an object of this class manually. Instead use sys.data.AggregateQuery.unwind() method.
path(fieldPath) # Indicates selected attribute will be unwound in single elements retrieving one document by every item in array value.
Parameters # Name Type Required Description fieldPath string yes Field in record to be unwound. Returns # sys.data.AggregatedUnwind - The unwind object so you can chain more operations.
Exceptions # badRequest
If the fieldPath is invalid.
includeEmpty(includeEmpty) # Indicates that elements with selected attribute equals to empty array or null will be included.
Parameters # Name Type Required Description includeEmpty boolean no if true includes records for empty arrays, nulls or not multivalued fields. Returns # sys.data.AggregatedUnwind - The unwind object so you can chain more operations.
sys.data.AggregatedLookup # Allows to lookup elements with other collections elemtents making an equivalent SQL left join. You should never create an object of this class manually. Instead use sys.data.AggregateQuery.lookup() method.
localField(fieldPath) # Indicates selected attribute from current entity elements that will be matched with foreign elements.
Parameters # Name Type Required Description fieldPath string yes Field into current entity used as local field. Returns # sys.data.AggregatedLookup - The lookup object so you can chain more operations.
Exceptions # badRequest
If the fieldPath is invalid.
foreignField(fieldPath) # Indicates selected attribute from foreign entity elements that will be matched with current elements.
Parameters # Name Type Required Description fieldPath string yes Field into foreign entity used as foreign field. Returns # sys.data.AggregatedLookup - The lookup object so you can chain more operations.
Exceptions # badRequest
If the fieldPath is invalid.
foreignEntity(entityName) # Indicates the foreign entity name whose elements will be matched.
Parameters # Name Type Required Description entityName string yes Name of an existing entity. Returns # sys.data.AggregatedLookup - The lookup object so you can chain more operations.
Exceptions # badRequest
If the fieldPath is invalid.
`}),e.add({id:104,href:"/dev-reference/scripting/sys-endpoints/",title:"sys.endpoints",description:`sys.endpoints # The sys.endpoints package comprises methods designed to manage legacy services.
findById() # This method locates an endpoint using its unique ID.
Parameters # Name Type Required Description id string yes ID of the endpoint Returns # sys.endpoints.Endpoint - The endpoint object or null if not found.
Exceptions # badRequest
If id is not a valid ID or it is empty.
Samples # // finds an endpoint and prints its status var endpoint = sys.`,content:`sys.endpoints # The sys.endpoints package comprises methods designed to manage legacy services.
findById() # This method locates an endpoint using its unique ID.
Parameters # Name Type Required Description id string yes ID of the endpoint Returns # sys.endpoints.Endpoint - The endpoint object or null if not found.
Exceptions # badRequest
If id is not a valid ID or it is empty.
Samples # // finds an endpoint and prints its status var endpoint = sys.endpoints.findById(''); log('status: '+endpoint.status()); findByName(name) # This method locates an endpoint using its name.
Parameters # Name Type Required Description name string yes Name of the endpoint Returns # sys.endpoints.Endpoint - The endpoint object or null if not found.
Exceptions # badRequest
If name it is empty.
Samples # // finds an endpoint and prints its status var endpoint = sys.endpoints.findByName('sample'); log('status: '+endpoint.status()); isDeployed(name) # Checks if an endpoint is deployed.
Parameters # Name Type Required Description name string yes Name of the endpoint Returns # boolean - true if the endpoint is deployed, false otherwise.
Exceptions # badRequest
If name it is empty or endpoint is not found with that name.
Samples # // prints if the endpoint is deployed log('endpoint deployed: '+sys.endpoints.isDeployed('sample')); sys.endpoints.Endpoint # Contains information about an endpoint.
id() # Returns the ID of the endpoint.
Returns # string - The ID of the endpoint
label() # Returns the label of the endpoint.
Returns # string - The label of the endpoint
name() # Returns the name of the endpoint.
Returns # string - The name of the endpoint
type() # Returns the type of the endpoint.
Returns # string - The type of the endpoint
status() # Returns the current status of the endpoint. Possible values are DEPLOYED, UNDEPLOYED, DEPLOYING, UNDEPLOYING, UNKNOWN.
Returns # string - The current status of the endpoint.
version() # Returns the current version of the running endpoint.
Returns # string - The current version of the endpoint.
`}),e.add({id:105,href:"/dev-reference/scripting/sys-events/",title:"sys.events",description:`sys.events # The sys.events package encompasses methods intended for the administration of custom events.
triggerEvent(event,data) # This method initiates a custom event within the application, which can be captured by any listener set up to monitor a CUSTOM_EVENT with a name matching the event parameter.
Parameters # Name Type Required Description event string yes The name of dispatched custom event. data object no Map of properties that will be sent as data of event.`,content:"sys.events # The sys.events package encompasses methods intended for the administration of custom events.\ntriggerEvent(event,data) # This method initiates a custom event within the application, which can be captured by any listener set up to monitor a CUSTOM_EVENT with a name matching the event parameter.\nParameters # Name Type Required Description event string yes The name of dispatched custom event. data object no Map of properties that will be sent as data of event. Samples # // trigger `newNote` event with id of record sys.events.triggerEvent('newNote', {noteId: record.id()}); "}),e.add({id:106,href:"/dev-reference/scripting/sys-exceptions/",title:"sys.exceptions",description:`sys.exceptions # The sys.exceptions package comprises methods tailored for handling exceptions.
getCode(exception) # This method retrieves the error code when the provided parameter is of the type sys.exceptions.ScriptException. If the parameter is of a different type, it returns null.
The benefit of utilizing this method over directly invoking sys.exceptions.ScriptException.code() is that you are relieved from the concern of whether the exception is a platform-specific one or belongs to another category. In scenarios where the exception type is not certain, it&rsquo;s advisable to first verify if it&rsquo;s a platform exception prior to retrieving the code.`,content:`sys.exceptions # The sys.exceptions package comprises methods tailored for handling exceptions.
getCode(exception) # This method retrieves the error code when the provided parameter is of the type sys.exceptions.ScriptException. If the parameter is of a different type, it returns null.
The benefit of utilizing this method over directly invoking sys.exceptions.ScriptException.code() is that you are relieved from the concern of whether the exception is a platform-specific one or belongs to another category. In scenarios where the exception type is not certain, it&rsquo;s advisable to first verify if it&rsquo;s a platform exception prior to retrieving the code.
Parameters # Name Type Required Description exception sys.exceptions.ScriptException or Error yes The platform exception to get the code from or any other kind of throwable object. Returns # string - The code of the exception or null.
Samples # // logs the code of a platform exception try { var query = sys.data.createQuery('entityThatDoesNotExist'); } catch (e) { log('error code: '+sys.exceptions.getCode(e)); } // when it is a Javascript exception it will return 'null' try { // this var doesn't exist an will throw a Javascript error var a = doesNotExist * 5; } catch (e) { log('error code: '+sys.exceptions.getCode(e)); } getMessage(exception) # This method retrieves the error message from the given exception. If the parameter is a string, the method returns that string. If the parameter is of type sys.exceptions.ScriptException, it returns the contained message. In the case of an object, the method provides its JSON representation. If none of these cases apply, the parameter is attempted to be cast to a string.
The key advantage of utilizing this method, as opposed to directly invoking sys.exceptions.ScriptException.message(), is that you need not be concerned about whether the exception is a platform-specific one or belongs to another category. When the exception type is uncertain, it&rsquo;s advisable to first confirm whether it&rsquo;s a platform exception before retrieving the message.
Parameters # Name Type Required Description exception sys.exceptions.ScriptException or Error yes The platform exception to get the message from or any other kind of throwable object. Returns # string|object - The message of the exception, a JSON object or just the string representation.
Samples # // logs the message of a platform exception try { var query = sys.data.createQuery('entityThatDoesNotExist'); } catch (e) { log('error message: '+sys.exceptions.getMessage(e)); } // logs the message of a Javascript exception try { // this var doesn't exist an will throw a Javascript error var a = doesNotExist * 5; } catch (e) { log('error message: '+sys.exceptions.getMessage(e)); } getAdditionalInfo(exception) # This method returns an object containing supplementary information about the error, if such information is available. It&rsquo;s important to note that this feature is not accessible across all exceptions, but rather applies to a select few. For instance, certain endpoint exceptions might include details about the specific request that encountered failure.
Parameters # Name Type Required Description exception sys.exceptions.ScriptException or Error yes The platform exception from which to extract additional information. While you can pass other throwable objects, please note that in such cases, there will be no additional information available, and the method will simply return an empty object. Returns # string|object - An object containing the additional information. This object will be empty if there is no additional information available.
Samples # // logs the message of a platform exception try { app.endpoints.http.post(params); } catch (e) { log('error additional info: '+sys.exceptions.getAdditionalInfo(e)); } throwException(code,message) # Throws an exception with the specified code and message. The primary advantage of using this method, as opposed to the standard JavaScript throw keyword, is that if the thrown exception is caught and logged, the stack trace will be accessible. Unlike the typical throw keyword, which does not offer the stack trace in cases where logging the exception is necessary.
It is recommended to consistently use this method over the throw keyword.
Parameters # Name Type Required Description code string yes A code that identifies the exception. Any appropriate code can be used. message string yes The error message. If displayed to users, consider internationalizing this message. Samples # // throws an exception if the state is not 'new' if (record.field('state').val() != 'new') { sys.exceptions.throwException('invalidState', 'Task must be in state new'); } sys.exceptions.ScriptException # This type of object is thrown when errors occur within the platform or when dealing with known errors in scripts (such as validation scripts). Instances of this type contain an error code and a message.
code() # This method retrieves the error code associated with the exception. The valid error codes include:
validationErrors badRequest forbidden optimisticLocking timeout systemException unknownError Returns # string - The error code
Samples # // logs the code of a platform exception try { var query = sys.data.createQuery('entityThatDoesNotExist'); } catch (e) { log('error code: '+e.code()); } message() # Returns the error message.
Returns # string - The error message
Samples # // logs the message of a platform exception try { var query = sys.data.createQuery('entityThatDoesNotExist'); } catch (e) { log('error message: '+e.message()); } throw() # This method throws an exception using the throwException() method, with the code and message values from this object.
Samples # // creates an exception and throw it if (record.field('state').val() != 'new') { var exception = new sys.exceptions.ScriptException('invalidState', 'Task must be in state new'); exception.throw(); } `}),e.add({id:107,href:"/dev-reference/scripting/sys-files/",title:"sys.files",description:`sys.files # This package contains methods for reading and writing text files.
open(fileId, fileType, options) # Opens a file as a stream. If the file to be read is of type text/csv, a CSV handler will be returned to handle it appropriately.
Parameters # Name Type Required Description fileId string yes ID of the file to be read. fileType string no Text based content type of the file. Some valid types are: - text/plain - text/csv - text/richtext`,content:`sys.files # This package contains methods for reading and writing text files.
open(fileId, fileType, options) # Opens a file as a stream. If the file to be read is of type text/csv, a CSV handler will be returned to handle it appropriately.
Parameters # Name Type Required Description fileId string yes ID of the file to be read. fileType string no Text based content type of the file. Some valid types are: - text/plain - text/csv - text/richtext
- text/html options object no Configuration options to open the file. For text/csv the following options are available: - separator: the delimiter to use for separating entries. - quoteChar: the character to use for quoted elements. - hasHeaders: if the file to be opened contains headers. Returns # sys.files.FileReader|sys.files.CsvFileReader - The reader to read the file.
Exceptions # badRequest
If any of the parameter is invalid.
notFound
If no file found with the given ID.
unknown
If there are problems opening the file.
Samples # // reads a text file and prints the content var record = sys.data.findOne('files', {code: 'test'}); var fileId = record.field('file').id(); var fileReader = sys.files.open(fileId, 'text/plain'); try { var line; while (line = fileReader.readLine()) { log(line); } } finally { fileReader.close(); } create(fileId, fileType) # Opens a new file stream for writing. If the file to be written is of type text/csv, a proper CSV handler will be returned to handle it appropriately.
Parameters # Name Type Required Description fileId string yes ID of the file to be created. fileType string no Text based content type of the file. Some valid types are: - text/plain - text/csv - text/richtext
- text/html Returns # sys.files.FileReader|sys.files.CsvFileReader - The reader to read the file.
Exceptions # badRequest
If fileName or fileType are invalid.
unknown
If there are problems creating the file.
Samples # // write a text file var fileWriter = sys.files.create('test1.txt', 'text/plain'); try { fileWriter.writeLine('test file!'); } finally { fileWriter.close(); } // now assocaite the file to a record var record = sys.data.findOne('files', {code: 'temporary-file'}); if (!record) { record = sys.data.createRecord('files'); record.field('code').val('temporary-file'); } record.field('file').val({ id: fileWriter.descriptor().id(), name: fileWriter.descriptor().name() }); sys.data.save(record); log('file record saved!'); // write a CSV file var fileWriter = sys.files.create('test2.csv', 'text/csv'); try { fileWriter.writeHeaders(['name', 'email']); fileWriter.writeRow(['john', 'john@test.com']); fileWriter.writeRow(['adam', 'adam@test.com']); } finally { fileWriter.close(); } // now assocaite the file to a record var record = sys.data.findOne('files', {code: 'temporary-csv-file'}); if (!record) { record = sys.data.createRecord('files'); record.field('code').val('temporary-csv-file'); } record.field('file').val({ id: fileWriter.descriptor().id(), name: fileWriter.descriptor().name() }); sys.data.save(record); log('file record saved!'); share(fileId, ttl) # Shares a file by returning a public URL for it. This link is valid for an hour.
Parameters # Name Type Required Default Description fileId string yes - ID of the file to be read. ttl number no 3600000 (1 hour) Time in milliseconds to expire. Exceptions # badRequest
If fileId is invalid or ttl is not a number.
notFound
If no file found with the given ID.
Samples # // prints a public URL for a file var record = sys.data.findOne('files', {code: 'test'}); var publicUrl = sys.files.share(record.field('file').id()); log(publicUrl); // prints a public URL for a file with expiration equals to a minute var record = sys.data.findOne('files', {code: 'test'}); var publicUrl = sys.files.share(record.field('file').id(), 60000); log(publicUrl); unshare(fileId) # Stops sharing a file that was shared before.
Parameters # Name Type Required Description fileId string yes ID of the file to unshare. Returns # string - The public URL for the file which is valid for the ttl set or an hour.
Exceptions # badRequest
If fileId is invalid.
notFound
If no file found with the given ID.
Samples # // prints a public URL for a file sys.files.unshare(record.field('file').id()); sys.files.FileReader # This class allows you to read a text file line by line. The file must be stored in the app.
descriptor() # Returns the metadata information of the opened file.
Returns # sys.files.FileDescriptor - The file descriptor of the opened file.
Samples # // opens a file and logs the name of the file from the descriptor var record = sys.data.findOne('files', {code: 'test'}); var fileId = record.field('file').id(); var fileReader = sys.files.open(record.field('file').id(), 'text/plain'); try { var descriptor = fileReader.descriptor(); log('file name: '+descriptor.name()); } finally { fileReader.close(); } readLine() # Reads the next line of the the opened file. If there isn’t any more data, it returns null.
Returns # string - Line of text or null if no more data.
Exceptions # unknown
If there are problems reading the file.
Samples # // reads a text file and prints the content var record = sys.data.findOne('files', {code: 'test'}); var fileId = record.field('file').id(); var fileReader = sys.files.open(fileId, 'text/plain'); try { var line; while (line = fileReader.readLine()) { log(line); } } finally { fileReader.close(); } close() # Closes this file stream and releases any system resources associated with the stream.
Exceptions # unknown
If there are errors closing the file.
Samples # // close the file after reading it var record = sys.data.findOne('files', {code: 'test'}); var fileId = record.field('file').id(); var fileReader = sys.files.open(fileId, 'text/plain'); try { var line; while (line = fileReader.readLine()) { log(line); } } finally { fileReader.close(); } sys.files.FileWriter # This class allows you to write a text file line by line. The file will be stored in the app.
descriptor() # Returns the metadata information of the opened file.
Returns # sys.files.FileDescriptor - The file descriptor of the opened file.
Samples # // creates a new file and logs the id, name, type and size var fileWriter = sys.files.create('test1.txt', 'text/plain'); try { fileWriter.writeLine('test file!'); } finally { fileWriter.close(); } var descriptor = fileWriter.descriptor(); log('id: '+descriptor.id()); log('name: '+descriptor.name()); log('type: '+descriptor.type()); log('size: '+descriptor.size()); writeLine(line) # Appends a new line to the file.
Parameters # Name Type Required Description line string yes The text to write to the file. Exceptions # unknown
If there are problems writing to the file.
Samples # // writes a few lines in a file var fileWriter = sys.files.create('test1.txt', 'text/plain'); try { fileWriter.writeLine('line 1'); fileWriter.writeLine('line 2'); fileWriter.writeLine('line 3'); } finally { fileWriter.close(); } log('id: '+fileWriter.descriptor().id()); close() # Closes this file stream and releases any system resources associated with the stream.
Exceptions # unknown
If there are errors closing the file.
Samples # // close the file after writing it var fileWriter = sys.files.create('test1.txt', 'text/plain'); try { fileWriter.writeLine('test file!'); } finally { fileWriter.close(); } sys.files.CsvFileReader # This class allows you to read a CSV file row by row. An object of this type will be returned by the sys.files.open() method when the type is text/csv.
This class inherits all methods from sys.files.FileReader.
readHeaders() # Returns the headers of the CSV file.
You don’t need to call this method before reading rows; it will be done automatically when the CSV file is opened. This method simply returns the headers that were read at that time.
Returns # string[] - An array containing the headers of the CSV file.
Samples # // reads a text file and prints the content var record = sys.data.findOne('files', {code: 'test-companies'}); var fileReader = sys.files.open(record.field('file').id(), 'text/csv'); try { var headers = fileReader.readHeaders(); log('headers: '+JSON.stringify(headers)); } finally { fileReader.close(); } readRow() # Returns the values of the next row in an array.
Returns # string[] - An array with the values of the row.
Samples # // reads a text file and prints the content var record = sys.data.findOne('files', {code: 'test-companies'}); var fileReader = sys.files.open(record.field('file').id(), 'text/csv'); var count = 1, row; try { var headers = fileReader.readHeaders(); log('headers: '+JSON.stringify(headers)); while (row = fileReader.readRow()) { log('row '+count+': '+JSON.stringify(row)); } } finally { fileReader.close(); } readRowMap() # Returns the values of the next row in a map using the headers as the key.
Returns # object - A map with the values of the row using the headers as keys
Samples # // reads a text file and prints the content var record = sys.data.findOne('files', {code: 'test-companies'}); var fileReader = sys.files.open(record.field('file').id(), 'text/csv'); var count = 1, row; try { while (row = fileReader.readRowMap()) { log('row '+count+': '+JSON.stringify(row)); } } finally { fileReader.close(); } readRowStr() # Returns the values of the next row as a string.
Returns # string - A string with the row values.
Samples # // reads a text file and prints the content var record = sys.data.findOne('files', {code: 'test-companies'}); var fileReader = sys.files.open(record.field('file').id(), 'text/csv'); var count = 1, row; try { var headers = fileReader.readHeaders(); log('headers: '+JSON.stringify(headers)); while (row = fileReader.readRowStr()) { log('row '+count+': '+row); } } finally { fileReader.close(); } sys.files.CsvFileWriter # This class allows you to write a CSV file row by row. An object of this type will be returned by the sys.files.create method when the type is text/csv.
This class inherits all methods from sys.files.FileWriter.
writeHeaders(headers) # Writes the headers of the CSV file.
You should call this method before writing rows. If you start writing rows without explicitly setting the headers, the first row will be considered as the headers.
Parameters # Name Type Required Description headers string[] yes An array of strings with the headers. Samples # // writes headers and rows for a CSV file var fileWriter = sys.files.create('test2.csv', 'text/csv'); try { fileWriter.writeHeaders(['name', 'email']); fileWriter.writeRow(['john', 'john@test.com']); fileWriter.writeRow(['adam', 'adam@test.com']); } finally { fileWriter.close(); } log('id: '+fileWriter.descriptor().id()); writeRow(row) # Appends a row the the CSV file.
Parameters # Name Type Required Description row string[] yes An array with the values of the row. You should use the same order as headers. Samples # // writes headers and rows for a CSV file var fileWriter = sys.files.create('test2.csv', 'text/csv'); try { fileWriter.writeHeaders(['name', 'email']); fileWriter.writeRow(['john', 'john@test.com']); fileWriter.writeRow(['adam', 'adam@test.com']); } finally { fileWriter.close(); } log('id: '+fileWriter.descriptor().id()); writeRowMap(row) # Appends a row to the CSV file from a map. It will take care of the positioning of values in the row automatically based on the headers.
Parameters # Name Type Required Description row object yes A map with the row values. Keys should be the headers. Samples # // writes headers and rows for a CSV file var fileWriter = sys.files.create('test2.csv', 'text/csv'); try { fileWriter.writeHeaders(['name', 'email']); fileWriter.writeRowMap({name: 'john', email: 'john@test.com'}); fileWriter.writeRowMap({name: 'adam', email: 'adam@test.com'}); } finally { fileWriter.close(); } log('id: '+fileWriter.descriptor().id()); writeRowStr(row) # Appends a row to the CSV file from a plain string. The string will be appended as it is, without any processing.
Parameters # Name Type Required Description row string yes The row to append to the CSV file. Samples # // writes headers and rows for a CSV file var fileWriter = sys.files.create('test2.csv', 'text/csv'); try { fileWriter.writeHeaders(['name', 'email']); fileWriter.writeRowStr('john,john@test.com'); fileWriter.writeRowStr('adam,adam@test.com'); } finally { fileWriter.close(); } log('id: '+fileWriter.descriptor().id()); sys.files.FileDescriptor # Handles metadata of the file.
id() # Returns # string - The ID of the file within the app.
name() # Returns # string - The name of the file.
hash() # Returns # string - The hash code of the file.
type() # Returns # string - The content type of the file. Some valid types include:
text/plain text/csv text/richtext text/html size() # Returns # string - The size of the file in bytes.
`}),e.add({id:108,href:"/dev-reference/scripting/sys-i18n/",title:"sys.i18n",description:`sys.i18n # The sys.i18n package provides methods for working with internationalization. These objects are stored as metadata using the builder.
translate(key,params) # This method returns the translated value for the provided key.
Parameters # Name Type Required Description event string yes he key corresponding to the desired translation. data object no A map of properties that will be sent as the data of the event. Returns # string - The translated value for the provided key in the language of the current user, platform language, or English.`,content:`sys.i18n # The sys.i18n package provides methods for working with internationalization. These objects are stored as metadata using the builder.
translate(key,params) # This method returns the translated value for the provided key.
Parameters # Name Type Required Description event string yes he key corresponding to the desired translation. data object no A map of properties that will be sent as the data of the event. Returns # string - The translated value for the provided key in the language of the current user, platform language, or English. If the key does not exist, it will return an empty string.
Samples # // gets a translation for a key var resolved = sys.i18n.translate('key1'); log('key1: '+resolved); // gets a translation for a key //key2 could be &quot;There are {{ numberOfItems }} in {{collName}}&quot; var resolved = sys.i18n.translate('key2'. {numberOfItems: 5, collName:'entities'}); log('key2: '+resolved); `}),e.add({id:109,href:"/dev-reference/scripting/sys-jobs/",title:"sys.jobs",description:`sys.jobs # The sys.jobs package contains a set of methods to manage and handle background jobs within the system.
findById(id) # Finds a background job by its unique identifier (ID).
Parameters # Name Type Required Description id string yes ID of the job. Returns # sys.jobs.Job - The job object or null if not found.
Exceptions # badRequest
This exception is raised if id provided is invalid.
Samples # // executes an action in the background and finds the job for it var jobId = sys.`,content:`sys.jobs # The sys.jobs package contains a set of methods to manage and handle background jobs within the system.
findById(id) # Finds a background job by its unique identifier (ID).
Parameters # Name Type Required Description id string yes ID of the job. Returns # sys.jobs.Job - The job object or null if not found.
Exceptions # badRequest
This exception is raised if id provided is invalid.
Samples # // executes an action in the background and finds the job for it var jobId = sys.data.executeAction('companies', {type: 'a'}, 'logSomething', {param1: 'a', param2: 'b'}); var job = sys.jobs.findById(jobId); log('job: '+job.name()); find(query) # Finds jobs using a query. A query looks like this:
var query = {}; query['status'] = 'FINISHED'; query['_size'] = 50; Parameters # Name Type Required Description query object yes The query to filter jobs. When working with job handling methods, you can use the following parameters for filtering and retrieving specific jobs:
type (string, multiple values allowed): Specifies the type of job. You can specify multiple types separated by commas. The valid job types you can use in your code are:
IMPORT_RECORDS EXPORT_RECORDS EXECUTE_ACTION DELETE_RECORDS EXECUTE_LISTENER IMPORT_USERS EXPORT_USERS STOP_APP START_APP DEPLOY_ENDPOINT UNDEPLOY_ENDPOINT status (string, multiple values allowed): Indicates the status of the job. You can specify multiple statuses separated by commas. Valid status values include:
PENDING RUNNING FINISHED STOPPING STOPPED CANCELED startFrom (timestamp in milliseconds): Filters jobs based on the date they started. You can use it in combination with startTo to specify a date range or use it alone to filter jobs started on or after the specified date.
startTo (timestamp in milliseconds): Filters jobs based on the date they started. You can use it in combination with startFrom to specify a date range or use it alone to filter jobs started on or before the specified date.
endFrom (timestamp in milliseconds): Filters jobs based on the date they ended. You can use it in combination with endTo to specify a date range or use it alone to filter jobs ended on or after the specified date.
endTo (timestamp in milliseconds): Filters jobs based on the date they ended. You can use it in combination with endFrom to specify a date range or use it alone to filter jobs ended on or before the specified date.
createFrom (timestamp in milliseconds): Filters jobs based on the date they were created. You can use it in combination with createTo to specify a date range or use it alone to filter jobs created on or after the specified date.
createTo (timestamp in milliseconds): Filters jobs based on the date they were created. You can use it in combination with createFrom to specify a date range or use it alone to filter jobs created on or before the specified date.
hasErrors (boolean): Specifies whether the job has errors. You can pass true or false to filter jobs based on their error status.
_size (integer): Sets the maximum number of jobs to retrieve in a single request.
You can combine these parameters as needed to narrow down your job search and retrieve the desired job information.
Returns # sys.commons.ResultSet - The jobs matching the query ordered by creation time in descendent order.
Exceptions # badRequest
This exception is raised if query provided is invalid.
Samples # // finds jobs finished with errors var jobs = sys.jobs.find({status: 'FINISHED', hasErrors: 'true', _size: 10}); while (jobs.hasNext()) { var job = jobs.next(); log('job with errors: '+job.name()); } logs(jobId, query) # The logs function allows you to retrieve logs for a background job. You have the option to apply filters and paginate the results for better control and analysis.
Parameters # Name Type Required Description jobId string yes ID of the job to retrieve its logs. query object yes When using the query parameter to filter logs, you can include various options to refine your log retrieval. Here are the valid filter options: - level : Filter logs by the level of the job. Allowed values are &ldquo;INFO&rdquo; and &ldquo;ERROR&rdquo;. - message : Filter logs by a partial match with the log message.
- from: Define the minimum timestamp in milliseconds since the Epoch. If you specify this parameter, the period option will be ignored.
- to : Set the maximum timestamp in milliseconds since the Epoch. If you specify this parameter, the period option will be ignored.
- period: Specify a period of time for log retrieval. Valid values include &ldquo;today&rdquo;, &ldquo;yesterday&rdquo;, or a time duration like &ldquo;2h 30m&rdquo; or &ldquo;10m&rdquo;. This option allows you to fetch logs from the last X amount of time.
- _size: Specify the maximum number of logs to retrieve. You can combine these filter options as needed to precisely target the logs you want to retrieve. Returns # sys.commons.ResultSet - A result set with the logs matching the query.
Exceptions # badRequest
This exception is raised if either the jobId or query provided are invalid.
notFound
This exception occurs when no job is found with the given ID.
Samples # // prints up to 10 logs for the last 3 jobs var jobs = sys.jobs.find({status: 'FINISHED', _size: 3}); while (jobs.hasNext()) { var job = jobs.next(); var logs = sys.jobs.logs(job.id(), {_size: 10}); log('logs for job ['+job.name()+']'); while (logs.hasNext()) { var logEntry = logs.next(); log(' '+logEntry.level()+': '+logEntry.message()); } } logInfo(jobId, message) # The logInfo function is used to add a log entry with the INFO level to a job.
If you provide the jobId parameter, the log entry will be associated with the specified job.
If you don&rsquo;t specify the jobId parameter, the log entry will be added to the current job if one exists. If there is no current job, the log entry will be discarded without any notification.
Parameters # Name Type Required Description jobId string no The unique identifier of the job to which you want to add the log entry. If this parameter is not provided, the current job (if available) will be used. If there is no current job, the log entry will be discarded without any notification. message string yes The message to be logged Exceptions # badRequest
This exception is raised if either the jobId or message provided are invalid.
notFound
This exception occurs when no job is found with the given ID.
Samples # // adds a log to the last 3 jobs var jobs = sys.jobs.find({_size: 3}); while (jobs.hasNext()) { var job = jobs.next(); sys.jobs.logInfo(job.id(), &quot;this is a test log!&quot;); } logError(jobId, message) # The logInfo function is used to add a log entry with the ERROR level to a job.
If you provide the jobId parameter, the log entry will be associated with the specified job.
If you don&rsquo;t specify the jobId parameter, the log entry will be added to the current job if one exists. If there is no current job, the log entry will be discarded without any notification.
Parameters # Name Type Required Description jobId string no The unique identifier of the job to which you want to add the log entry. If this parameter is not provided, the current job (if available) will be used. If there is no current job, the log entry will be discarded without any notification. message string yes The message to be logged. Exceptions # badRequest
This exception is raised if either the jobId or message provided are invalid.
notFound
This exception occurs when no job is found with the given ID.
Samples # // adds a log to the last 3 jobs var jobs = sys.jobs.find({_size: 3}); while (jobs.hasNext()) { var job = jobs.next(); sys.jobs.logError(job.id(), &quot;adds an error log!&quot;); } waitForJob(jobId, desiredStatus, maxTimeToWait) # The waitForJob function is used to pause execution and wait for a specific job to reach a desired status. It will return when the job reaches one of the specified statuses, or it will throw a timeout exception if the maximum wait time is exceeded.
Parameters # Name Type Required Description jobId string yes The unique identifier of the job for which you want to wait. desiredStaus string or string[] yes An array of one or more valid statuses that you want the job to reach before continuing execution.
Valid statuses include: PENDING, RUNNING, FINISHED, STOPPING, STOPPED, CANCELING, and CANCELED. The function will return as soon as the job reaches any of the specified statuses in the array. maxTimeToWait number yes The maximum amount of time, in some suitable time unit, that you are willing to wait for the job to reach one of the statuses specified in desiredStatus. If the job takes longer than this specified time, a timeout exception will be thrown. Exceptions # badRequest
This exception is raised if either the jobId or desiredStatus provided are invalid.
notFound
This exception occurs when no job is found with the given ID.
timeOut
This exception is raised if the job takes longer than the maxTimeToWait parameter specifies to reach one of the desired statuses specified in desiredStatus.
Samples # // executes an action in the background and waits for its completion var jobId = sys.data.executeAction('companies', {}, 'logSomething', {param1: 'a', param2: 'b'}); try { sys.jobs.waitForJob(jobId, 'FINISHED', 60000); log('job finished!!!'); } catch (e) { if (sys.exceptions.getCode(e) == 'timeout') { log('timeout execution the job'); } } // executes an action in the background and waits until it is finished or stopped var jobId = sys.data.executeAction('companies', {}, 'logSomething', {param1: 'a', param2: 'b'}); try { sys.jobs.waitForJob(jobId, ['FINISHED', 'STOPPED'], 60000); log('job finished!!!'); } catch (e) { if (sys.exceptions.getCode(e) == 'timeout') { log('timeout execution the job'); } } setLowPriority(jobId) # The setLowPriority function is used to set a low priority flag for a specific job. When this flag is set, other jobs that are running may be given higher priority over this job.
Parameters # Name Type Required Description jobId string yes The unique identifier of the job to which you want to set the low priority flag. Exceptions # badRequest
This exception is raised if jobId is invalid.
notFound
This exception occurs when no job is found with the given ID.
Samples # // executes an action in the background and sets the low priority flag var jobId = sys.data.executeAction('companies', {}, 'logSomething', {param1: 'a', param2: 'b'}); sys.jobs.setLowPriority(jobId); log('job flagged as low priority'); removeLowPriority(jobId) # The setLowPriority function is used to remove a low priority flag for a specific job.
Parameters # Name Type Required Description jobId string yes The unique identifier of the job to which you want to remove the low priority flag. Exceptions # badRequest
This exception is raised if jobId is invalid.
notFound
This exception occurs when no job is found with the given ID.
Samples # // executes an action in the background and sets the low priority flag and the removes it var jobId = sys.data.executeAction('companies', {}, 'logSomething', {param1: 'a', param2: 'b'}); sys.jobs.setLowPriority(jobId); log('job flagged as low priority'); sys.jobs.removeLowPriority(jobId); log('job unflagged as low priority'); getCurrentJobId() # The getCurrentJobId function returns the ID of the job that the script is currently running within. If the script is not running within the context of a job, this method will return null.
Returns # string - The ID of the current job if the script is running inside a job, or null if the script is not running within a job.
Samples # // logs the ID of the job executing the script var jobId = sys.jobs.getCurrentJobId(); log('job id: ' + jobId); getCurrentJob() # The getCurrentJob function returns the job object that the script is currently running within. If the script is not running within the context of a job, this method will return null.
Returns # sys.jobs.Job - The job object representing the current job if the script is running inside a job, or null if the script is not running within a job.
Samples # // logs the name of the job executing the script var job = sys.jobs.getCurrentJob(); log('job id: ' + job.label()); sys.jobs.Job # The sys.jobs.Job object contains information about a job.
id() # The id() method returns the unique ID of the job.
Returns # string - The ID of the job.
label() # The label() method returns the human-readable label of the job.
Returns # string -The label of the job.
type() # The type() method returns the type of the job. The only types of jobs that you can use in your code are as follows:
IMPORT_RECORDS EXPORT_RECORDS EXECUTE_ACTION DELETE_RECORDS EXECUTE_LISTENER IMPORT_USERS EXPORT_USERS STOP_APP START_APP DEPLOY_ENDPOINT UNDEPLOY_ENDPOINT Please note that there are other types of jobs, but they are system-specific and may change or be removed without prior notice.
Returns # string - The type of the job.
status() # The status() method returns the current status of the job. Possible status values are:
PENDING: The job is pending execution. RUNNING: The job is currently being executed. FINISHED: The job has been successfully completed. STOPPING: The job is in the process of stopping, which may take some time until it can be gracefully halted. STOPPED: The job has been stopped but is eligible for resuming. CANCELED: The job has been canceled and cannot be resumed. Returns # string - The current status of the job.
progress() # The progress() method returns the percentage of progress of the job. Please note that in some jobs, the progress value might not be very precise.
Returns # number - The progress of the job.
waiting() # The waiting() method returns the amount of time in milliseconds since the job was created until execution started. If the job is still in the &ldquo;PENDING&rdquo; state, this value will continue to grow.
Returns # number - The number of milliseconds that the job has been waiting.
duration() # The duration() method returns the amount of time in milliseconds that the job took to complete its execution since the start date. If the job is still in progress, this value will continue to grow.
Returns # number - The number of milliseconds that the job has been executing.
hasErrors() # The hasErrors() method indicates whether there have been errors during the execution of the job.
Returns # boolean - true if there have been errors, false otherwise.
startDate() # The startDate() method returns the date when the job started its execution. Keep in mind that a job could be in the &ldquo;PENDING&rdquo; state for a long time if there is heavy load on the app. In that case, the start date might be null and will be set when the job is actually executed.
Returns # Date - The date when the execution of the job started.
endDate() # The endDate() method returns the date when the job finished its execution. This can be either because the job finished correctly or because it was stopped.
Returns # Date - The date when the execution of the job finished.
runBy() # The runBy() method returns an object containing the ID and name of the user who triggered the job.
Returns # object - An object with the ID and name properties of the user.
data() # The data() method returns an object that contains the parameters of the job. The structure of this object depends on the type of job and should only be used for public jobs:
Start App:
Path Description pushChanges true if changes will be pushed during the starting of the app. false or empty otherwise. wakingUp true if the app was sleeping and is waking ap. false otherwise. Import records:
Path Description fileName This is the name of the file that will be imported. entityName The name of the entity where records will be imported. Export records:
Path Description entityName The name of the entity where records will be exported from. Delete records:
Path Description entityName The name of the entity where records will be deleted from. Execute action:
Path Description entityName The name of the entity the action belongs to. actionName The name of the action to be executed. Execute listener:
Path Description listenerName The name of the listener to execute. Import users:
Path Description fileName This is the name of the file that will be imported. notifyUsers true if people will be notified by email when users are created; false otherwise. Deploy endpoint:
Path Description endpointName The name of the endpoint to deploy. Undeploy endpoint:
Path Description endpointName The name of the endpoint to undeploy. Returns # object - An object containing the parameters of the job. The structure may vary depending on the job type.
results() # The results() method returns an object containing the results of executing the job. The structure of this object depends on the type of job and should only be used for public jobs.
Import records:
Path Description rowsImported The number of rows that were imported successfully. rowsWithErrors The number of rows that couldn’t be imported due to errors. Export records:
Path Description fileLink URL to download the CSV file with the exported records. You will need to send the token in the headers in order to be able to download it. fileId The ID of the file that was generated. recordsExported The number of records that were exported. Delete records:
The result will be a map like this one:
{ &quot;results&quot;: { &quot;id1&quot;: { &quot;status&quot;: &quot;ok&quot; }, &quot;id2&quot;: { &quot;status&quot;: &quot;error&quot;, &quot;errorMessage&quot;: &quot;error message&quot; } } } status: This field indicates whether the delete process was executed successfully over each record. It can have two possible values: &quot;ok&quot; if the deletion was successful or &quot;error&quot; if there were errors during the process.
response (Optional): This field will be available only if the action is configured to return the response in the results; otherwise, it won&rsquo;t be present.
Please note an important limitation: The maximum number of responses in this map will be 1,000. If you execute the delete process over more than 1,000 records, you might not be able to collect the response for each one.
This method is useful for retrieving the outcomes and responses from a completed job, particularly when performing actions like record deletion. However, the structure of the returned object varies depending on the job type and the configuration of the action. Make sure to account for the potential absence of the response field and the 1,000-record limit when processing large batches.
Execute action:
The results of this job depend on the type of action being executed. Here&rsquo;s how the results are structured:
{ &quot;results&quot;: { &quot;id1&quot;: { &quot;status&quot;: &quot;ok&quot;, &quot;response&quot;: &quot;response from action&quot; }, &quot;id2&quot;: { &quot;status&quot;: &quot;error&quot;, &quot;errorMessage&quot;: &quot;error message&quot; } } } Type: One Record
recordId: The ID of the record on which the action was executed. status: Indicates if the action was executed successfully over that record. It can have two possible values: &ldquo;ok&rdquo; for success or &ldquo;error&rdquo; for failure. response (Optional): The response data from the action, if configured to return a response in the results. errorMessage (Optional): Present when there is an error, providing insight into the problem. Type: Many Records
status: Indicates if the action was executed successfully over the records. It can have two possible values: &ldquo;ok&rdquo; for success or &ldquo;error&rdquo; for failure. response (Optional): The response data from the action, if configured to return a response in the results. { &quot;results&quot;: { &quot;status&quot;: &quot;ok&quot;, &quot;response&quot;: &quot;response from action&quot; } Please note that the response field will be available only if the action is configured to return the response in the results; otherwise, it won&rsquo;t be present.
Also, keep in mind an important limitation: The maximum number of responses in this map will be 1,000. If you execute the action over more than 1,000 records, you might not be able to collect the response for each one.
The structure of the result may vary depending on the type of action being performed and its configuration. Make sure to handle the result accordingly based on the specific requirements of the action.
Import users:
Path Description Export users:
Path Description fileLink URL to download the CSV file with the exported users. You will need to send the token in the headers in order to be able to download it. fileId The ID of the file that was generated. usersExported The number of users that were exported. Returns # object - The results of the job
logs() # The logs() method returns the logs of the job. It accepts a query as a parameter. This method works exactly the same as sys.jobs.logs(), so you can refer to its documentation to understand how it functions.
Returns # sys.commons.ResultSet - A result set containing the logs of the job.
Exceptions # notFound
This exception is raised if the job is not found in the database.
logInfo(message) # The logInfo() method adds a log entry with the INFO level to the job.
Parameters # Name Type Required Description message string yes The message to be logged Exceptions # badRequest
This exception is raised if the job is no longer valid or if the provided message is invalid.
notFound
This exception is raised if the job is not found in the database.
logError(message) # The logInfo() method adds a log entry with the ERROR level to the job.
Parameters # Name Type Required Description message string yes The message to be logged Exceptions # badRequest
This exception is raised if the job is no longer valid or if the provided message is invalid.
notFound
This exception is raised if the job is not found in the database.
sys.jobs.JobLog # The sys.jobs.JobLog object contains information about a line of log.
timeStamp() # The timestamp() method returns the date on which the log entry was recorded.
Returns # Date - The date on which the log entry was recorded.
level() # The level() method returns the level of the log, which can be &ldquo;INFO&rdquo; or &ldquo;ERROR&rdquo;.
Returns # string - The level of the log.
message() # The message() method returns the message associated with the log entry.
Returns # string - The message of the log.
aditionalInfo() # The additionalInfo() method returns additional information specific to the log entry. The content of this field can vary and should be used for diagnosing problems or gaining more insight into the log entry. However, it&rsquo;s recommended not to base your code logic solely on information from this field.
Returns # object - An object containing additional log-specific information. This field could be null in some cases.
This object and its methods allow you to access and retrieve detailed information about individual log entries for diagnostic and troubleshooting purposes.
`}),e.add({id:110,href:"/getting-started/getting/first-steps/task-mananger/creating/",title:"About - Task Manager",description:`Welcome to the Task Manager Tutorial!
What is a Task Manager App? # A task manager is an application designed to help individuals or teams organize, track, and manage tasks efficiently. It provides a centralized platform for creating, assigning, and monitoring tasks to streamline workflows and improve productivity. Users can set task deadlines, priorities, and statuses, enabling them to stay on top of their responsibilities and collaborate effectively with others.`,content:`Welcome to the Task Manager Tutorial!
What is a Task Manager App? # A task manager is an application designed to help individuals or teams organize, track, and manage tasks efficiently. It provides a centralized platform for creating, assigning, and monitoring tasks to streamline workflows and improve productivity. Users can set task deadlines, priorities, and statuses, enabling them to stay on top of their responsibilities and collaborate effectively with others.
Create the app from scratch # Once you are logged into the developer portal, you should see the Home Page:
Click on the New App button in the Your Apps section. Fill in the app label and name. Please note that the name must be unique on the platform. Select Slingr Free as the plan for your app. Choose the option to start from scratch. Wait until the app is created. This process usually takes a minute to complete. Discover the application components # Once your app is successfully created, you will see its details. By default, you will be the owner of the app, and you will have developer permissions for the development environment, which is created by default. In the environment details, you will be able to navigate through the different components of the app.
👉 Go To App: This button will take you to your running app. Right now, it doesn&rsquo;t provide much functionality as the app is empty.
👉 Monitor: From here, we can see the app&rsquo;s status, background jobs, logs, etc. If you need to know what&rsquo;s going on, this is the place to look.
👉 Builder: This is where we will develop our app.
You can also see the different environments and components on the Apps Page.
The first button represents the Runtime, the second is the Monitor, and the third one is the Builder. As our new app is empty, the first thing we need to do is to go to the app builder by clicking on the Builder button (the one with the wrench). That will automatically open the builder in a new tab.
Let&rsquo;s wrap up this section here. If you want to learn more, let&rsquo;s proceed to the next section: First steps with the builder.
`}),e.add({id:111,href:"/dev-reference/scripting/sys-logs/",title:"sys.logs",description:`sys.logs # The sys.logs package provides methods for logging application events. These logs are accessible in the app monitor, serving as valuable tools to understand your app&rsquo;s activities.
You have the option to set up your app to generate alerts when error or warning messages are logged. This proactive approach aids in monitoring your app effectively.
info(message,exception) # This method logs a message at the INFO level.
Parameters # Name Type Required Description message string yes The message to be logged.`,content:`sys.logs # The sys.logs package provides methods for logging application events. These logs are accessible in the app monitor, serving as valuable tools to understand your app&rsquo;s activities.
You have the option to set up your app to generate alerts when error or warning messages are logged. This proactive approach aids in monitoring your app effectively.
info(message,exception) # This method logs a message at the INFO level.
Parameters # Name Type Required Description message string yes The message to be logged. exception sys.exceptions.ScriptException or Error yes Optional. An associated exception, if applicable. Samples # // logs something in the app sys.logs.info('this is a test info log'); warn(message,exception) # This method logs a message at the WARN level.
Parameters # Name Type Required Description message string yes The message to be logged. exception sys.exceptions.ScriptException or Error yes Optional. An associated exception, if applicable. Samples # // logs something in the app sys.logs.warn('this is a test warn log'); error(message,exception) # This method logs a message at the ERROR level.
Parameters # Name Type Required Description message string yes The message to be logged. exception sys.exceptions.ScriptException or Error yes Optional. An associated exception, if applicable. Samples # // logs something in the app sys.logs.error('this is a test error log'); // catches an exception and logs a message with the exception try { sys.data.find('entityThatDoesNotExist', {}); } catch (e) { sys.logs.error('there was an error when doing query', e); } debug(message,exception) # This method logs a message at the DEBUG level for development purposes. Please note that this service functions exclusively in the Development environment.
Parameters # Name Type Required Description message string yes The message to be logged. exception sys.exceptions.ScriptException or Error yes Optional. An associated exception, if applicable. Samples # // logs something in the app sys.logs.debug('this is a test debug log'); `}),e.add({id:112,href:"/dev-reference/scripting/sys-storage/",title:"sys.storage",description:`sys.storage # The sys.storage package provides methods for working with storage. Storage is a temporary key-value data structure used to store information that spans multiple user requests or threads.
It&rsquo;s essential to note that storage is temporary, and data may be lost when the app is restarted or upgraded. Therefore, relying on data being available between restarts or upgrades of the app is not recommended.
get(key, options) # This method returns the value stored at the specified key.`,content:`sys.storage # The sys.storage package provides methods for working with storage. Storage is a temporary key-value data structure used to store information that spans multiple user requests or threads.
It&rsquo;s essential to note that storage is temporary, and data may be lost when the app is restarted or upgraded. Therefore, relying on data being available between restarts or upgrades of the app is not recommended.
get(key, options) # This method returns the value stored at the specified key.
Parameters # Name Type Required Description key string yes The key for which you want to retrieve the stored value. options object no Optional parameters to configure the retrieval. The available option is: - decrypt: If set to true, it will decrypt the entry value. Returns # any - The value stored at the specified key or null if no value exists for the given key.
Samples # // puts something in the storage and retrives it sys.storage.put('key1', 'a'); log('key1: '+sys.storage.get('key1')); // retrieve sensitive data sys.storage.put('apiKey', 'd4j6Ls83ndIw2JdnuwUj3bz'); log('apiKey: ' + sys.storage.get('token')); // display api key encrypted log('apiKey: ' + sys.storage.get('token', {decrypt: true})); // display plain api key put(key, value, options) # This method stores an object or primitive value in the storage.
Parameters # Name Type Required Description key string yes The key for which you want to retrieve the stored value. value any yes The value to store. It can be a primitive or an object. options object no Optional parameters to configure the storage. The available options are: - ttl: Indicates the time to live for that key, expressed in milliseconds. - If set to true, it will encrypt the entry value, which can be useful for storing sensitive data. Returns # any - The previous value associated with the given key, or null if there wasn&rsquo;t a value associated with it previously.
Samples # // puts a string and an object in the storage sys.storage.put('key1', 'a'); log('key1: '+sys.storage.get('key1')); var obj = {prop1: 'a', prop2: 'b'}; sys.storage.put('key2', obj); log('key2: '+JSON.stringify(sys.storage.get('key2'))); // puts a key that will live for 1 hours sys.storage.put('key1', 'a', {ttl: 60 * 60 * 1000}); // encrypts and decrypts a token sys.storage.put('token', 'Okd4j6', {encrypt: true}); log('token: ' + sys.storage.get('token')); // display token encrypted log('token: ' + sys.storage.get('token', {decrypt: true})); // display plain token put(key, value, options) # This method stores an object or primitive value in the storage at the specified key if it hasn&rsquo;t been set already.
Parameters # Name Type Required Description key string yes The key for which you want to retrieve the stored value. value any yes The value to store. It can be a primitive or an object. options object no Optional parameters to configure the storage. The available options are: - ttl: Indicates the time to live for that key, expressed in milliseconds. - If set to true, it will encrypt the entry value, which can be useful for storing sensitive data. Returns # boolean - true if the value was effectively set, or false otherwise.
Samples # // puts a value twice over the same key, but second time it shouldn't be stored sys.storage.put('key1', 'a'); sys.storage.putIfAbsent('key1', 'b'); log('key1: '+sys.storage.get('key1')); replace(key, value, options) # This method replaces the value at the specified key. If no value was previously set at that key, the new value won&rsquo;t be stored.
Parameters # Name Type Required Description key string yes The key for which you want to retrieve the stored value. value any yes The value to store. It can be a primitive or an object. options object no Optional parameters to configure the storage. The available options are: - ttl: Indicates the time to live for that key, expressed in milliseconds. - If set to true, it will encrypt the entry value, which can be useful for storing sensitive data. Returns # boolean - true if the value was effectively set, or false otherwise.
Samples # // tries to replace the value in two different keys sys.storage.put('key1', 'a'); sys.storage.replace('key1', 'b'); sys.storage.replace('keyThatDoesNotExist', 'c'); log('key1: '+sys.storage.get('key1')); log('keyThatDoesNotExist: '+sys.storage.get('keyThatDoesNotExist')); remove(key) # This method removes the value at the specified key.
Parameters # Name Type Required Description key string yes The key for which you want to retrieve the stored value. Returns # any - The value at the specified key, or null if there isn&rsquo;t any value associated with that key.
Samples # // puts and remove a value sys.storage.put('key1', 'a'); log('key1: '+sys.storage.get('key1')); sys.storage.remove('key1'); log('key1: '+sys.storage.get('key1')); clear() # This method removes all values stored in the storage, effectively clearing it.
Samples # // puts and remove a value sys.storage.put('key1', 'a'); sys.storage.put('key2', 'b'); log('key1: '+sys.storage.get('key1')); log('key2: '+sys.storage.get('key2')); sys.storage.clear(); log('key1: '+sys.storage.get('key1')); log('key2: '+sys.storage.get('key2')); `}),e.add({id:113,href:"/dev-reference/scripting/sys-ui/",title:"sys.ui",description:`It is possible to interact with the UI by sending messages from server-side scripts. These messages can instruct the UI to perform various actions, such as navigating to a view, reloading the UI, displaying a message, or triggering an action.
When working with UI messages, there are several important considerations:
Script Association: While you can call this method from any script, it is recommended to use it primarily in scripts associated with views, such as event scripts in views.`,content:`It is possible to interact with the UI by sending messages from server-side scripts. These messages can instruct the UI to perform various actions, such as navigating to a view, reloading the UI, displaying a message, or triggering an action.
When working with UI messages, there are several important considerations:
Script Association: While you can call this method from any script, it is recommended to use it primarily in scripts associated with views, such as event scripts in views. This ensures clarity regarding when these scripts will be executed.
Non-View Scripts: If you call this method from a script that is not associated with a view (e.g., an action script), the message may not be sent to the UI and could be lost. This can occur when the action is executed in the background or as part of a non-UI-related process, such as an external REST API call.
Message Order: You can send multiple messages to the UI, and they will be executed in order. However, it is essential to understand that some messages might override or discard others. For instance, if you reload the page, any message after that command will be lost.
Message Timing: Messages may not be sent to the UI immediately. The timing of UI messages is implementation-specific and depends on the available features in the UI. UI messages might be executed only after the associated request has been completed.
All messages have at least two fields:
scope: Indicates the message&rsquo;s scope and which elements in the UI should process it. Currently, there are four scopes: global, view, plugin, and action.
name: A unique name for the message within each scope.
target: Specifies the message&rsquo;s recipient. Possible values include:
caller: The user who initiated the UI request. users: Sends the message to all users defined in targetUsers across all their tabs. allUsers: Broadcasts the message to all users. The default value is caller. targetUsers: A list of recipients when target is defined as users. It is an array of emails or IDs. The default value is the current user.
views: A list of view names. This is only required for messages in the view scope.
recordId: A list of view names. This is only required for messages in the view scope.
sys.ui.sendMessage(message) # Parameters # Name Type Required Description message object yes This is the message to send to the UI. You must indicate the scope and name. Other fields depends on the message. Exceptions # badRequest
If the message is does not exist or there are validation errors.
Global message names # reload # Scope # global
Parameters # Name Type Required Default Description goToDefaultView boolean no false If true when the app is reloaded, the user will be taken to the default view (the view displayed when the app is loaded after login). Otherwise current page will be reloaded. Samples # // reload current page sys.ui.sendMessage({ scope: 'global', name: 'reload', target: 'caller' }); // reload and go to default view sys.ui.sendMessage({ scope: 'global', name: 'reload', goToDefaultView: true, target: 'caller' }); navigate # Scope # global
Parameters # Name Type Required Default Description view string yes - ID or name of the view to navigate to. recordId string no - ID of the record. When this field is set the app navigates to the detail read-only view of the record. viewType string no readOnly In case of grid or workflow views define the view type to redirect. Possible values edit or create. filters object no - In case of grid or workflow views define some view filters to be applied. This filter example apply 2 filters for the view:
{
name: &lsquo;ACME&rsquo;,
address.state:&rsquo;new&rsquo;
} parameters object no - In case of custom views you can define some view parameters to be applied. Those parameters are transformed into URL query parameters. For example, the following parameters
{
name: &lsquo;ACME&rsquo;,
status:&rsquo;new&rsquo;
}
Are going to be transformed to the following URL query parameters:
?name=ACME&amp;status=New goToLogin # Scope # global
Parameters # Name Type Required Default Description pathAfterLogin string no - If you add this parameter after logging in, it will redirect to the indicated path. Samples # // Go to login sys.ui.sendMessage({ scope: 'global', name: 'goToLogin' }); openExternalLink # Scope # global
Parameters # Name Type Required Default Description url string yes - External URL to open newTab boolean no true If true external URL is opened in a new tab of the browser. Otherwise the URL will be opened in same tab. historyBack # Scope # global
Parameters # No parameters required
showMessage # Scope # global
Parameters # Name Type Required Default Description title string yes - The title to be shown on message. message string yes - The message content to be shown. It supports some basic HTML tags. type string no info Defines the style for the message. Possible values are info, success, warning or error. keepVisible boolean no false If true the message won’t be closed automatically and the user has to close it manually. Samples # // send a custom message sys.ui.sendMessage({ scope: 'global', name: 'showMessage', target: 'users', targetUsers: ['id1', 'id2', 'user@test.com'], title: 'Heads up!', message: 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.', type: 'warning', keepVisible: true }); // send a notification sys.ui.sendMessage({ scope: 'global', name: 'showMessage', target: 'allUsers', title: 'title message', message: 'body message here...' }); downloadFile # Scope # global
Parameters # Name Type Required Default Description fileId string yes - The ID of the file to download. Samples # // start downloading a file sys.ui.sendMessage({ scope: 'global', name: 'downloadFile', target: 'caller', fileId: record.field('file').id() }); addBackgroundJob # Scope # global
Parameters # Name Type Required Default Description jobId string yes - The ID of the background job in charge of executing. startTask # Scope # global
Parameters # Name Type Required Default Description taskId string yes - The ID of the task to be displayed on tasks menu in the top-right. taskTitle string yes - The message to be displayed on tasks menu in the top-right. taskMessage string no - The compliment message to be sent as subtitle on tasks menu in the top-right. updateTask # Scope # global
Parameters # Name Type Required Default Description taskId string yes - The ID of the task to be displayed on tasks menu in the top-right. taskTitle string no - The message to be displayed on tasks menu in the top-right. taskMessage string no - The compliment message to be sent as subtitle on tasks menu in the top-right. taskStatus string no - The status of the tasks. Can be updated to running, success or error. At the beginning the status is running. View message names # recordChanged # Scope # view
Parameters # Name Type Required Default Description recordId string no - The ID of the record that has been changed. views object yes - The list of view names that will be notified by the event. The view types that can process this event are: grid, card, calendar and read only views. Samples # // Notify to all users that are currently on views \`contacts\` and \`contactsReadOnly\` that the record \`57fd2d65e4b0ce322b0c8665\` has been updated sys.ui.sendMessage({ scope: 'view', name: 'recordChanged', target: 'allUsers', views: ['contacts','contactsReadOnly'], recordId: '57fd2d65e4b0ce322b0c8665' }); recordCreated # Scope # view
Parameters # Name Type Required Default Description recordId string no - The ID of the record that has been changed. views object yes - The list of view names that will be notified by the event. The view types that can process this event are: grid, card, calendar and read only views. Samples # // Notify to some users that are currently on view \`tasksCards\` that a record has been created var record = sys.data.createRecord('tasks');// create an empty record of entity task record.field('status').val('NEW');// filling the new necord with the corresponding field values... record.field('description').val('Example created on script'); record.field('title').val('New task created from script'); record.field('area').val({id:&quot;5506fc3cc2eee3b1a7025bff&quot;}); record.field('project').val({id: &quot;5506fc44c2eee3b1a7026959&quot;, label: &quot;Point-to-point link&quot;}); record = sys.data.save(record);// saving the created record sys.ui.sendMessage({ scope: 'view', views: ['tasksCards'], target: 'users', targetUsers: ['id1', 'id2', 'user@test.com'], name: 'recordCreated', recordId: record.id() }); recordDeleted # Scope # view
Parameters # Name Type Required Default Description recordId string no - The ID of the record that has been changed. views object yes - The list of view names that will be notified by the event. The view types that can process this event are: grid, card, calendar and read only views. Samples # // Notify to all users that are currently on view \`contacts\` that the record \`57fd2d65e4b0ce322b0c8665\` has been deleted sys.ui.sendMessage({ scope: 'view', name: 'recordDeleted', target: 'allUsers', views: ['contacts'], recordId: '57fd2d65e4b0ce322b0c8665' }); refresh # Scope # view
Parameters # Name Type Required Default Description views object yes - The list of view names that will be notified by the event. The view types that can process this event are: grid, card, calendar and read only views. widgetContainers onject no - In case to dashbaord view you can send the array a list to containers to be refresh. This can be an array of string or can be specify an object with container name and query parameters. Check widgets documentation for more information. Samples # // Refresh view \`contacts\` to all users that are currently on that view sys.ui.sendMessage({ scope: 'view', name: 'refresh', target: 'allUsers', views: ['contacts'] }); Plugin message names # anyEvent # Scope # plugin:pluginName
Parameters # No parmeters required
Samples # // dispatch \`event1\` in \`sample\` plugin sys.ui.sendMessage({ scope: 'plugin:sample', name: 'event1', companyId: record.id(), callbacks: { callback1: function(originalMessage, callbackData) { sys.logs.debug(&quot;Here is the original message for callback 1&quot;); sys.logs.debug(JSON.stringify(originalMessage)); sys.logs.debug(&quot;Here is the callback data for callback 1&quot;); sys.logs.debug(JSON.stringify(callbackData)); }, callback2: function(originalMessage, callbackData) { //do something } } }); Action message names # anyEvent # Scope # action
Parameters # Name Type Required Description entity string yes ID or name of the entity the action belongs too. recordId string no The ID of the record the action will be executed over. This is optional in case it is a global action. recordsIds object no The IDs array of the record the action will be executed over. This is optional in case it is a global action. actionView string no Name or ID of the action view. action string no If actionView is not provided, you can send only action with the name or ID of the action and the default view will be used. success function no Callback when the action is executed successfully. error function no Callback when there is an error executing the action. canceled function no Callback when the action execution is canceled. Samples # // Send UI message in order to trigger an action from server side so the user can enter the parameters and execute it. sys.ui.sendMessage({ scope: 'action', entity: 'myCompany', target: 'allUsers', recordIds: ['5be99071b10c3e09893300d2', '5be99082b10c3e09893300e2'], action: 'setCompanyType', success: function() { sys.logs.debug(&quot;&gt; Success!&quot;); }, error: function() { sys.logs.debug(&quot;&gt; ERROR&quot;); }, canceled: function() { sys.logs.debug(&quot;&gt; Canceled...&quot;); } }); `}),e.add({id:114,href:"/dev-reference/scripting/sys-users/",title:"sys.users",description:`sys.users # The sys.users package comprises various utilities for managing system user records.
activate(user) # This method changes the status of the user to active. If the user was already active, no action will be taken.
Parameters # Name Type Required Description user sys.data.Record yes The user to activate. Returns # sys.data.Record - The activated user object.
Exceptions # badRequest
If user is not a valid object
notFound
If no user is found in the database for the given user object.`,content:`sys.users # The sys.users package comprises various utilities for managing system user records.
activate(user) # This method changes the status of the user to active. If the user was already active, no action will be taken.
Parameters # Name Type Required Description user sys.data.Record yes The user to activate. Returns # sys.data.Record - The activated user object.
Exceptions # badRequest
If user is not a valid object
notFound
If no user is found in the database for the given user object.
Samples # // creates a user, deactivate, activate and deletes it var user = sys.data.createRecord('sys.users'); user.field('firstName').val('User1'); user.field('lastName').val('Test'); user.field('email').val('user1@test.com'); user.field('sendWelcomeEmail').val(false); sys.users.addGroup(user, 'Group1', true); // if we want to save the user's password we need to add user.field('authentication.passwordExpired').val(false); user.field('authentication.generatePassword').val(false); // otherwise those fields values will be TRUE by default, and the API will skip the password fields var userPassword = '1234567890' user.field('authentication.password').val(userPassword); user.field('authentication.passwordConfirmation').val(userPassword); user.field('authentication.newPassword').val(userPassword); // now we save the user and it will be created in the app at this point user = sys.data.save(user); log('user id: '+user.id()); // deactivate user user = sys.users.deactivate(user); log('user status: '+user.status()); // activate user user = sys.users.activate(user); log('user status: '+user.status()); // finally remove the user sys.data.remove(user); deactivate(user) # This method changes the status of the user to inactive. If the user was already inactive, no action will be taken.
Parameters # Name Type Required Description user sys.data.Record yes The user to deactivate. Returns # sys.data.Record - The deactivated user object.
Exceptions # badRequest
If user is not a valid object
notFound
If no user is found in the database for the given user object.
Samples # // creates a user, deactivates and deletes it var user = sys.data.createRecord(); user.field('firstName').val('User1'); user.field('lastName').val('Test'); user.field('email').val('user1@test.com'); user.field('sendWelcomeEmail').val(false); sys.users.addGroup(user, 'Group1', true); // now we save the user and it will be created in the app at this point user = sys.data.save(user); log('user id: '+user.id()); // deactivate user user = sys.users.deactivate(user); log('user status: '+user.status()); // finally remove the user sys.data.remove(user); resetPassword(user, options) # This method resets the password of a specific user. If the user is blocked, this action will also reactivate the user.
Parameters # Name Type Required Description user sys.data.Record yes The user to reset password. options object no The available option is: - notifyUser: A flag to indicate whether the user should be notified by email. Returns # object
userId: '...', userEmail: '...', resetCode: '...', link: '...' Where userId and userEmail are fields associated with the affected user in the operation.
resetCode is the automatically generated code used for password reset, and link represents the URL where the user needs to configure their password settings.
Samples # // reset password for user and notified about it by email var user = sys.data.findOne('sys.users', 'user@company.com'); var result = sys.users.resetPassword(user, {notify: true}); log('Reset password result: ' + JSON.stringify(result)); updatePassword(user, options) # This method updates the password of a specific user. If the user is blocked, this action will also reactivate the user.
Parameters # Name Type Required Description user sys.data.Record yes The user to reset password. options object no These options allow to configure operation. The available option is: - notifyUser: A flag to indicate whether the user should be notified by email. - currentPassword: flag to indicate the current password.
- newPassword: flag to specify the new password. Returns # object
{ userId: '...', userEmail: '...' } Where userId and userEmail are fields associated with the affected user in the operation.
Samples # // update password for user and notified about it by email var user = sys.data.findOne('sys.users', {email: 'your_email@example.com'}); var options = { notifyUser: true, currentPassword: &quot;CurrentPassword456&quot;, newPassword: &quot;OldPassword123&quot; }; var result = sys.users.updatePassword(user, options); log('Update password result: ' + JSON.stringify(result)); addIdentityProvider(userId, identityProviderIdOrName, externalId) # Enables an identity provider for the specified user. If the identity provider was previously enabled for that user, the external ID will be updated.
Parameters # Name Type Required Description userId string yes The ID of the user to enable the identity provider. identityProviderIdOrName string yes The ID or name of the identity provider to enable. externalId string no The ID of the user in the identity provider. It is optional. Returns # sys.data.Record - The updated user object.
Exceptions # badRequest
If user or identityProviderIdOrName are not valid.
notFound
If no user is found in the database for the given user ID or no identity provider with the given ID or name.
Samples # // creates a user, adds an identity provider, and deletes it var user = sys.data.createRecord(); user.field('firstName').val('User1'); user.field('lastName').val('Test'); user.field('email').val('user1@test.com'); user.field('sendWelcomeEmail').val(false); sys.users.addGroup(user, 'Group1', true); // now we save the user and it will be created in the app at this point user = sys.data.save(user); log('user id: '+user.id()); // add identity provider user = sys.users.addIdentityProvider(user.id(), 'slack', user.email()); log('identity provider added'); // finally remove the user sys.data.remove(user); removeIdentityProvider(userId, identityProviderIdOrName) # Disables an identity provider for the specified user. If the identity provider wasn&rsquo;t already enabled for that user, it has no effect.
Parameters # Name Type Required Description userId string yes The ID of the user to disable the identity provider. identityProviderIdOrName string yes The ID or name of the identity provider to disable. Returns # sys.data.Record - The updated user object.
Exceptions # badRequest
If user or identityProviderIdOrName are not valid.
notFound
If no user is found in the database for the given user ID.
Samples # // creates a user, adds an identity provider, removes it, and deletes the user var user = sys.data.createRecord(); user.field('firstName').val('User1'); user.field('lastName').val('Test'); user.field('email').val('user1@test.com'); user.field('sendWelcomeEmail').val(false); sys.users.addGroup(user, 'Group1', true); // now we save the user and it will be created in the app at this point user = sys.data.save(user); log('user id: '+user.id()); // add identity provider user = sys.users.addIdentityProvider(user.id(), 'slack', user.email()); log('identity provider added'); // remove identity provider user = sys.users.removeIdentityProvider(user.id(), 'slack'); log('identity provider removed'); // finally remove the user sys.data.remove(user); containsGroup(userRecord, groupIdOrNameOrLabel) # Checks whether the user record is a member of the specified group.
Parameters # Name Type Required Description userRecord sys.data.Record yes The user record to check group. groupIdOrNameOrLabel string yes The ID or name or label of the group to check. Returns # boolean - True if the user belongs to the specified group.
Samples # // check if the user belongs to the admins group var user = sys.data.findOne('sys.users', {email: 'user@company.com'}); var isAdmin = sys.users.containsGroup(user, 'admins'); log('Is it admin? ' + isAdmin); isPrimaryGroup(userRecord, groupIdOrNameOrLabel) # Checks if the primary group of the user record is the given group.
Parameters # Name Type Required Description userRecord sys.data.Record yes The user record to check group. groupIdOrNameOrLabel string yes The ID or name or label of the group to check. Returns # boolean - True if the specified group is the primary one.
Samples # // check if admins group is the primary one var user = sys.data.findOne('sys.users', {email: 'user@company.com'}); var isPrimary = sys.users.isPrimaryGroup(user, 'admins'); log('Is it primary? ' + isPrimary); getPrimaryGroup(userRecord) # Retrieves the primary group of the user.
Parameters # Name Type Required Description userRecord sys.data.Record yes The user record to check group. Returns # object - An object with the attributes ID, name and label
Samples # // check if admins group is the primary one var user = sys.data.findOne('sys.users', {email: 'user@company.com'}); var primaryGroup = sys.users.getPrimaryGroup(user); log('Group: ' + JSON.stringify(primaryGroup)); addGroup(userRecord, groupIdOrNameOrLabel, primary) # Adds a group to the specified record user.
Parameters # Name Type Required Description userRecord sys.data.Record yes The user record to add to a group. groupIdOrNameOrLabel string yes The ID or name or label of the group to be added. primary boolean no True if the group to be added is the primary one. Samples # // add admins group as primary. var user = sys.data.findOne('sys.users', {email: 'user@company.com'}); sys.users.addGroup(user, 'admins', true); sys.data.save(user); log('Contains group: ' + sys.users.containsGroup(user, 'admins')); removeGroup(userRecord, groupIdOrNameOrLabel) # Removes the user record from the given group
Parameters # Name Type Required Description userRecord sys.data.Record yes The user record to remove group. groupIdOrNameOrLabel string yes The ID or name or label of the group to be removed. Samples # // remove admins group. var user = sys.data.findOne('sys.users', {email: 'user@company.com'}); sys.users.removeGroup(user, 'admins'); sys.data.save(user); log('Contains group: ' + sys.users.containsGroup(user, 'admins')); getEndpointConfiguration(userRecord, endpointName) # This function retrieves the configuration of the specified user endpoint if it exists.
Parameters # Name Type Required Description userRecord sys.data.Record yes The user record to to retrieve endpoint configuration. endpointName string yes The name of the endpoint to retrieve configuration. Samples # // retrieve http endpoint configuration var user = sys.data.findOne('sys.users', {email: 'user@company.com'}); var config = sys.users.getEndpointConfiguration(user, 'http'); log('Http endpoint configuration: ' + JSON.stringify(config)); `}),e.add({id:115,href:"/dev-reference/scripting/sys-utils/",title:"sys.utils",description:`sys.utils.text # This package contains methods to manipulate text.
findTokens(text) # The findTokens function is used to locate and extract all tokens from a given string. Tokens in the string are identified as sequences that start with &ldquo;#&rdquo; and adhere to the following format:
#name:value #name:value1,value2,value3 #name This way you could have a text like this:
#project:test #assignee:user1 #important There is a bug with user profile popup! This method enables you to effortlessly extract the tokens project, assignee, and important.`,content:`sys.utils.text # This package contains methods to manipulate text.
findTokens(text) # The findTokens function is used to locate and extract all tokens from a given string. Tokens in the string are identified as sequences that start with &ldquo;#&rdquo; and adhere to the following format:
#name:value #name:value1,value2,value3 #name This way you could have a text like this:
#project:test #assignee:user1 #important There is a bug with user profile popup! This method enables you to effortlessly extract the tokens project, assignee, and important.
This method proves highly valuable for parsing commands within plain text messages, such as emails or instant messages.
Parameters # Name Type Required Description text string yes Text to parse to find tokens. Returns # object - A key-value structure where the key represents the token name. The value could be an array if there is more than one value. For example, given the following text:
#project:test1 #assignee:admin #watchers:user1,user2 #important This is an important issue! Please fix. Also related to #project:test2 Tokens will be:
{ project: ['test1', 'test2'], assignee: 'admin', watchers: ['user1', 'user2'], important: true } Notice that when you don’t specify a value for the token, it will be set to true.
Samples # // finds tokens in a string var str = &quot;this is a ticker #project:test1 #type:bug #hotfix&quot;; var tokens = sys.utils.text.findTokens(str); log('tokens: '+JSON.stringify(tokens)); processTemplate(template, options) # This function enables you to process a Freemarker template. You can find more information about Freemarker here
Parameters # Name Type Required Description template string yes The Freemarker template options object no Options to process the template. The available options are: - unescapeHtml: Use this option if you want to unescape the resulting string after processing the template. - model: These are the objects you want to merge into your template. Returns # string - The processed template
Samples # // process a template for an email for a contact var record = sys.data.findOne('contacts', {email: 'gowensb1@google.ca'}); var recordStr = record.toJson({relationshipsToFetch: 'company', user: 'gowensb1@google.ca '}); var template = &quot;Hi \${contact.firstName} \${contact.lastName}:\\n\\n We want to say hi!\\n\\nThanks!&quot;; var emailContent = sys.utils.text.processTemplate(template, { model: { contact: recordStr } }); log('email content: '+emailContent); htmlToText(html) # This function allows you to convert an HTML text into plain text by removing HTML tags.
Parameters # Name Type Required Description html string yes The HTML text to be parsed. Returns # string - A plain text with HTML tags removed.
Samples # // convert an html text into a plain text var html = &quot;&lt;strong&gt;This is sparta&lt;/strong&gt;&quot;; var text = sys.utils.text.htmlToText(html); log('Text: ' + text); textToHtml(text) # This function allows you to convert a plain text into HTML text.
Parameters # Name Type Required Description text string yes The plain text to be parsed. Returns # string - An HTML with plain text tokens removed.
Samples # // convert a plain text into an html text var text = &quot;This is sparta\\n&quot;; var html = sys.utils.text.textToHtml(text); log('HTML: ' + html); markdownToHtml(markdownText) # This function allows you to convert an markdown text into HTML by transforming markdown tokens into html tags.
Parameters # Name Type Required Description markdownText string yes The markdown text to be parsed. Returns # string - An HTML text with markdown tokens transformed into html tags
Samples # // convert a markdown text into an html text var markdown = &quot;**This is sparta**&quot;; var html = sys.utils.text.markdownToHtml(markdown); log('HTML: ' + html); htmlToMarkdown(html) # This function allows you to convert an HTML text into markdown text by transforming html tags into html markdown tokens.
Parameters # Name Type Required Description hrml string yes The html text to be parsed. Returns # string - A markdown text with html tags transformed into markdown tokens
Samples # // convert an html text into a markdown text var html = &quot;&lt;strong&gt;This is sparta&lt;/strong&gt;&lt;br/&gt;&quot;; var markdown = sys.utils.text.htmlToMarkdown(html); log('Markdown text: ' + markdown); sys.utils.xml # This package contains methods for manipulating XML format.
xmlToJson(xml) # This function allows you to convert an XML text into a JSON object.
Parameters # Name Type Required Description xml string yes The xml text to be converted Returns # object - the JSON representation of the given XML
Samples # // convert an XML text into a JSON object var xml = '&lt;note&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;/note&gt;'; var json = sys.utils.xml.xmlToJson(xml); log('Json: ' + JSON.stringify(json)); // this will print {&quot;note&quot;:{&quot;to&quot;:&quot;Tove&quot;,&quot;from&quot;:&quot;Jani&quot;}} jsonToXml(json) # This function allows you to convert a JSON object into an XML text.
Parameters # Name Type Required Description json object yes The JSON object to be parsed Returns # string - A XML text
Samples # // convert a JSON object into a XML text var json = {&quot;note&quot;:{&quot;to&quot;:&quot;Tove&quot;,&quot;from&quot;:&quot;Jani&quot;}}; var xml = sys.utils.xml.jsonToXml(json); log('XML: ' + xml); sys.utils.base64 # This package contains utilities for Base64 encoding. Base64 encoding is used to represent binary data in an ASCII format.
encode(string) # This function encodes binary data using the Base64 algorithm. It does not chunk the output.
Parameters # Name Type Required Description string string yes Data to be encoded. Returns # string - A string containing Base64 characters in their UTF-8 representation.
Samples # // encode a string var pass = 'This_is_a_pass'; var encodedPass = sys.utils.base64.encode(pass); log('Encoded pass: ' + encodedPass); decode(base64String) # Decodes a Base64 string into octets.
Parameters # Name Type Required Description base64String string yes String containing base 64 data Returns # string - Decoded data
Samples # // decode an encoded string var pass = 'VGhpc19pc19hX3Bhc3M='; var rawPass = sys.utils.base64.decode(pass); log('Pass: ' + rawPass); sys.utils.numbers # This package contains methods to assist in managing numbers.
BigNumber() # This is a library for arbitrary-precision decimal and non-decimal arithmetic. For more information, please visit: BigNumber.js
Samples # // Returns a BigNumber whose value is the value of this BigNumber plus n var n = 0.2; var bigNumber = sys.utils.numbers.BigNumber(0.1); return bigNumber.plus(n); format(value, options) # Returns a string of formatted number of the value or string without format.
Parameters # Name Type Required Description value number yes The value to be formtted. options object no These parameters are used to format a value. If left empty, the default display options are used for formatting.
- thousandsSeparator: Specifies whether to show a thousands separator. Accepts true or false.
- limitNumberOfDecimals: Indicates whether to limit the number of decimals. Accepts true or false.
- numberOfDecimals: Specifies the number of decimals to be displayed. Default is 2.
- limitRuleType: Specifies the rule to use when limiting decimals. Options include TRUNCATE or ROUND. Default is TRUNCATE. Returns # string - string of formatted value of number.
Samples # // prints the formatted value of a decimal value var options = {thousandsSeparator: true, limitNumberOfDecimals:true, numberOfDecimals: 3}; var formattedNumber = sys.utils.numbers.format(12345.12345, options); log('Result: ' + formattedNumber); getRandomValue() # Using a random number algorithm generates a strong cryptographic decimal number between 0.0 and 1.0.
Samples # // prints a random number. var randomNumber = sys.utils.numbers.getRandomValue(); log('Result: ' + randomNumber); sys.utils.crypto # This package contains methods for performing basic cryptographic operations.
sha1(message) # This function calculates the SHA-1 digest of a message and returns the result as a hexadecimal string.
Parameters # Name Type Required Description message string yes The string to be converted Returns # string - The result hash as String.
Samples # // converts a company to the string representation var convertedMessage = sys.utils.crypto.sha1('my custom message'); log('SHA-1 string: '+convertedMessage); sha3(message, bits) # This function calculates the SHA-3 digest of a message and returns the result as a hexadecimal string.
Parameters # Name Type Required Description message string yes The string to be converted bits number no Valid number of bits for conversion (default 256) Returns # string - The result hash as String.
Samples # // converts a company to the string representation var convertedMessage = sys.utils.crypto.sha3('my custom message'); log('SHA-3 string: '+convertedMessage); keccak(message, bits) # This function calculates the KECCAK digest of a message and returns the result as a hexadecimal string.
Parameters # Name Type Required Description message string yes The string to be converted bits number no Valid number of bits for conversion (default 256) Returns # string - The result hash as String.
Samples # // converts a company to the string representation var convertedMessage = sys.utils.crypto.keccak('my custom message'); log('Keccak string: '+convertedMessage); jwt.generate(payload, privateKey, algorithm) # Uses a secret key and a algorithm to generate a JWT token of a JSON object.
Parameters # Name Type Required Description payload object yes The payload in JSON format to be encoded. privateKey string yes The private key to sign the token. algorithm string yes The algorithm to use for the signature. Returns # string - The JWT token as String.
Samples # // generates a JWT token var convertedJWT = sys.utils.crypto.jwt.generate({iss: &quot;123&quot;, sub: &quot;456&quot;}, &quot;secret&quot;, &quot;HS256&quot;); log('JWT token: '+convertedJWT); jwt.verify(token, privateKey) # Uses a public key and a JWT token to verify if it is a valid JWT.
Parameters # Name Type Required Description token string yes The JWT token to be verified in String format. privateKey string yes The private key to decode the token. Returns # boolean - True if the token is valid, false otherwise.
Samples # // verifies a JWT token var validJWT = sys.utils.crypto.jwt.verify(&quot;ey.js.wt&quot;, &quot;public&quot;); log('JWT token is valid? : ' + validJWT); jwt.decodeToken(token) # Uses a JWT token to decode the payload.
Parameters # Name Type Required Description token string yes The JWT token to be decoded in String format. Returns # string - The payload as String.
Samples # // decodes a JWT token var tokenJWT = sys.utils.crypto.jwt.decodeToken(&quot;ey.js.wt&quot;); log('JWT token: ' + tokenJWT); sys.utils.time # This package contains methods for working with time.
getTimeZoneOffset(timeZoneId, timestamp) # This function retrieves the offset in milliseconds between the specified time zone and the standard time zone (GMT). If daylight saving time is in effect in the specified time zone at the given timestamp, the offset value is adjusted to account for daylight saving time.
Parameters # Name Type Required Description timeZoneId string yes The time zone identifier (ID) options include:
- US/Hawaii - US/Alaska - US/Pacific - US/Mountain - US/Central - US/Eastern - Canada/Atlantic - America/Buenos_Aires
- For additional available time zones, please refer to the list of time zones for more options. timestamp object no The point in time the time zone offset should be calculated. If it is not specified then the current date time is going to be used. Returns # number - The timezone offset in milliseconds.
Samples # // Logs the specific time zone in hours var offset = sys.utils.time.getTimeZoneOffset('America/Buenos_Aires'); log('offset in hours: '+offset/1000/60/60); setTimeZone(date, timeZoneId) # Apply the offset between given time zone and standard time zone (GMT) to the passed date.
Parameters # Name Type Required Description date object yes The date to apply the given offset timeZoneId string yes The time zone identifier (ID) options include:
- US/Hawaii - US/Alaska - US/Pacific - US/Mountain - US/Central - US/Eastern - Canada/Atlantic - America/Buenos_Aires
- For additional available time zones, please refer to the list of time zones for more options. Returns # object - The date with the time zone applied.
Samples # // Apply the specified time zone to the given date var dateWithOffset = sys.utils.time.setTimeZone(new Date(), 'America/Buenos_Aires'); log('date modified: ' + dateWithOffset); format(date, pattern, timezone) # Apply the pattern and the time zone to a date and return it as string.
Parameters # Name Type Required Description date object yes The date to apply the given pattern and offset pattern string yes The pattern to format the date timezone object no Timezone configuration object or the string code for a time zone. If it is not specified the default app timezone is going to be used.
Valid time zone codes are:
- US/Hawaii - US/Alaska - US/Pacific - US/Mountain - US/Central - US/Eastern - Canada/Atlantic - America/Buenos_Aires
- For additional available time zones, please refer to the list of time zones for more options. Returns # string - The date with the time zone applied.
Samples # // Apply the specified format and time zone to the given date var formattedDate = sys.utils.time.format(new Date(), 'yyyy-MM-dd HH:mm Z', 'America/Buenos_Aires'); log('date formatted is: ' + formattedDate); parse(date, pattern, timezone) # Parse a date string using pattern and time zone and return it as date object.
Parameters # Name Type Required Description date string yes The date string to parse using the given pattern and timezone pattern string yes The pattern to parse the date string timezone string no Timezone configuration object or the string code for a time zone. If it is not specified the default app timezone is going to be used.
Valid time zone codes are:
- US/Hawaii - US/Alaska - US/Pacific - US/Mountain - US/Central - US/Eastern - Canada/Atlantic - America/Buenos_Aires
- For additional available time zones, please refer to the list of time zones for more options. Returns # object - The final parsed date object with the time zone applied.
Samples # // Parse given date using a specific pattern and timezone var parsedDate = sys.utils.time.parse('2020-07-17 13:30', 'yyyy-MM-dd HH:mm', 'America/Buenos_Aires'); log('date is: ' + parsedDate); sys.utils.concurrency # This package contains methods to assist in managing concurrency issues.
tryLock(key, timeout) # This function attempts to acquire a lock for a specified key. It is typically used when multiple threads require synchronization.
Important: Developers must ensure that locks are released. We recommend using try/finally clauses to handle this. While the platform will automatically release locks after the script is fully executed, it is a best practice to do so explicitly.
Parameters # Name Type Required Description key string yes Key to be locked timeout number yes Maximum time in seconds to wait for the lock. Returns # boolean - true if the lock was acquired, false otherwise.
Samples # // locks the key 'lock1' if (sys.utils.concurrency.tryLock('lock1')) { try { sys.logs.info('lock acquired!'); } finally { sys.utils.concurrency.unlock('lock1'); } } lock(key, timeoutOrSuccessCallback, successCallback) # This function acquires a lock for a specified key. It is typically used when multiple threads require synchronization.
Important: Developers must ensure that locks are released. We recommend using try/finally clauses to handle this. While the platform will automatically release locks after the script is fully executed, it is a best practice to do so explicitly.
Parameters # Name Type Required Description key string yes Key to be locked timeoutOrSuccessCallback object no The maximum time in seconds to wait for the lock or the callback executed after the lock is successfully acquired. If this parameter is a function, the lock is released automatically. successCallback function no A callback function that is executed after the lock is successfully acquired and any optional timeout delay has elapsed. Exceptions # tiemout
If lock could not have been acquired.
Samples # // locks the key 'lock1' try { sys.utils.concurrency.lock('lock1'); sys.logs.info('lock acquired!'); //do something sys.utils.concurrency.unlock('lock1'); } catch (e) { sys.logs.error('lock NOT acquired!') } // locks the key 'lock1' using a callback sys.utils.concurrency.lock('lock1', function () { sys.logs.info('lock acquired!'); }); // lock will be released automatically unlock(key) # Releases a lock for a specified key.
Parameters # Name Type Required Description key string yes Key to be released Samples # // acquires and release the lock over key 'lock1' if (sys.utils.concurrency.lock('lock1')) { try { log('lock acquired!'); } finally { sys.utils.concurrency.unlock('lock1'); } } forceUnlock(key) # Releases a lock for a specified key. This is useful for mantenaince purposes.
Parameters # Name Type Required Description key string yes Key to be released Samples # // acquires and force to release the lock over key 'lock1' if (sys.utils.concurrency.lock('lock1')) { try { log('lock acquired!'); } finally { sys.utils.concurrency.forceUnlock('lock1'); } } sys.utils.script # This package contains misc methods useful when scripting.
wait(timeToWait) # Waits blocking the execution of the script.
Parameters # Name Type Required Description timeToWait number yes The number of milliseconds to wait. Samples # // waits for 2 seconds sys.utils.script.wait(2000); // continue execution eval(scriptToEval, context) # Evaluates JavaScript code represented as a string as classic eval but storing code to be displayed in case of errors.
Parameters # Name Type Required Description scriptToEval string yes Script to be evaluated. context object no An object that will serve as the reference during evaluation. It is required when making indirect calls. Returns # object - result of eval
Samples # // waits for 2 seconds sys.utils.script.wait(2000); // continue execution `}),e.add({id:116,href:"/dev-reference/scripting/javascript-es6/",title:"Javascript ES6",description:`Overview # With the recent library version update, our library now supports approximately 40% of ES6 features. In this section, we will provide simple and well-tested syntax examples for some key features. Additionally, you can find a developer reference from the Rhino Library for more detailed information about these and other supported features.
Tested features # Farewell to semicolons! # Our new version implements ASI (Automatic Semicolon Insertion). This means you can now bid farewell to manually adding semicolons at the end of each line.`,content:`Overview # With the recent library version update, our library now supports approximately 40% of ES6 features. In this section, we will provide simple and well-tested syntax examples for some key features. Additionally, you can find a developer reference from the Rhino Library for more detailed information about these and other supported features.
Tested features # Farewell to semicolons! # Our new version implements ASI (Automatic Semicolon Insertion). This means you can now bid farewell to manually adding semicolons at the end of each line.
Let # The let keyword enables you to declare variables that are scoped to the block statement or expression in which they are used.
let foo = 'test' if (true){ let foo = 'test2' log(foo) } log(foo) Const # When you declare a variable using const, it signifies that the identifier cannot be reassigned. This ensures that the value associated with this identifier remains constant and won&rsquo;t change during its lifetime.
const PI = 3.14 log(PI) Map # Map objects are collections of key-value pairs.
let userRoles = new Map() userRoles.set('john', 'admin') log(userRoles.get('john')) For of # The 'for...of' loop allows you to iterate through a data collection with a simple and intuitive syntax. It provides a convenient way to traverse iterable objects like arrays, sets, and more.
In the example below, we demonstrate its usage with a Set, which is also a notable feature:
let chars = new Set(['a', 'a', 'b', 'c', 'c']) for (let char of chars.values()) { log(char) } String templates # String templates, also known as template literals, enable you to create strings with embedded expressions. They provide a more convenient and readable way to construct strings.
With string templates, you can easily interpolate variables and expressions directly into your strings, making the process of string building simpler and cleaner. Here&rsquo;s a basic example:
let name = 'Slingr' let message = \`Hello \${name}!!!\` log(message) Multi-line strings # In pursuit of more legible code, ES6 introduces support for multi-line strings. You can now create strings that span multiple lines without resorting to cumbersome concatenation methods.
Here&rsquo;s how you can declare a multi-line string:
let string = \`This is a test, For multi line Strings\` log(string) Destructuring assignment # Destructuring assignment allows you to unpack values from arrays or properties from objects in a concise and expressive manner.
Here&rsquo;s a brief example of how destructuring assignment works:
let person = {name: &quot;John&quot;, age: 28} let {name, age} = person log(name) log(age) Enhanced object literals # Enhanced object literals provide a concise and expressive way to define and group variables into objects. They enhance the readability and writability of your code.
Here&rsquo;s a simple example of enhanced object literals in action:
function getMobile(manufacturer, model, year) { return { manufacturer, model, year } } var mob = getMobile(&quot;Samsung&quot;, &quot;Galaxy&quot;, &quot;2020&quot;) log(mob.manufacturer) log(mob.model) log(mob.year) Function* (generator function) # ES6 introduces generator functions, denoted by the function* syntax. These functions enable you to define generator objects, which can yield values one at a time, providing more fine-grained control over iteration.
Here&rsquo;s a basic example of a generator function:
function* generator(i) { yield i yield i + 10 } const gen = generator(10) log( gen.next().value) log( gen.next().value) Rhino&rsquo;s developer reference # As mentioned earlier, Rhino does not provide full support for ES6 features. Consequently, certain ES6 functionalities may behave unexpectedly or may not be fully supported.
In such cases, we recommend consulting the Rhino ES6 Support documentation to identify whether any unexpected behavior arises from the library&rsquo;s limitations.
When referencing the Rhino documentation, please be aware that we are utilizing Rhino version 1.7.14 and are sending the VERSION_ES6 flag. This flag facilitates the process of pinpointing the specific feature you need to examine for compatibility or potential limitations.
`}),e.add({id:117,href:"/dev-reference/flows/",title:"Flows",description:"",content:""}),e.add({id:118,href:"/dev-reference/flows/overview/",title:"Overview",description:`Introduction # Flow is a visual programming language tool that utilizes graphical blocks (steps) for creating algorithms.
To describe the logic of a flow, you are required to perform a drag-and-drop action of steps and connect them together. In essence, a Flow is a sequence of predefined and configurable steps that can be employed to execute a wide array of business rules in various parts of an application.
Flow settings # The table below outlines the general properties of flows:`,content:`Introduction # Flow is a visual programming language tool that utilizes graphical blocks (steps) for creating algorithms.
To describe the logic of a flow, you are required to perform a drag-and-drop action of steps and connect them together. In essence, a Flow is a sequence of predefined and configurable steps that can be employed to execute a wide array of business rules in various parts of an application.
Flow settings # The table below outlines the general properties of flows:
Label Type Description Label string This is a human-readable name of the flow. You can use spaces, special characters, and mix upper case and lower case letters. Name string This is the internal name of the flow. It cannot contain special characters or spaces. Description string This is the description of the flow. Debug boolean If enabled, it will print the generated code in logs. General rules # The following list outlines the rules that must be adhered to in all flows:
The flow name must be unique within the app. Each step name must be unique within the flow. Both start and end steps are mandatory. The start step should be unique. Inputs must adhere to their own validation rules. Outputs must adhere to their own validation rules. Steps, with the exception of the context step and expanded versions of subflows, must have at least one connection. Every step, except for start and end steps, should serve as the source or target of at least one connection. Item selection from the context should align with its scope. Considerations # This section provides essential considerations to keep in mind when working with flows:
Currently, input values can only consist of fixed values or references to variables available in the context. Condition expressions are expressed as scripts. Quick start # The flow editor comprises available steps, which can be dragged and interconnected to construct the flow.
Each step serves a distinct function and may include input parameters, generating output data that becomes part of the flow&rsquo;s context for reuse by other steps.
Steps are interconnected by drawing connections from the green rectangle of the source step to the destination step. Some steps feature a red square, indicating the flow to follow in case of an error during step execution.
In the example above, the flow initiates with the start step, followed by the find data step searching for all companies. For each of the companies discovered in the previous step, the update record step is executed, and the corresponding log step is triggered, whether the operation succeeds or not. The flow concludes with the end step.
`}),e.add({id:119,href:"/dev-reference/flows/flow-designer/",title:"The flow designer",description:"",content:""}),e.add({id:120,href:"/dev-reference/flows/flow-designer/overview/",title:"Flow designer overview",description:`Overview # The flow designer is a visual drag-and-drop editor designed to simplify the creation and editing of flows within a Slingr app. To access it, follow these steps:
Navigate to the Builder section of your app. Look for a property that supports flows as an alternative. After selecting this option, an &ldquo;Open editor&rdquo; button should appear. The flow designer consists of three main panels: the step&rsquo;s palette, the canvas, and the properties panel.`,content:`Overview # The flow designer is a visual drag-and-drop editor designed to simplify the creation and editing of flows within a Slingr app. To access it, follow these steps:
Navigate to the Builder section of your app. Look for a property that supports flows as an alternative. After selecting this option, an &ldquo;Open editor&rdquo; button should appear. The flow designer consists of three main panels: the step&rsquo;s palette, the canvas, and the properties panel.
The step&rsquo;s palette # The step&rsquo;s palette is located on the left side of the flow designer and contains all the available steps categorized for building a flow. To start creating a flow, simply drag a step from the palette and drop it onto the canvas. At the top of the panel, there is a search box that allows you to find steps by name.
✅ You can collapse this panel using the &lt;&lt; icon located at its top side to maximize the size of the canvas. ✅ Hovering over a step will give you a short description of what it does The canvas # The canvas is the central and primary panel of the flow designer. It&rsquo;s a grid area where your flow, comprising steps and connections, takes shape. To add a step to the canvas, drag it from the palette and drop it onto the canvas. Once added, the step initializes, and its source or target connection&rsquo;s endpoints appear on its sides. Double-clicking a step expands the right panel to show its properties.
You can rearrange steps within the canvas by dragging and dropping them. Connections between steps are maintained when you move them. The flow designer supports multi-selection of steps for convenience. To select multiple steps, hold the shift key and drag a selection area with your mouse. To deselect, press Escape or click an empty canvas area.
To delete a step, click it once to reveal a delete button in the top-right corner. Clicking this button removes the step from the canvas along with its associated connections.
The context stack # In the top right corner of the canvas, you&rsquo;ll find the context stack. This special step cannot be deleted or connected, but you can reposition it. The context stack displays the values and variables available for use in the different steps of the flow. Learn more about this feature.
The properties panel # The properties panel is on the right side of the flow designer. It provides information related to the entire flow and individual steps. This information is displayed with editable forms for easy configuration.
Clicking the Settings button in the header displays general information about the flow, including its name, label, and description.
When you click on a step within the canvas, the properties panel displays settings specific to that step. The upper section includes basic properties like name, label, and description. The lower section allows you to configure inputs and outputs for that step. For more information on inputs and outputs, refer to the relevant section in the documentation. Feel free to use this improved and structured text in your documentation.
&#x26A0;&#xFE0F; After editing any text input field inside the properties&rsquo; panel, you should press the tab key on your keyboard to save those changes when navigating between tabs or steps. Please note that this action does not automatically save the changes upon closing the designer. To save your changes permanently, you need to click the Save or Apply button in the header. ✅ You can collapse this panel using the &gt;&gt; icon located at its top side to maximize the size of the canvas. Additionally, pressing the Escape key will also collapse the panel. ✅ If the properties&rsquo; panel is collapsed, you can double click on any step within the canvas to expand the properties panel and view the step properties. The header # At the top of the flow designer, you&rsquo;ll find the header of the view in which you&rsquo;ve opened it. This header is the same as that of the particular view, but you might notice that some buttons change when the flow designer is open. Here are the buttons displayed in the header when the flow designer is open:
Close: Closes the flow designer. If changes were made without saving, a warning prompt will appear before closing it. Reset: Reverts the flow and context stack to the state before the last save. Settings: Opens the properties panel and displays the general settings for the flow (such as name, label, and description). ℹ️ Activating the Debug switcher will display information about the flow and how it is transformed into a JavaScript function in the monitor component. Full Screen: Toggles fullscreen mode on and off. Apply: Saves all changes made to the flow while keeping the flow designer open. Save: Saves all changes made to the flow and closes the flow designer. `}),e.add({id:121,href:"/dev-reference/flows/flow-designer/establishing/",title:"Establishing connections",description:"Flows consist of a sequence of steps interconnected in a specific direction. It&rsquo;s crucial to understand how to establish connections between these steps. In the flow designer, connections are created by dragging connectors from a source step&rsquo;s endpoints to a target step or a target connection&rsquo;s endpoint. The connection&rsquo;s endpoints are the small colored squares located at the edges of the steps. They become visible once they are dragged onto the canvas.",content:`Flows consist of a sequence of steps interconnected in a specific direction. It&rsquo;s crucial to understand how to establish connections between these steps. In the flow designer, connections are created by dragging connectors from a source step&rsquo;s endpoints to a target step or a target connection&rsquo;s endpoint. The connection&rsquo;s endpoints are the small colored squares located at the edges of the steps. They become visible once they are dragged onto the canvas. Different steps have different connection endpoints, leading to various types of connections.
Connection types # There are three types of connections that can be established:
Regular connections: Represented by green arrows, these connections define the execution order of the different instructions represented by each step.
Error connections: Indicated by red arrows, error connections come into play when a certain step fails. In such cases, the next step in the flow execution will be the one connected to this error connector.
Else connections: Marked with purple arrows, else connections are only available in conditional steps. If the condition set in this step is not met, the next step in the flow execution will be the one connected to this else connector.
Connection endpoint types # There are four types of connection endpoints:
Green connection endpoints: Located on the right or sometimes the bottom side of all steps (except for the &ldquo;end&rdquo; step). Dragging a connection from one of these endpoints and dropping it onto a target step will establish a normal connection. Red connection endpoints: Positioned on the bottom side of certain steps. Creating a connection from one of these endpoints and connecting it to a target step will create an error connection. Else connection endpoints: Found on the bottom side of Condition type steps. Connecting a connection from one of these endpoints to a target step will establish an else connection. Target connection endpoints: Situated on the left side of group container steps. To establish a connection, drop it onto one of these endpoints. The connection can be regular, error, or else, depending on the source connection endpoint. ℹ️ Connection targets, such as regular steps or target connection&rsquo;s endpoints, will display a dashed outline border when a connection is being dragged on top of them. Deleting a connection # To delete a connection, simply click on the connector, and a delete button will appear. By clicking on that button, the connection will be deleted.
`}),e.add({id:122,href:"/getting-started/getting/first-steps/task-mananger/firststeps/",title:"First steps - Builder",description:`Hi, welcome to the builder! Here, we are going to build the app. As you can see on the left, there is a tree with multiple items, we will call them: nodes. Let’s start building something great.
Creating the &ldquo;Tasks&rdquo; Entity # The tasks entity serves as the central component in the task manager application. It allows users to create, store, and manage task records efficiently. Through this entity, users can access various views of their tasks, granting them the flexibility to organize and handle records according to their preferences and needs.`,content:`Hi, welcome to the builder! Here, we are going to build the app. As you can see on the left, there is a tree with multiple items, we will call them: nodes. Let’s start building something great.
Creating the &ldquo;Tasks&rdquo; Entity # The tasks entity serves as the central component in the task manager application. It allows users to create, store, and manage task records efficiently. Through this entity, users can access various views of their tasks, granting them the flexibility to organize and handle records according to their preferences and needs.
Now we will create the tasks entity and then some actions and views to display the records.
Let&rsquo;s go!
👉 Right-click on the node Model &gt; Entities, and a dropdown menu will be shown.
👉 Click on New Entity.
👉 Fill in the form with the following details:
Label: Tasks Name: tasks Type: Data 👉 Let’s add a simple field. Fill the label with Title, the name with title, the type should be text, and the multiplicity should be one. Click on Add.
👉 Finally, let’s set the record label. The record label is calculated for every record, and it is something that will identify your record. It doesn’t need to be unique but should be human-friendly. Leave the option as Field, and in the dropdown, select Title.
👉 The form should look something like this. If so, click on Create.
Create some adittional fields # Great! Now that we have finished creating the entity, let’s add some more fields:
👉 Right-click on the node Model &gt; Entities &gt; Tasks &gt; Fields, and click New Field.
For every field, you will need to complete the form with some basic information: label, name, type, and multiplicity. Create the following fields with these settings:
Label Name Type Required Default value Notes Number number Auto increment - - This a number that will be incremented for every new task created. Title title Text Yes - The title of the task. Status status Choice Yes To Do This is the status of the task. Possible values will be To do, In progress, Done and Archived Description description HTML No - A longer description of the task. Depending on the type, you might see some additional options at creation time, which is the case for the Status field where you will need to add the four possible statuses: To do, In progress, Done, and Archived. It should look something like this:
Clicking on Save and edit will create the field and will open the details view for that field, where you will be able to change other settings, like the default value and required flag. You can also open it by clicking the field node in the tree. In our sample app, we need to take care of the following things for these fields:
👉 Title: the setting Required should be set to Always.
👉 Status: the setting Required should be set to Always. Also, in the Default value, you should choose Value and then select the value To Do from the dropdown.
Remember to save all the changes. In the end, your structure should look similar to this one:
Create a simple grid view # Now that we have created the fields for the entity, the next step is to create a view so we can see something in our app. For that, we will create a simple grid view that will allow you to list, create, edit, and delete tasks. To create the grid view, follow these steps:
👉 Right-click on the node Model &gt; Entities &gt; Tasks &gt; Views, and a dropdown menu will be shown.
👉 Click on New View &gt; Grid View.
👉 Fill in the form with the following details:
Label: All tasks Name: allTasks Columns: Number, Title, Status. 👉 Click on Create.
Once we have the view, we need to indicate how to navigate to it. Let’s add it to what’s going to be the sidebar of our app. Click the node User interface &gt; Navigation &gt; Main menu, and follow these steps:
👉 Click on Add new menu entry on the top-right of the page, and then click on the option Add view entry.
👉 In the view, select the view All Tasks, and complete the label with All Tasks. You can add an icon if you want.
👉 Click on Create.
Push your changes # Great! We have a basic app already configured.
Let’s see how it looks at runtime, but first, we need to push the changes so the runtime has the latest version of our app.
👉 On the header of the builder, click the button next to your name (The hamburger button).
👉 A dropdown menu will be shown. Click on &quot;Push Changes.&quot;
👉 A popup will appear, displaying the changes you have made. Review them, and if everything looks good, click on &quot;Push Changes.&quot;
Once the process is done, the changes will be reflected in the runtime. To open the runtime, go back to the developer portal, in the Apps page, click the runtime button (The first one). That will automatically open the runtime in a new tab.
🎉
Fantastic!
Let’s wrap this section here; we have made great progress. If you want to learn more, let’s go to the next section: &ldquo;First Look at Our App.&rdquo;
`}),e.add({id:123,href:"/dev-reference/flows/flow-designer/group-container/",title:"Group container steps",description:"Some steps in the flow designer also function as group containers. These group containers have the capability to hold nested steps within them. You can easily identify group container steps by dragging them from the palette and dropping them onto the canvas. Once dropped onto the canvas, you will notice that these steps are wider and taller than regular steps. They also display a &ldquo;Dropped steps here&rdquo; message in the center.",content:`Some steps in the flow designer also function as group containers. These group containers have the capability to hold nested steps within them. You can easily identify group container steps by dragging them from the palette and dropping them onto the canvas. Once dropped onto the canvas, you will notice that these steps are wider and taller than regular steps. They also display a &ldquo;Dropped steps here&rdquo; message in the center.
You can drag and drop other steps from the palette as well as the canvas into a group container step. Once a step is dropped into a group container, it becomes a part of that group, and a linked icon will appear on both the parent and child steps. This creates a sub-context, and the flow execution will proceed with the steps inside the group container before moving on to the next step connected to the group container. This means that you can place multiple steps inside a container and connect them with each other. The first step to be executed within a group container will be the one that has not been the target of any connection. Therefore, it&rsquo;s important to ensure that only one step inside a group container is not the target of a connection.
✅ Group container steps can be resized to make them larger or smaller as needed. To do this, drag their edges from the bottom or right sides. ℹ️ Group containers can be nested at multiple levels. ℹ️ Group container steps will display a dashed outline border when a step is being dragged on top of them. &#x26A0;&#xFE0F; Steps in a container group can only be connected to other steps within the same group. 🚨 Once a step is dropped inside a group container step, you won&rsquo;t be able to drag that step out of the group and drop it onto the canvas. You are only allowed to move it from one group to another one. If you accidentally placed a step inside a group, you can press the reset button to revert changes to the last saved state. `}),e.add({id:124,href:"/dev-reference/flows/flow-designer/validation-rules/",title:"Validation rules",description:`Certain rules must be adhered to in order to successfully save a flow. If any of these rules are not followed after clicking the Apply or Save button, a validation error notification will appear, and the changes won&rsquo;t be saved.
Rules # The flow name must be unique within the app. Each step name must be unique within the flow. Both a Start step and at least one End step are mandatory.`,content:`Certain rules must be adhered to in order to successfully save a flow. If any of these rules are not followed after clicking the Apply or Save button, a validation error notification will appear, and the changes won&rsquo;t be saved.
Rules # The flow name must be unique within the app. Each step name must be unique within the flow. Both a Start step and at least one End step are mandatory. The Start step should be unique. Inputs must pass their respective validation rules. Outputs must pass their respective validation rules. There should be no steps without any connections except for the Context step and expanded versions of subflows. Outside of group containers, every step, except for Start and End steps, should serve as the source and target of at least one connection. Inside of group containers, only one step should not be the target of any connection. This step will be the initial step in the flow execution within the group. `}),e.add({id:125,href:"/dev-reference/flows/steps/",title:"Steps",description:"",content:""}),e.add({id:126,href:"/dev-reference/flows/steps/categories/",title:"Categories",description:"Definition # Steps are predefined components that serve specific functionalities. They are used in a flow to create code in a more graphical way, eliminating the need to learn any specific coding language. Instead, you simply need to drag and drop steps from the steps palette onto the canvas area and then connect them by dragging a connector from a source step to a target step. Steps are categorized, and documentation for each step can be found on the following pages.",content:`Definition # Steps are predefined components that serve specific functionalities. They are used in a flow to create code in a more graphical way, eliminating the need to learn any specific coding language. Instead, you simply need to drag and drop steps from the steps palette onto the canvas area and then connect them by dragging a connector from a source step to a target step. Steps are categorized, and documentation for each step can be found on the following pages.
Categories # System # The first category of steps is labeled &ldquo;System&rdquo;. Here, you&rsquo;ll discover steps that aid in constructing your flow. For instance, you&rsquo;ll find the logger step, which logs information to your application&rsquo;s monitor, and the set var step, which creates a new variable in the context. The steps in this category include: start, end, logger, script, and set var. Documentation for each of these steps can be found on the following pages.
Control # The second category, &ldquo;Control&rdquo;, contains steps that allow you to work with structures commonly used in programming languages and more. The steps in this category include: For Each, If, Subflow, Try-Catch, and While. You can find the documentation for each of these steps on the following pages.
Data # The third category, &ldquo;Data&rdquo;, includes steps related to the data stored in your application. Here, you&rsquo;ll find useful steps for searching, creating, deleting, updating records, and more. The steps in this category comprise: Create record, Delete Data, Delete Record, Execute Action on data, Execute Action on record, Execute Global Action, Fin Data, Find Record, Find Record by id, Save Record, and Update Record. You can access the documentation for each of these steps on the following pages.
User Interface # The final category, &ldquo;User Interface&rdquo;, provides steps for controlling the functionality of your application&rsquo;s user interface. The steps in this category include: Download File, Go Back, Go To View, Open Action, Open External Link, Reload, Show Message, Start Task, and Update task. Detailed documentation for each of these steps can be found on the following pages.
`}),e.add({id:127,href:"/dev-reference/flows/steps/system-steps/",title:"System steps",description:`Start step # General Info # Category Description Rules System Initiates the flow. - A single start step is mandatory. Inputs # No configuration required.
Outputs # No configuration required.
Sample # The flow begins with the logger step, which logs a message, and concludes with the end step. End step # General Info # Category Description Rules System Marks the end of the flow. Optional, and can return a result.`,content:`Start step # General Info # Category Description Rules System Initiates the flow. - A single start step is mandatory. Inputs # No configuration required.
Outputs # No configuration required.
Sample # The flow begins with the logger step, which logs a message, and concludes with the end step. End step # General Info # Category Description Rules System Marks the end of the flow. Optional, and can return a result. - At least one end step is required. Inputs # Label Type Required Visibility Description Return result boolean no Always When true, it returns the final result of the flow. Result object no config.returnResult The final result to be returned by the flow. Outputs # No configuration required.
Sample # The flow begins with the logger step, logs a message, and concludes with the end step. Logger step # General Info # Category Description System Logs application events. Inputs # Label Type Required Default Visibility Description level choice yes Info Always Log importance level.
Possible values: Info, Warning, Error, Debug Message text yes - Always Message to be logged, supports dynamic arguments for formatting. Arguments text no - Always Arguments for the format string. Zero or more allowed. Outputs # Name Type Description result string The name of the next element in the list. Sample # The flow begins with the logger step, logs a message, and concludes with the end step. Script step # General Info # Category Description System Executes custom code. Inputs # Label Type Required Visibility Description code script yes Always Custom code to execute. Outputs # Name Type Description result object The final result of the script execution. Sample # The flow begins with the set script step, which executes custom code, and concludes with the end step. In case of an error during execution, the error will be logged, and the execution will terminate. Set var step # General Info # Category Description System Defines a new variable in the current execution context. Inputs # Label Type Required Default Visibility Description Name text yes - Always - Value Type choice yes Fixed Always Possible values: Fixed, Script, Expression Script Value script config.valueType is SCRIPT - config.valueType is SCRIPT - Fixed Value text config.valueType is FIXED - config.valueType is FIXED - Expression Type choice config.valueType is EXPRESSION - config.valueType is EXPRESSION Possible values:
Current User,
Field Value Context Item object config.expressionType.name is FIELD_VALUE - config.expressionType.name is FIELD_VALUE - Field entityField config.expressionType.name is FIELD_VALUE - config.expressionType.name is FIELD_VALUE - Outputs # Name Type Description resultVariable record/field The variable created. Sample # The flow begins with the set var step, which defines a new variable in the context, and concludes with the end step. `}),e.add({id:128,href:"/dev-reference/flows/steps/control-steps/",title:"Control steps",description:"List iterator # General info # Category Description Control The List Iterator is a control flow statement designed for iterating through items within a collection, such as result sets or multiple fields. This step facilitates the inclusion of other steps within it. The behavior of this step encapsulates the behavior of the nested steps, enabling structured traversal of the collection. Inputs # Label Type Required Visibility Description Iterable list resultSet / field(many) yes Always The list of elements to be traversed.",content:`List iterator # General info # Category Description Control The List Iterator is a control flow statement designed for iterating through items within a collection, such as result sets or multiple fields. This step facilitates the inclusion of other steps within it. The behavior of this step encapsulates the behavior of the nested steps, enabling structured traversal of the collection. Inputs # Label Type Required Visibility Description Iterable list resultSet / field(many) yes Always The list of elements to be traversed. Outputs # Name Type Description nextElementName record / field The name of the next element in the list. Sample # The flow initiates, the "foreach" step updates and saves each of the records discovered in the "find data" step, and finally, the execution concludes with the "end" step. Condition # General info # Category Description Control The &ldquo;Condition&rdquo; step executes the subsequent steps in the path only if the specified condition evaluates to &ldquo;truthy.&rdquo; Inputs # Label Type Required Default Visibility Description Condition type choice yes Expression Always Type of condition to be checked. Possible values are Expression and Script Expression record record Condition type is expression - Condition type is expression The record instance to be used to check condition. Expression condition confition Condition type is Expression. Expression record has been defined - Condition type is Expression. Expression record has been defined The condition to be valued as true. Script condition condition Condition type is Script - Condition type is Script The script condition to be evaluated as true. Outputs # No configuration required.
Sample # The flow starts, the if step evaluates the condition, if the condition is true, runs the script and then the execution finished with the end step. Subflow # General info # Category Description Control A subflow is a grouping of steps that are condensed into a single step within the execution path. It can be employed to simplify the visual representation of a flow, or to bundle a set of steps as a reusable component used across various instances. Inputs # No configuration required.
Outputs # No configuration required.
Sample # The flow initiates, and the "subflow" step executes the set of steps specified within the subflow. If an error occurs during the execution of these steps, the error will be recorded, and the execution will be terminated. Error handler # General info # Category Description Control The error handler step enables you to define a code block that is examined for errors while it runs. This step also permits the inclusion of other steps within it. The behavior of this step encompasses the behavior of the nested steps, providing error-handling capabilities. Inputs # No configuration required.
Outputs # No configuration required.
Sample # The flow begins, and the "try-catch" step runs the script. If an error occurs during the execution of the script, the error will be recorded, and the execution will be terminated. Loop # General info # Category Description Control This control flow statement enables the repeated execution of steps based on a specified boolean condition. It supports the inclusion of other steps within it, thus allowing for the nesting of steps. Inputs # Label Type Required Default Visibility Description Condition type choice yes Expression Always Type of condition to be checked. Possible values are Expression and Script Expression record record Condition type is expression - Condition type is expression The record instance to be used to check condition. Expression condition confition Condition type is Expression. Expression record has been defined - Condition type is Expression. Expression record has been defined The condition to be valued as true. Script condition condition Condition type is Script - Condition type is Script The script condition to be evaluated as true. Outputs # No configuration required.
Sample # The flow commences, and the "while" step logs as long as a specified condition remains true. Subsequently, the execution concludes with the "end" step. `}),e.add({id:129,href:"/dev-reference/flows/steps/data-steps/",title:"Data steps",description:'Create record # General info # Category Description Data This step generates a new record instance within the database. Inputs # Label Type Required Visibility Description Entity entity yes Always Entity to create a new record instance. Data dataBody yes Always Data to be used to create record. Outputs # Name Type Description createRecord record Create record instance. Sample # The flow begins, and the "create record" step generates a new record.',content:`Create record # General info # Category Description Data This step generates a new record instance within the database. Inputs # Label Type Required Visibility Description Entity entity yes Always Entity to create a new record instance. Data dataBody yes Always Data to be used to create record. Outputs # Name Type Description createRecord record Create record instance. Sample # The flow begins, and the "create record" step generates a new record. Following this, the execution concludes with the "end" step. Should an error occur during the record creation process, the error will be logged, and the execution will terminate. Delete data # General info # Category Description Data This step deletes data from the specified entity. Inputs # Label Type Required Visibility Description Entity entity yes Always The entity to delete data. Query query no config.entity The query used to filter records to be deleted. Wait task to finish boolean no Always Flag to set if the deletion should wait for the job to finish. Outputs # Name Type Description taskId text The task ID in charge of the execution of the deletion. Sample # The flow initiates, and the "delete data" step removes data from an entity. Subsequently, the execution concludes with the "end" step. If any errors arise during the data deletion process, they will be logged, and the execution will be terminated. Delete record # General info # Category Description Data This step deletes the specified record. Inputs # Label Type Required Visibility Description Record record yes Always The record instance to be deleted. Outputs # Name Type Description deletedRecord record The deleted record. Sample # The flow initiates, and the "delete record" step deletes a specific record. Subsequently, the execution concludes with the "end" step. If any errors occur during the record deletion process, they will be logged, and the execution will be terminated. Execute action on data # General info # Category Description Data This step performs an action on the records returned by a query. Inputs # Label Type Required Visibility Description Entity entity yes Always The entity to which the actions belongs. Action entityAction yes Always The action to be executed Query query yes config.entity A filter used to identify the records on which to execute the action. Data dataBody no Always Precise data to be transmitted to the action. Wait task to finish boolean no Always A flag to indicate whether the action should wait for the task to finish. Outputs # Name Type Description taskId text The task ID in charge of the execution of the action. Sample # The flow begins, and the "execute action on data" step executes actions on the identified records. Subsequently, the execution concludes with the "end" step. If an error occurs during the action execution, the error will be logged, and the execution will be terminated. Execute action on record # General info # Category Description Data This step performs an action on one record Inputs # Label Type Required Visibility Description Entity entity yes Always The entity to which the actions belongs. Action entityAction yes Always The action to be executed. Record record yes Always The record to be modified by the action. Data dataBody no Always Precise data to be transmitted to the action. Outputs # Name Type Description actionResult object A record or a custom response, depending on the action&rsquo;s configuration. Sample # The flow initiates, and the "execute action on record" step performs actions on a record. Subsequently, the execution concludes with the "end" step. In the event of an error during the action execution, the error will be logged, and the execution will terminate. Execute global action # General info # Category Description Data This step executes an action at the entity level, which implies that the action does not require any parameters to specify affected records. Inputs # Label Type Required Visibility Description Entity entity yes Always The entity to which the actions belongs. Action entityAction yes Always The action to be executed. Data dataBody no Always Precise data to be transmitted to the action. Wait task to finish boolean no Always A flag to indicate whether the action should wait for the task to finish. Outputs # Name Type Description taskId text The task ID in charge of the execution of the action. Sample # The flow begins, and the "execute global action" step executes an action at the entity level. Subsequently, the execution concludes with the "end" step. If an error occurs during the action execution, the error will be logged, and the execution will be terminated. Find data # General info # Category Description Data This step retrieves data using a specified query. Inputs # Label Type Required Visibility Description Entity entity yes Always The entity to which the data belongs. Query query no config.entity The query used to filter records Outputs # Name Type Description recordsResultSet resultSet A collection of records that can be iterated through. Sample # The flow initiates, and the "find data" step conducts a search for data using a query. Following this, the retrieved data is logged, and the execution concludes with the "end" step. Find record # General info # Category Description Data This step retrieves a record using a specified query. Inputs # Label Type Required Visibility Description Entity entity yes Always The entity to which the data belongs. Query query no config.entity The query used to filter records Outputs # Name Type Description resultRecord record The record instance that matches the filtering. Sample # The flow begins, and the "find record" step searches for a specific record using a query. Subsequently, the located record is logged, and the execution concludes with the "end" step. Find record by Id # General info # Category Description Data This step retrieves a record using it ID. Inputs # Label Type Required Visibility Description Entity entity yes Always The entity to which the data belongs. Record ID text yes Always ID of the record. Outputs # Name Type Description resultRecord record The record instance. Sample # The flow begins, and the "find record by id" step searches for a specific record by its unique identifier. Following this, the identified record is logged, and the execution is finalized with the "end" step. Lock record # General info # Category Description Data Acquires a lock for a specified record. This method is recommended when multiple threads attempt to access the same record, especially in scenarios involving concurrent execution of listeners or actions. Inputs # Label Type Required Visibility Description Record record yes Always The record instance to be locked. Outputs # No configuration required.
Sample # The flow initiates, and the "lock" step obtains a lock for a specified record to prevent any listener or action from altering the record while we perform subsequent actions. Following this, the "update record" step modifies the record's data, and these changes are saved using the "save record" step. Subsequently, a success message is logged with the "logger" step, and the execution concludes with the "end" step.
In the event that the lock cannot be acquired, an error message will be logged using the "logger" step. Update record # General info # Category Description Data This step manipulates a record, applying changes to it and storing these modifications in the database, effectively making the changes permanent. Inputs # Label Type Required Visibility Description Record object yes Always The record instance to be saved into the database after applying changes. Data dataBody yes Always Data to be used to update record. Outputs # Name Type Description updatedRecord record The updated record instance. Sample # The flow begins, and the "update record" step modifies the data of a record. Subsequently, the changes are saved by the "save record" step, and the execution concludes with the "end" step. If an error occurs, it will be logged, and the execution will be terminated. Save record # General info # Category Description Data This step saves a record in the database, rendering the changes made to it permanent. Inputs # Label Type Required Visibility Description Record object yes Always The record instance to be saved into the database after applying changes. Outputs # Name Type Description savedRecord record The saved record instance. Sample # The flow begins, and the "find record by id" step searches for a specific record by its unique identifier. Following this, the identified record is logged, and the execution is finalized with the "end" step. `}),e.add({id:130,href:"/dev-reference/flows/steps/ui-steps/",title:"UI steps",description:`Download file # General info # Category Description UI Performs a download of the specified file. Inputs # Label Type Required Visibility Description File ID text yes Always The ID of the file to download. Outputs # No configuration required.
Sample # The flow begins, and the "download file" step downloads the specified file. If an error occurs during the file download, the error will be logged, and the execution will be terminated.`,content:`Download file # General info # Category Description UI Performs a download of the specified file. Inputs # Label Type Required Visibility Description File ID text yes Always The ID of the file to download. Outputs # No configuration required.
Sample # The flow begins, and the "download file" step downloads the specified file. If an error occurs during the file download, the error will be logged, and the execution will be terminated. Go back # General info # Category Description UI Goes back in the browser navigation history. Inputs # No configuration required.
Outputs # No configuration required.
Sample # The flow initiates, and the "go back" step navigates back in the browser's navigation history. Subsequently, the execution concludes with the "end" step. Go to view # General info # Category Description UI Navigates to the specified view in the UI. Inputs # Label Type Required Default Visibility Description View view yes - Always The view to navidate to. View type choice config.view.type is ENTITY_VIEW Read Only config.view.type is ENTITY_VIEW In case of grid or workflow views define the view type to redirect. Possible values are: Read Only
Create
Edit Record ID text config.view.type is ENTITY_VIEW - config.view.type is ENTITY_VIEW ID of the record. When this field is set the app navigates to the detail read-only view of the record. Filters query no - config.view.type is COLLECTION_VIEW config.view.type is CARDS_VIEW In case of grid or workflow views define some view filters to be applied. Parameters query no - config.view.type is CUSTOM_VIEW In case of custom views you can define some view parameters to be applied. Those parameters are transformed into URL query parameters. Outputs # No configuration required.
Sample # The flow begins, and the "go to view" step navigates to the specified view. Subsequently, the execution concludes with the "end" step. Open action # General info # Category Description UI Open the specified action modal in the UI. Inputs # Label Type Required Visibility Description Entity entity yes always The entity that the action belongs to. Action entityAction yes Always The action to be executed. Action view view no Always The action view to be used. If it is not specified the default one is going to be used. Record IDs text config.action.type is not GLOBAL_ENTITY config.action.type is not GLOBAL_ENTITY The condition to be evaluated as true. Outputs # No configuration required.
Sample # The flow initiates, and the "open action" step opens the specified action modal in the UI. Following this, the execution concludes with the "end" step. Open external link # General info # Category Description UI Opens the specified link in the browser. Inputs # Label Type Required Default Visibility Description URL text yes - Always External URL to open. Open link in a new tab boolean yes true Always If true external URL is opened in a new tab of the browser. Otherwise the URL will be opened in same tab. Outputs # No configuration required.
Sample # The flow begins, and the "open external link" step opens the specified external URL. Subsequently, the execution concludes with the "end" step. Reload # General info # Category Description UI Reloads the app. Inputs # Label Type Required Visibility Description Go to default view boolean yes Always If set to &ldquo;true,&rdquo; when the app is reloaded, the user will be directed to the default view, which is the view displayed when the app is loaded after login. If set to &ldquo;false,&rdquo; the current page will be reloaded. Outputs # No configuration required.
Sample # The flow begins, and the "reload" step refreshes the app. Subsequently, the execution concludes with the "end" step. Show message # General info # Category Description UI Displays a message in the UI. Inputs # Label Type Required Default Visibility Description Target choice yes caller Always Type of users to send the message.
Possible values are: Caller Users All users Users text config.target is users - config.target is users Specific users to send the message. Title text yes - Always The title to be shown on message. Message text yes - Always The message content to be shown on message. It supports some basic HTML tags. Type choice yes Information Always Define the style for the message. Possible values are: Information Success Warning Error Keep visible boolean yes - Always If true the message won’t be closed automatically and the user has to close it manually. Outputs # No configuration required.
Sample # The flow initiates, and the "show message" step displays the specified message. Following this, the execution concludes with the "end" step. Start task # General info # Category Description UI Displays the specified task in the top right. Inputs # Label Type Required Visibility Description Task ID text yes Always The ID of the task to be displayed on the tasks menu. Title text yes Always The message to be displayed on the tasks menu as the title. Message text no Always The complimentary message to be displayed as a subtitle. Outputs # No configuration required.
Sample # The flow begins, and the "start task" step displays the specified task in the top right corner. If an error occurs during the task display, the error will be logged, and the execution will be terminated. Update task # General info # Category Description UI Updates the status of a task displayed in the top right. Inputs # Label Type Required Visibility Description Task ID text yes Always The ID of the task to be displayed on the tasks menu. Title text yes Always The message to be displayed on the tasks menu as the title. Message text no Always The complimentary message to be displayed as a subtitle. Status text no Always The status of the task, which can be updated to running, success, or error. The initial status is running. Outputs # No configuration required.
Sample # The flow initiates, and the "update task" step updates the status of the specified task. If an error occurs during the task update, the error will be logged, and the execution will be terminated. `}),e.add({id:131,href:"/getting-started/getting/first-steps/task-mananger/firstlook/",title:"First look at our App",description:`Welcome back! In this section, let&rsquo;s take a first look at the app we&rsquo;ve been working on. Although it&rsquo;s currently a very basic setup, we&rsquo;ll keep working on it to enhance its features.
Runtime Tasks grid view # 👉 If you followed the previous instructions correctly, your view should look similar to this:
Create a task # 👉 In the top-right corner of the view, you&rsquo;ll find a Create button. Click on it, complete the form, and hit Create to see a read-only view of your new task:`,content:`Welcome back! In this section, let&rsquo;s take a first look at the app we&rsquo;ve been working on. Although it&rsquo;s currently a very basic setup, we&rsquo;ll keep working on it to enhance its features.
Runtime Tasks grid view # 👉 If you followed the previous instructions correctly, your view should look similar to this:
Create a task # 👉 In the top-right corner of the view, you&rsquo;ll find a Create button. Click on it, complete the form, and hit Create to see a read-only view of your new task:
👉 To go back to the table, you can either click on the element in the sidebar or use the All Tasks link located at the top-left corner of the view:
Runtime Tasks actions and filters # 👉 By default, this view allows you to create new tasks, view and edit existing ones, and delete them.
👉 You can also filter tasks using the listing headers, as well as export and import records. All of this was automatically generated from your app definition. Pretty awesome, right?
Next step # I understand that our app is still very basic, but in the next section, we&rsquo;ll add some actions to our entity, allowing us to change the status of a task without having to go inside the edit view. For now, let&rsquo;s go to the builder tab or open it through the developer portal. See you in the next section!
`}),e.add({id:132,href:"/dev-reference/flows/steps/library-steps/",title:"Library steps",description:`Definition categories # Description # Flow Steps Libraries empower you to define your custom steps and seamlessly integrate them into your workflows. It&rsquo;s imperative to specify inputs, outputs, and the script that a step will execute. Once defined, this library becomes a reusable asset accessible across various parts of your application.
Category # In contrast to predefined steps, you have the flexibility to configure the category of your step library.`,content:`Definition categories # Description # Flow Steps Libraries empower you to define your custom steps and seamlessly integrate them into your workflows. It&rsquo;s imperative to specify inputs, outputs, and the script that a step will execute. Once defined, this library becomes a reusable asset accessible across various parts of your application.
Category # In contrast to predefined steps, you have the flexibility to configure the category of your step library.
Category examples # By Business Logic: Group a set of steps tailored to a specific business entity or process.
By Generic Functionalities: Create steps with frequently used operations that streamline the development of your workflows.
In the Flow Editor, we have the libraries divided by the configured categories Inputs and Outputs # Description # Flow Step Libraries enable you to define your custom steps and seamlessly integrate them into your workflows. To create a step, it&rsquo;s necessary to specify inputs, outputs, and the script that the step will execute. Once configured, this library becomes a reusable asset that can be conveniently utilized in various parts of your application.
Inputs # Inputs are versatile and optionally configurable. Each input can be customized extensively, from defining its data type to establishing general rules. This empowers users to employ expressions and scripts to tailor the behavior of the library step within the Flow Editor.
In the Flow Editor, we have the libraries divided by the configured categories Outputs # Outputs are also optional and each output has its Type.
Advantages # Why Use Step Libraries?
Reusability # Step Libraries offer a powerful mechanism for code reuse. You write a step once, and it becomes available for use in any flow within your application. This eliminates redundant effort and promotes efficiency.
Custom Business Logic # Not all business logic fits neatly into standard pre-defined steps. Step Libraries empower you to tackle complex scenarios by allowing you to insert custom JavaScript code. This flexibility ensures that you can handle a wide range of situations according to your specific needs.
Facilitating Collaboration # Step Libraries can facilitate new dynamics between citizen developers and traditional developers. When an entity used within a Step Library is updated, the library may need manual updates to accommodate changes. This collaborative approach ensures that both citizen developers and traditional developers can work together effectively to maintain and enhance the functionality of your application.
Refactoring # When you make changes to a Step Library, it&rsquo;s crucial for developers to be aware of the potential impacts due to the following rules:
Code Modifications # If the code within a Step Library is altered, all Flows utilizing this step will automatically adopt the new behavior. Therefore, any changes to the code will propagate across relevant Flows.
Input Modifications # Modifying the inputs of a Step Library will inevitably result in changes to how the Step is used within your flows. It&rsquo;s important to note that altering Step library inputs will necessitate updates in all the places where this Step is used.
Entity Updates # When an entity utilized within a Step Library undergoes changes or updates, the Step Library will require manual adjustments to accommodate these modifications. This ensures that the Step Library remains synchronized with the evolving entity.
Example # Step Library Definition: To begin, we define our Business Logic step. In this example, it accepts a list as input and returns a list after applying a specific process to each element. Enhancing Workflow: Following the definition of the Business Logic step, we navigate to the Flow Editor and realize that we need to process multiple lists. To simplify this operation, we decide to add a Library Step that streamlines the concatenation of these lists. Ready for Use: With the new Step Library in place, we return to the Flow Editor, where the newly defined steps are now readily available for use. Data Collection: In our sample scenario, we gather the data to be processed using Set Var steps. Once all the data lists are collected, the Concat List step effectively merges these values, preparing them for processing by the Business Logic Step. `}),e.add({id:133,href:"/getting-started/getting/first-steps/task-mananger/adding/",title:"Adding actions to an entity",description:`In this section, we will be working with the actions of an entity.
Let's go back to the builder and get to work. We already have the basic operations to create, edit, and delete tasks. However, it would be better to have a custom workflow that enforces some rules. For example, a task can only be moved to &quot;In progress&quot; if it is in the status &quot;To do&quot;. To create the workflow, we will:`,content:`In this section, we will be working with the actions of an entity.
Let's go back to the builder and get to work. We already have the basic operations to create, edit, and delete tasks. However, it would be better to have a custom workflow that enforces some rules. For example, a task can only be moved to &quot;In progress&quot; if it is in the status &quot;To do&quot;. To create the workflow, we will:
✅ Create actions to move the task through the different statuses. ✅ Do not allow modification of the status manually. ✅ Add a column to the grid view. Create the action &ldquo;Start work&rdquo; # 👉 Right-click on the node Model &gt; Entities &gt; Tasks &gt; Actions, a dropdown menu will be shown, click &quot;New Action&quot;.
👉 Fill in the form with:
Label: Start work Name: startWork. 👉 In the Preconditions section, you will indicate under which conditions the action can be executed. For the &quot;startWork&quot; action, the precondition is that the field &quot;Status&quot; must be &quot;To do&quot;. This can be indicated with an expression. Select the option &quot;Expression&quot; for Preconditions, then set up the following expression by clicking on &quot;Add new rule&quot; and configure it like this:
👉 In the field &quot;Action script&quot;, add the following script to the body of the function:
record.lock(function(record) { record.field('status').val('inProgress'); sys.data.save(record); }); Create some more actions # Now it&rsquo;s your turn!
In the following table, you will find the settings for the actions required to handle different task statuses. Please repeat the instructions from the previous step to create each action.
Label Name Precondition Action script Complete complete Status equals to In progress record.lock(function(record) { record.field('status').val('done'); sys.data.save(record); }); Archive archive Status NOT equals toArchived record.lock(function(record) { record.field('status').val('archived'); sys.data.save(record); }); Stop work stopWork Status equals to In progress record.lock(function(record) { record.field('status').val('toDo'); sys.data.save(record); }); Reopen reopen Status equals to Done or Archived record.lock(function(record) { record.field('status').val('toDo'); sys.data.save(record); }); Limit write access to status field # Good, now we have all the actions to manage the workflow! However, there is one problem: anyone can simply change the status field by editing the task. This is not what we want; instead, we want people to follow the actions workflow we have defined. To achieve this, we need to make the Status field read-only:
Click on the node Model &gt; Entities &gt; Tasks &gt; Fields &gt; Status. Select the Display options tab. For the option Read only select Always. Save changes by clicking on Apply. To keep it simple, we just made the field read-only. However, the correct way to do it is to remove permissions to change that field, which will be enforced at the API level and not just the UI. We will see that later. Adding a column to the grid view # Finally, we will add a column to the grid view that shows the actions available for that record:
Click on the node Model &gt; Entities &gt; Tasks &gt; Views &gt; All tasks. Inside List settings, set the option &quot;Record menu&quot; to &quot;All&quot; and set the flag &quot;Display record menu column&quot; to &quot;active&quot;. Save changes by clicking on &quot;Apply&quot;. Awesome! Go ahead and push the changes. To do that, you need to click the icon next to your username (The hamburger icon). A drop-down menu will be shown, then click &quot;Push changes&quot;.
🎉
Congratulations! Now you have learned how to create actions to model the behavior of the entity fields and records.
Let&rsquo;s wrap up this session here. Go to the runtime tab, and we will continue on to the next session &quot;Testing actions on runtime&quot;.
`}),e.add({id:134,href:"/getting-started/getting/first-steps/event-planner/",title:"Event Planner App",description:"",content:""}),e.add({id:135,href:"/getting-started/getting/first-steps/task-mananger/",title:"Task Manager App",description:"",content:""}),e.add({id:136,href:"/getting-started/",title:"Get",description:"Prologue Doks.",content:""}),e.add({id:137,href:"/getting-started/getting/first-steps/task-mananger/testing/",title:"Testing actions on runtime",description:`In this section, we will examine the functionality of the actions we implemented in the previous section.
Discover the actions # As you can observe in the grid view, a new column called &ldquo;Actions&rdquo; has been added. You can execute these actions from the &ldquo;Actions&rdquo; column or from the following locations:
From &ldquo;All tasks&rdquo; view actions column # From &ldquo;All tasks&rdquo; view main menu # From task record view main menu # Great!`,content:`In this section, we will examine the functionality of the actions we implemented in the previous section.
Discover the actions # As you can observe in the grid view, a new column called &ldquo;Actions&rdquo; has been added. You can execute these actions from the &ldquo;Actions&rdquo; column or from the following locations:
From &ldquo;All tasks&rdquo; view actions column # From &ldquo;All tasks&rdquo; view main menu # From task record view main menu # Great! Our actions are now running. Please verify that the preconditions are working as expected. Additionally, ensure that in the edit view, the status cannot be changed. If you encounter any issues, refer back to the previous section to see if there is something you might have missed.
That’s it for this section. In the next one, we will create a new type of view that complements our current implementation. For more information, proceed to the next section: &ldquo;Creating a workflow view.&rdquo;
`}),e.add({id:138,href:"/getting-started/getting/first-steps/task-mananger/creatingworkflow/",title:"Creating a workflow view",description:`At this point, we have an app with some fantastic features up and running. However, you might desire a different design for a specific use case. Let&rsquo;s consider adding a workflow view to make our app look even more impressive. To provide you with a visual representation of what I mean, here&rsquo;s an example of how it would look:
Create the workflow view # Isn&rsquo;t it awesome? Let&rsquo;s create the workflow view:`,content:`At this point, we have an app with some fantastic features up and running. However, you might desire a different design for a specific use case. Let&rsquo;s consider adding a workflow view to make our app look even more impressive. To provide you with a visual representation of what I mean, here&rsquo;s an example of how it would look:
Create the workflow view # Isn&rsquo;t it awesome? Let&rsquo;s create the workflow view:
Right-click on the node Model &gt; Entities &gt; Tasks &gt; Views and select New view &gt; Workflow view from the dropdown menu.
Fill in the form with:
Label: Task Board Name: taskBoard Click on Create and edit. Add some card configuration details # Once the workflow view is created, its configuration details will appear. The first thing to do is to set up the card settings:
In the Header setting, select Script and add the following code in the function&rsquo;s body: return 'Task #' + record.field('number').val(); In the Summary setting, leave Field selected, and in the Summary field select Title.
Click on Apply to save changes.
Create a rank field # Before defining the columns, we need to add a new field to the entity that will be necessary to enable ranking of records:
Right-click on the node Model &gt; Entities &gt; Tasks &gt; Fields and select New Field.
Fill in the form with:
Label: Rank Name: rank Type: Rank Click on Create and edit.
Go to the Display options tab.
Set the option Visible to Never. This is to hide this field as we don’t want to show it to our users. We will only use it internally to keep the rank of tasks.
Click on Save to save changes.
Create the view columns # Now we are ready to create the columns in the workflow view
Click on the node Model &gt; Entities &gt; Tasks &gt; Views &gt; Task board &gt; Columns.
Click on the Create button on the top-right of the page.
Fill in the form with:
Label: To do Filters: Status equals To do Set the flag Allow to rank records and select the field Rank in Rank field.
Click on Create to save the column.
Repeat the same process to create these two additional columns:
Label Filters In progress Status equals to In progress Done Status equals to Done Define transitions # Once you have the columns we need to define the transitions that will allow moving a card from one column to another:
Click on the node Model &gt; Entities &gt; Tasks &gt; Views &gt; Task board &gt; Transitions.
Click on the Create button on the top-right of the page.
Fill in the form with:
Label: Start work Source column: To do Target column: In progress Action: Start work (tasksStartWork) Click on Create to save the transition. Repeat the same process to create these other transitions:
Label Source column Target column Action Complete In progress Done Complete (tasksComplete) Stop work In progress To do Stop work (tasksStopWork) Reopen from done Done To do Reopen (tasksReopen) General improvements to the view # We are almost there! Let&rsquo;s do a few improvements:
Click on the node Model &gt; Entities &gt; Tasks &gt; Views &gt; Task board &gt; CRUD actions &gt; Tasks.
For Create, Read and Update set the flag Open in modal to active and click on Apply. This will allow the opening of tasks in a modal.
Click on the node Model &gt; Entities &gt; Tasks &gt; Views &gt; Task board.
Inside Cards settings, in the setting Record menu select Some.
Then in Available actions click on Add and select the action Archive (tasksArchive). This is to be able to archive tasks because we didn’t create a column for the Archived status to keep this view clean.
Add the view on the interface navigation # Click on the node User interface &gt; Navigation &gt; Main menu.
Click on the Add new menu entry button on the top-right of the page and select Add view entry.
Fill in the form with:
View: Task board Label: Task board Icon: select the one you like the most! Click on Create to save the menu entry. 🥳
Great! We are done. I know this section was difficult so thanks for sticking with it.
Now let&rsquo;s just push the changes and open the runtime tab.
In the next section, we are going to see the changes we have made.
`}),e.add({id:139,href:"/dev-reference/flows/context/",title:"Context",description:"",content:""}),e.add({id:140,href:"/dev-reference/flows/context/context-overview/",title:"Context Overview",description:`Summary # Variables can be injected into a step&rsquo;s inputs based on the results of other steps, utilizing what is known as the &ldquo;Context.&rdquo; The Context proves invaluable in various scenarios. For instance, it allows you to update a record using data generated by a previous &ldquo;create-record&rdquo; step. Additionally, you can log error results using a &ldquo;try-catch&rdquo; step or create a record using data derived from action parameters.
Context stack # Adding items to the context stack # Certain steps have the capability to output their results into the execution context of Flows.`,content:`Summary # Variables can be injected into a step&rsquo;s inputs based on the results of other steps, utilizing what is known as the &ldquo;Context.&rdquo; The Context proves invaluable in various scenarios. For instance, it allows you to update a record using data generated by a previous &ldquo;create-record&rdquo; step. Additionally, you can log error results using a &ldquo;try-catch&rdquo; step or create a record using data derived from action parameters.
Context stack # Adding items to the context stack # Certain steps have the capability to output their results into the execution context of Flows. For example, the &ldquo;createRecord&rdquo; step can output the created record, which can then be included in the context stack by selecting &ldquo;put in context.&rdquo; Depending on where the Flow is executed from, the context stack may also include default items. For instance, if the Flow is executed from an action, the action&rsquo;s parameters become accessible in the context stack.
Utilizing context items in inputs # By default, an input is designed to accept a static value. However, some inputs are equipped to accept values from the context. In such cases, you can choose a value from the context based on its scope.
Scope # Each item within the context stack operates within its designated scope. Context items are exclusively available when editing a step that follows the step responsible for outputting the context item. For instance, you cannot select context items from steps located outside the execution flow of the step that produces the context. Similarly, you cannot choose an output from a step that precedes the step responsible for generating the context.
Example # In the &quot;updateRecord&quot; step, nested within a &quot;tryCatch&quot; step, it&rsquo;s not possible to access the output of &quot;findData&quot; because it is not within the execution flow of &quot;findData.&quot; However, it can access the output of the parent step: &quot;tryCatchError.&quot;
`}),e.add({id:141,href:"/dev-reference/flows/examples/",title:"Examples",description:"",content:""}),e.add({id:142,href:"/dev-reference/flows/examples/start-task/",title:"Start task",description:`Summary # This example is an action that changes the status of a task in progress.
Step: start # Inputs # No configuration required.
Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: update record # Inputs # Label Value Description record Status Set IN PROGRESS Updates the state of the task record and store the changes. Outputs # Name Type Description updatedTask record The updated task is put in the context.`,content:`Summary # This example is an action that changes the status of a task in progress.
Step: start # Inputs # No configuration required.
Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: update record # Inputs # Label Value Description record Status Set IN PROGRESS Updates the state of the task record and store the changes. Outputs # Name Type Description updatedTask record The updated task is put in the context. Context # - record: Record - oldRecord: Record - action: Action - updatedTask: Record Step: end # Inputs # Label Type Description Return result boolean If true it will return the final result of the flow. Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action - updatedTask: Record `}),e.add({id:143,href:"/getting-started/getting/first-steps/task-mananger/workflowview/",title:"The workflow view",description:`Hi! In this section, we will take a look at the new Workflow View.
See the view # Make sure you are on the runtime of your app; if not, you can access it through the developer portal. Let&rsquo;s see what we have accomplished. This is how the new Workflow View should look like after a few configurations.
We have built an awesome app. Let&rsquo;s try it out and verify that the actions and transitions are working as expected.`,content:`Hi! In this section, we will take a look at the new Workflow View.
See the view # Make sure you are on the runtime of your app; if not, you can access it through the developer portal. Let&rsquo;s see what we have accomplished. This is how the new Workflow View should look like after a few configurations.
We have built an awesome app. Let&rsquo;s try it out and verify that the actions and transitions are working as expected.
Review the actions # To execute actions, click the button located at the top-right corner of the card. In this case, only the &quot;Archive&quot; action is available as per our configuration. You should also be able to perform other actions by moving the card through different columns.
Create tasks through modal view # To create new tasks, click on the &quot;Create&quot; button, and a pop-up will appear.
Verify transitions # You can move the cards between different columns. Keep in mind that only the movements we have configured will be allowed. For example, in our app, moving a card from the &quot;To do&quot; column to the &quot;Done&quot; column should not be possible.
Verify ranking feature # Lastly, you can rank tasks by moving them up and down.
😊
Pretty awesome, right? Our app is starting to look amazing! In the next section, we will create different roles for app users and assign them specific permissions. See you in the next section: &ldquo;Groups and Permissions.&rdquo;
`}),e.add({id:144,href:"/dev-reference/flows/examples/update-tax-rates/",title:"Update tax rates",description:`Summary # In this example, we demonstrate an action that dynamically updates the tax rate percentage based on the customer&rsquo;s location. When the customer&rsquo;s location is Colorado, the tax rate is set to 5%, while for customers in Arizona, the tax rate is adjusted to 6.5%. This showcases how you can use contextual information to make real-time adjustments and tailor processes to specific conditions.
Step: start # Inputs # No configuration required.`,content:`Summary # In this example, we demonstrate an action that dynamically updates the tax rate percentage based on the customer&rsquo;s location. When the customer&rsquo;s location is Colorado, the tax rate is set to 5%, while for customers in Arizona, the tax rate is adjusted to 6.5%. This showcases how you can use contextual information to make real-time adjustments and tailor processes to specific conditions.
Step: start # Inputs # No configuration required.
Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: If CO # Inputs # Label Type Value Condition Condition record.field(&lsquo;customer.address.state&rsquo;).val() === &lsquo;CO&rsquo; Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: If AZ # Inputs # Label Type Value Condition Condition record.field(&lsquo;customer.address.state&rsquo;).val() === &lsquo;AZ&rsquo; Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: Update tax rate Colorado # Inputs # Label Type Value Record record context.record Tax Rates percentage 0.05 Outputs # Label Type Description updatedRecord record put in context == false Context # - record: Record - oldRecord: Record - action: Action Step: Update tax rate Arizona # Inputs # Label Type Value Record record context.record Tax Rates percentage 0.05 Outputs # Label Type Description updatedRecord record put in context == false Context # - record: Record - oldRecord: Record - action: Action Step: end # Inputs # Label Type Description Return result boolean If true it will return the final result of the flow. Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action `}),e.add({id:145,href:"/dev-reference/flows/examples/update-several-records/",title:"Update several records",description:"Summary # In this example, we present an action that performs a comprehensive search for all companies located in Arizona. For each company found, it updates the rating value to 5, logs the updated company details, and saves the changes to the database. In the event of an error occurring during the company update process, the error is also diligently logged for future reference. This example illustrates how to efficiently manage and update multiple records within a specific context while handling potential errors gracefully.",content:`Summary # In this example, we present an action that performs a comprehensive search for all companies located in Arizona. For each company found, it updates the rating value to 5, logs the updated company details, and saves the changes to the database. In the event of an error occurring during the company update process, the error is also diligently logged for future reference. This example illustrates how to efficiently manage and update multiple records within a specific context while handling potential errors gracefully.
Step: start # Inputs # No configuration required.
Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: Find companies of Arizona # Inputs # Label Value Description Companies State equals Arizona Find companies of Arizona Outputs # Name Type Description arizonaCompanies resultSet The founded companies are put in the context. Context # - record: Record - oldRecord: Record - action: Action - arizonaCompanies: ResultSet Step: For Each # Inputs # Label Description arizonaCompanies Iterates the companies. Outputs # Name Type Description arizonaCompany record Puts the iterated company in the context. Context # - record: Record - oldRecord: Record - action: Action - arizonaCompanies: ResultSet - arizonaCompany: Record Step: Update Rating # Inputs # Label Value Description arizonaCompany Rating Set 5 The rating of the company is set to 5. Outputs # Name Type Description updatedCompany record The edited company is put in the context. Context # - record: Record - oldRecord: Record - action: Action - arizonaCompanies: ResultSet - arizonaCompany: Record - updatedCompany: Record Step: Log success message # Inputs # Label Value Description message Successfully updated company Logs a message too inform that the company was updated successfully. Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action - arizonaCompanies: ResultSet - arizonaCompany: Record - updatedCompany: Record Step: Log error message # Inputs # Label Value Description message Error while updating company Logs a message too inform that the update of the company failed. Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action - arizonaCompanies: ResultSet - arizonaCompany: Record - updatedCompany: Record Step: Save company # Inputs # Label Description updatedCompany The record instance to be saved into the database after applying changes. Outputs # Name Type Description savedCompany record The saved company is put in the context. Context # - record: Record - oldRecord: Record - action: Action - arizonaCompanies: ResultSet - arizonaCompany: Record - updatedCompany: Record - savedCompany: Record Step: end # Inputs # Label Type Description Return result boolean If true it will return the final result of the flow. Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action - arizonaCompanies: ResultSet - arizonaCompany: Record - updatedCompany: Record - savedCompany: Record `}),e.add({id:146,href:"/dev-reference/flows/examples/delete-company/",title:"Delete company",description:`Summary # In this example, we showcase an action designed to delete a company. If the deletion process encounters an error, the action is configured to display an appropriate error message. This example highlights a straightforward but essential feature in managing and handling potential errors during company deletion operations.
Step: start # Inputs # No configuration required.
Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: Delete company # Inputs # Label Type Value Record record context.`,content:`Summary # In this example, we showcase an action designed to delete a company. If the deletion process encounters an error, the action is configured to display an appropriate error message. This example highlights a straightforward but essential feature in managing and handling potential errors during company deletion operations.
Step: start # Inputs # No configuration required.
Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: Delete company # Inputs # Label Type Value Record record context.record Outputs # Name Type Description deleteRecord record put in context == false Context # - record: Record - oldRecord: Record - action: Action Step: Show error message # Inputs # Label Type Value Target choice Caller Title text Error deleting the company Message text An error occurred while deleting the company, please try again. Type choice Error Keep visible boolean false Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: end # Label Type Description Return result boolean If true it will return the final result of the flow. Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action `}),e.add({id:147,href:"/dev-reference/flows/examples/delete-several-records/",title:"Delete several records",description:`Summary # In this example, we illustrate an action that attempts to delete all companies located in Colorado. In the event that an error is encountered during the deletion of any company, the action diligently logs the error for further analysis. This example showcases a robust workflow for systematically managing the deletion of companies, with error handling to ensure smooth operation.
Step: start # Inputs # No configuration required.
Outputs # No configuration required.`,content:`Summary # In this example, we illustrate an action that attempts to delete all companies located in Colorado. In the event that an error is encountered during the deletion of any company, the action diligently logs the error for further analysis. This example showcases a robust workflow for systematically managing the deletion of companies, with error handling to ensure smooth operation.
Step: start # Inputs # No configuration required.
Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: Find companies # Inputs # Label Value Description Companies All Finds all the companies Outputs # Name Type Description companies resultSet Puts the company in the context. Context # - record: Record - oldRecord: Record - action: Action - companies: ResultSet Step: Delete all Colorado companies # Inputs # No configuration required.
Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action - companies: ResultSet Step: For each # Inputs # Label Type Description Companies resultSet Iterates the companies. Outputs # Name Type Description company record Puts the iterated company in the context. Context # - record: Record - oldRecord: Record - action: Action - companies: ResultSet - company: record Step: If CO # Inputs # Label Type Value Description Condition condition context.company.field(&lsquo;address.state&rsquo;).val() === &lsquo;CO&rsquo;; Filter companies from Colorado. Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action - companies: ResultSet - company: record Step: Delete company # Inputs # Label Type Value Record record company Outputs # Name Type Description deletedRecord record Deletes the company and does not put it in the context. Context # - record: Record - oldRecord: Record - action: Action - companies: ResultSet - company: record Step: Log error # Inputs # Label Value Description Message Error while deleting company Logs a message too inform that the delete of the company faild. Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action - companies: ResultSet - company: record Step: end # Label Type Description Return result boolean If true it will return the final result of the flow. Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action - companies: ResultSet - company: record `}),e.add({id:148,href:"/dev-reference/flows/examples/download-file/",title:"Download file",description:`Summary # In this example, we showcase an action designed to delete a company.
Step: start # Inputs # No configuration required.
Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: Execute verify user action # Inputs # Label Type Value Action entityAction context.record Outputs # Name Type Description taskId text put in context == false Context # - record: Record - oldRecord: Record - action: Action Step: Go to download view # Inputs # Label Type Parameters query Outputs # No configuration required.`,content:`Summary # In this example, we showcase an action designed to delete a company.
Step: start # Inputs # No configuration required.
Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: Execute verify user action # Inputs # Label Type Value Action entityAction context.record Outputs # Name Type Description taskId text put in context == false Context # - record: Record - oldRecord: Record - action: Action Step: Go to download view # Inputs # Label Type Parameters query Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: Download file # Inputs # Label Type Value File Id text myFileId Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: Show execute verify user action error message # Inputs # Label Type Value Target choice caller Title text Error executing verify user action Message text An error occurred while execute verify user action, please try again. Type choice Error Keep visible boolean false Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: Show download file error message # Inputs # Label Type Value Target choice caller Title text Error downloading file Message text An error occurred while execute verify user action, please try again. Type choice Error Keep visible boolean false Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action Step: end # Label Type Description Return result boolean If true it will return the final result of the flow. Outputs # No configuration required.
Context # - record: Record - oldRecord: Record - action: Action `}),e.add({id:149,href:"/dev-reference/queries/",title:"Queries",description:"",content:""}),e.add({id:150,href:"/dev-reference/queries/query-language/",title:"Query language",description:`Overview # The query language enables you to search for records within an entity using complex criteria. This language is used by both the REST API and the Javascript API. However, please note that the method of specifying queries differs between the two.
For example, a simple query to retrieve 10 active companies using the REST API looks like this:
GET https://app.{{ site.slingr_domain }}/prod/runtime/api/data/companies?state=active&amp;_size=10 In contrast, with the Javascript API, it would look something like this:`,content:`Overview # The query language enables you to search for records within an entity using complex criteria. This language is used by both the REST API and the Javascript API. However, please note that the method of specifying queries differs between the two.
For example, a simple query to retrieve 10 active companies using the REST API looks like this:
GET https://app.{{ site.slingr_domain }}/prod/runtime/api/data/companies?state=active&amp;_size=10 In contrast, with the Javascript API, it would look something like this:
var records = sys.data.find('companies', {state: 'active', _size: 10}); while (records.hasNext()) { // do something } In the Javascript API, you can also utilize the query builder), which provides helpful tools for constructing queries:
var query = sys.data.createQuery('companies') .field('state').equals('active') .size(10); var records = sys.data.find(query); while (records.hasNext()) { // do something } Generally, when dealing with more intricate query criteria, the query builder is easier to use than the simple map form because it offers conversion and parsing features. Additionally, there are queries that cannot be expressed using the query map version. For instance:
var query = sys.data.createQuery('companies').query(function(q) { return q.or( q.field('name').like('test'), q.field('name').equals('abc') ); }); The above query cannot be expressed using the query map version because you cannot use the same key in the map. It would look like this:
var query = { name: 'like(test)', name: 'like(abc)' }; In this case, the key name appears twice in the map and won&rsquo;t work as expected.
Another consideration is exception handling. When using the query builder, exceptions may be thrown during query construction. For example:
try { var query = sys.data.createQuery('companies') .field('doesNotExist').equals('test'); log('count: '+sys.data.count(query); } catch (e) { log('error: '+e.message()); } The script above will throw an exception when calling the field() method because the field doesNotExist is not a valid field in the companies entity. Similar exceptions will occur with other improper query configurations, so be aware that exceptions may arise during query construction.
On the other hand, when using the query map, exceptions won&rsquo;t occur during query construction but rather when executing the query:
try { var query = {doesNotExist: 'test'}; var count = sys.data.count('companies', query); log('count: '+count); } catch (e) { log('error: '+e.message()); } In this case, the exception will be thrown when calling the sys.data.count() method.
This documentation section provides samples in all three versions for comparison. If a feature only applies to specific versions, it will be explicitly indicated.
Simple queries # Simple queries allow you to filter records using the AND logical operator exclusively, although you can still specify multiple filters. Here are some simple query examples:
JS Query MapJS Query BuilderREST API // finds a company by exact name var records_00 = sys.data.find('companies', {name: &#39;Blogpad&#39;}); log('total: '+records_00.count()); while (records_00.hasNext()) { log(records_00.next().label()); } // finds a company by exact name var query_00 = sys.data.createQuery('companies') .field(&#39;name&#39;).equals(&#39;Blogpad&#39;) var records_00 = sys.data.find(query_00); log('total: '+records_00.count()); while (records_00.hasNext()) { log(records_00.next().label()); } // finds a company by exact name GET /data/contacts?name=Blogpad JS Query MapJS Query BuilderREST API // filters by companies with more than 200 employees; limits results to 10 and use offset of 20 var records_01 = sys.data.find('companies', {numberOfEmployees: &#39;greater(200)&#39;, _size: 10, _offset: 20}); log('total: '+records_01.count()); while (records_01.hasNext()) { log(records_01.next().label()); } // filters by companies with more than 200 employees; limits results to 10 and use offset of 20 var query_01 = sys.data.createQuery('companies') .field(&#39;numberOfEmployees&#39;).greater(200).size(10).offset(20) var records_01 = sys.data.find(query_01); log('total: '+records_01.count()); while (records_01.hasNext()) { log(records_01.next().label()); } // filters by companies with more than 200 employees; limits results to 10 and use offset of 20 GET /data/contacts?numberOfEmployees=greater(200)&amp;_size=10&amp;_offset=20 JS Query MapJS Query BuilderREST API // filters by two fields var records_02 = sys.data.find('companies', {type: &#39;a&#39;, isCustomer: false}); log('total: '+records_02.count()); while (records_02.hasNext()) { log(records_02.next().label()); } // filters by two fields var query_02 = sys.data.createQuery('companies') .field(&#39;type&#39;).equals(&#39;a&#39;).field(&#39;isCustomer&#39;).equals(false) var records_02 = sys.data.find(query_02); log('total: '+records_02.count()); while (records_02.hasNext()) { log(records_02.next().label()); } // filters by two fields GET /data/contacts?type=a&amp;isCustomer=false JS Query MapJS Query BuilderREST API // filters by a nested field var records_03 = sys.data.find('companies', {&#39;addresses.state&#39;: &#39;CA&#39;}); log('total: '+records_03.count()); while (records_03.hasNext()) { log(records_03.next().label()); } // filters by a nested field var query_03 = sys.data.createQuery('companies') .field(&#39;addresses.state&#39;).equals(&#39;CA&#39;) var records_03 = sys.data.find(query_03); log('total: '+records_03.count()); while (records_03.hasNext()) { log(records_03.next().label()); } // filters by a nested field GET /data/contacts?addresses.state=CA JS Query MapJS Query BuilderREST API // retrieves only name and type of customers var records_04 = sys.data.find('companies', {isCustomer: true, _fields: &#39;name,type&#39;}); log('total: '+records_04.count()); while (records_04.hasNext()) { log(records_04.next().label()); } // retrieves only name and type of customers var query_04 = sys.data.createQuery('companies') .field(&#39;isCustomer&#39;).equals(true).includeFields(&#39;name&#39;, &#39;type&#39;) var records_04 = sys.data.find(query_04); log('total: '+records_04.count()); while (records_04.hasNext()) { log(records_04.next().label()); } // retrieves only name and type of customers GET /data/contacts?isCustomer=true&amp;_fields=name,type In the query map and REST API, parameters starting with _ are system parameters, while others are fields. The next section explains all the options for filtering by fields.
Filters by field # You can filter results by field value. For instance, if your entity has a field called name, you can make the following query:
JS Query MapJS Query BuilderREST API // var records_05 = sys.data.find('companies', {name: &#39;Blogpad&#39;}); log('total: '+records_05.count()); while (records_05.hasNext()) { log(records_05.next().label()); } // var query_05 = sys.data.createQuery('companies') .field(&#39;name&#39;).equals(&#39;Blogpad&#39;) var records_05 = sys.data.find(query_05); log('total: '+records_05.count()); while (records_05.hasNext()) { log(records_05.next().label()); } // GET /data/contacts?name=Blogpad You can also provide several values (comma-separated), and it will act like an OR:
JS Query MapJS Query BuilderREST API // var records_06 = sys.data.find('companies', {name: &#39;Blogpad,Jazzy&#39;}); log('total: '+records_06.count()); while (records_06.hasNext()) { log(records_06.next().label()); } // var query_06 = sys.data.createQuery('companies') .field(&#39;name&#39;).equals(&#39;Blogpad,Jazzy&#39;) var records_06 = sys.data.find(query_06); log('total: '+records_06.count()); while (records_06.hasNext()) { log(records_06.next().label()); } // GET /data/contacts?name=Blogpad,Jazzy If the value you are matching already contains a comma, you should wrap it in double quotes:
JS Query MapJS Query BuilderREST API // var records_07 = sys.data.find('companies', {name: &#39;&#34;ACME, Inc&#34;&#39;}); log('total: '+records_07.count()); while (records_07.hasNext()) { log(records_07.next().label()); } // var query_07 = sys.data.createQuery('companies') .field(&#39;name&#39;).equals(&#39;&#34;ACME, Inc&#34;&#39;) var records_07 = sys.data.find(query_07); log('total: '+records_07.count()); while (records_07.hasNext()) { log(records_07.next().label()); } // GET /data/contacts?name=&#34;ACME, Inc&#34; You can filter by nested fields as well:
JS Query MapJS Query BuilderREST API // var records_08 = sys.data.find('companies', {&#39;contactInformation.email&#39;: &#39;dwelchdp@apple.com&#39;}); log('total: '+records_08.count()); while (records_08.hasNext()) { log(records_08.next().label()); } // var query_08 = sys.data.createQuery('companies') .field(&#39;contactInformation.email&#39;).equals(&#39;dwelchdp@apple.com&#39;) var records_08 = sys.data.find(query_08); log('total: '+records_08.count()); while (records_08.hasNext()) { log(records_08.next().label()); } // GET /data/contacts?contactInformation.email=dwelchdp@apple.com If the nested group field is multi-valued, you can still perform a query like this:
JS Query MapJS Query BuilderREST API // var records_09 = sys.data.find('companies', &#39;{&#39;_or&#39;: {&#39;type&#39;: &#39;a&#39;, &#39;_and&#39;: {&#39;type&#39;: &#39;b&#39;, &#39;isCustomer&#39;: true}}}&#39;); log('total: '+records_09.count()); while (records_09.hasNext()) { log(records_09.next().label()); } // var query_09 = sys.data.createQuery('companies') &#39;.query(function(q) { return q.or(q.field(&#39;type&#39;).equals(&#39;a&#39;), q.and(q.field(&#39;type&#39;).equals(&#39;b&#39;), q.field(&#39;isCustomer&#39;).equals(true))); })&#39; var records_09 = sys.data.find(query_09); log('total: '+records_09.count()); while (records_09.hasNext()) { log(records_09.next().label()); } // GET /data/contacts?_query=or(filter(&#39;type&#39;,&#39;a&#39;),and(filter(&#39;type&#39;,&#39;b&#39;),filter(&#39;isCustomer&#39;,&#39;true&#39;))) Available operators for filtering:
equals(value) notEquals(value) like(value) // options: /value, value/ or /regexp/ between(from,to) greater(value) greaterOrEquals(value) less(value) lessOrEquals(value) empty() notEmpty() Each field type supports different operators. Refer to the documentation for each type to see which operators are supported.
The following operators are available for all types:
equals(value) notEquals(value) empty() notEmpty() If you don't specify any operator, the default one is equals(). It's a good practice to consult the documentation for each type when filtering by field values, as each type may support different querying methods and alternative formats for simplifying usage. Complex queries # Complex queries are similar to regular queries, but they allow you to mix and nest OR and AND expressions. They are separated because they require a different syntax, especially in the REST API and query builder.
Here&rsquo;s a sample complex query, highlighting the differences between the three versions:
JS Query MapJS Query BuilderREST API // Query on companies var records_10 = sys.data.find('companies', { _or: { type: &#39;a&#39;, _and: { type: &#39;b&#39;, isCustomer: true }}}); log('total: '+records_10.count()); while (records_10.hasNext()) { log(records_10.next().label()); } // Query on companies var query_10 = sys.data.createQuery('companies') .field(&#39;type&#39;).equals(&#39;a&#39;).or().field(&#39;type&#39;).equals(&#39;b&#39;).field(&#39;isCustomer&#39;).equals(true) var records_10 = sys.data.find(query_10); log('total: '+records_10.count()); while (records_10.hasNext()) { log(records_10.next().label()); } // Query on companies GET /data/contacts?_query=or(filter(&#39;type&#39;,&#39;a&#39;),and(filter(&#39;type&#39;,&#39;b&#39;),filter(&#39;isCustomer&#39;,&#39;true&#39;))) The query map version is almost the same as simple queries; it uses the _or and _and operators. However, in the REST API and query builder, due to interface limitations, complex queries must be written differently.
For the REST API, you must pass a _query parameter, where you can use these operators:
or(...): evaluates to true if any of the criteria passed as arguments is true. It accepts a list of filter criteria that can be and(), filter(), or another or(). and(...): similar to or(), but it evaluates to true if all the criteria passed as arguments are true. filter(field,value): a simple field filter, like those in simple queries. Always enclose the name and value with single quotes. When using the query builder, you should use the query() method, which accepts a function as a parameter. This function receives a helper object and should return a query criteria. Here are some examples of complex queries in the REST API and query builder:
JS Query BuilderREST API // Query on companies var query_11 = sys.data.createQuery('companies') .and(q.field(&#39;isCustomer&#39;).equals(true), q.or(q.field(&#39;addresses.state&#39;).equals(&#39;CA&#39;), q.field(&#39;numberOfEmployees&#39;).greater(100))) var records_11 = sys.data.find(query_11); log('total: '+records_11.count()); while (records_11.hasNext()) { log(records_11.next().label()); } // Query on companies GET /data/contacts?_query=and(filter(&#39;isCustomer&#39;,&#39;true&#39;),or(filter(&#39;addresses.state&#39;,&#39;CA&#39;),filter(&#39;numberOfEmployees&#39;,&#39;greater(100)&#39;))) JS Query BuilderREST API // Query on companies var query_12 = sys.data.createQuery('companies') .or(q.field(&#39;isCustomer&#39;).equals(true), q.field(&#39;numberOfEmployees&#39;).greater(900), q.field(&#39;addresses.state&#39;).equals(&#39;CA,CO,NJ&#39;)) var records_12 = sys.data.find(query_12); log('total: '+records_12.count()); while (records_12.hasNext()) { log(records_12.next().label()); } // Query on companies GET /data/contacts?_query=or(filter(&#39;isCustomer&#39;,&#39;true&#39;),filter(&#39;numberOfEmployees&#39;,&#39;greater(900)&#39;),filter(&#39;addresses.state&#39;,&#39;CA,CO,NJ&#39;)) Query parameters # In addition to field filtering, you can specify query parameters to control how the query is executed.
Limit size # You can set a maximum number of records to fetch using the _size parameter or the size() method:
JS Query MapJS Query BuilderREST API // fetches 10 records at most var records_13 = sys.data.find('companies', {_size: 10}); log('total: '+records_13.count()); while (records_13.hasNext()) { log(records_13.next().label()); } // fetches 10 records at most var query_13 = sys.data.createQuery('companies') .size(10) var records_13 = sys.data.find(query_13); log('total: '+records_13.count()); while (records_13.hasNext()) { log(records_13.next().label()); } // fetches 10 records at most GET /data/contacts?_size=10 It&rsquo;s possible that the query returns fewer records than the specified number.
The REST and Javascript APIs will return the total number of records matched by the query. Please refer to the documentation for each API for more information.
For the REST API, the maximum value you can specify is 1,000, with a default value of 20 if not specified. These limits and defaults do not apply to the Javascript API, as it uses a cursor to iterate over the results. Skip records # You can provide an offset to skip some records in your query. You can use a number to indicate how many records to skip, or you can use an ID.
If you use a number, that number will indicate how many records to skip. Use the _offset parameter or the offset() method:
JS Query MapJS Query BuilderREST API // skips the first 5 records and the first record retrieved will be the 6th one var records_14 = sys.data.find('companies', {_offset: 5}); log('total: '+records_14.count()); while (records_14.hasNext()) { log(records_14.next().label()); } // skips the first 5 records and the first record retrieved will be the 6th one var query_14 = sys.data.createQuery('companies') .offset(5) var records_14 = sys.data.find(query_14); log('total: '+records_14.count()); while (records_14.hasNext()) { log(records_14.next().label()); } // skips the first 5 records and the first record retrieved will be the 6th one GET /data/contacts?_offset=5 If there are fewer records than the specified offset, the query will return no results.
The other option for specifying an offset is an ID. This form can only be used if you are either explicitly sorting by the id field or if you have omitted sorting options in your query (the default is id).
For instance, if you query 5 records and receive the following record IDs:
[ '57fd2d65e4b0ce322b0c8665', '57fd2d65e4b0ce322b0c8565', '57fd2d65e4b0ce322b0c8547', '57fd2d65e4b0ce322b0c84b1', '57fd2d64e4b0ce322b0c8349' ] To fetch the next 5 records, you should make the following query, using the last record&rsquo;s ID as the offset:
JS Query MapJS Query BuilderREST API // starts after record with ID 57fd2d64e4b0ce322b0c8349 var records_15 = sys.data.find('companies', {_offset: &#39;57fd2d64e4b0ce322b0c8349&#39;}); log('total: '+records_15.count()); while (records_15.hasNext()) { log(records_15.next().label()); } // starts after record with ID 57fd2d64e4b0ce322b0c8349 var query_15 = sys.data.createQuery('companies') .offset(&#39;57fd2d64e4b0ce322b0c8349&#39;) var records_15 = sys.data.find(query_15); log('total: '+records_15.count()); while (records_15.hasNext()) { log(records_15.next().label()); } // starts after record with ID 57fd2d64e4b0ce322b0c8349 GET /data/contacts?_offset=57fd2d64e4b0ce322b0c8349 This query will not return the record with ID 57fd2d64e4b0ce322b0c8349 but rather the next 5 records after it.
If you need to iterate over all records using the REST API and want to avoid fetching the same record twice, it's advisable to use IDs as offsets. Using numbers might result in duplicated or missed records due to modifications of records affecting your query. Sorting # You can sort results based on a field. By default, the id field and desc direction are used if no sorting options are specified. However, you can change this behavior using the _sortField and _sortType parameters or the sortBy() method:
JS Query MapJS Query BuilderREST API // var records_16 = sys.data.find('companies', { state: &#39;active&#39;, _sortField: &#39;name&#39;, _sortType: &#39;asc&#39; }); log('total: '+records_16.count()); while (records_16.hasNext()) { log(records_16.next().label()); } // var query_16 = sys.data.createQuery('companies') .field(&#39;state&#39;).equals(&#39;active&#39;).sortBy(&#39;name&#39;, &#39;asc&#39;) var records_16 = sys.data.find(query_16); log('total: '+records_16.count()); while (records_16.hasNext()) { log(records_16.next().label()); } // GET /data/contacts?state=active&amp;_sortField=name&amp;_sortType=asc You can even use a nested field for sorting:
JS Query MapJS Query BuilderREST API // var records_17 = sys.data.find('companies', { _sortField: &#39;contactInformation.email&#39;, _sortType: &#39;asc&#39; }); log('total: '+records_17.count()); while (records_17.hasNext()) { log(records_17.next().label()); } // var query_17 = sys.data.createQuery('companies') .sortBy(&#39;contactInformation.email&#39;, &#39;asc&#39;) var records_17 = sys.data.find(query_17); log('total: '+records_17.count()); while (records_17.hasNext()) { log(records_17.next().label()); } // GET /data/contacts?_sortField=contactInformation.email&amp;_sortType=asc The _sortField parameter specifies the field to sort by, and _sortType specifies the sorting order, which can be one of the following:
asc (ascending) desc (descending) Keep in mind that you cannot use multi-valued or nested fields as the sorting field.
So far you cannot specify many fields for sorting. In some cases you can achieve the same result by adding a calculated field that concatenates the fields you want to use for sorting.
Include fields # By default, all fields are returned in the results. If you only want to retrieve specific fields, you can use the _fields parameter or the includeFields() method:
JS Query MapJS Query BuilderREST API // only name and email fields will be fetched var records_18 = sys.data.find('companies', { _fields: &#39;name,email&#39; }); log('total: '+records_18.count()); while (records_18.hasNext()) { log(records_18.next().label()); } // only name and email fields will be fetched var query_18 = sys.data.createQuery('companies') .includeFields(&#39;name&#39;, &#39;email&#39;) var records_18 = sys.data.find(query_18); log('total: '+records_18.count()); while (records_18.hasNext()) { log(records_18.next().label()); } // only name and email fields will be fetched GET /data/contacts?_fields=name,email You can select nested fields like addresses.state. If you put the parent field, like addresses, all inner fields will be included.
JS Query MapJS Query BuilderREST API // you can also indicate nested fields var records_19 = sys.data.find('companies', { _fields: &#39;name,addresses.state&#39; }); log('total: '+records_19.count()); while (records_19.hasNext()) { log(records_19.next().label()); } // you can also indicate nested fields var query_19 = sys.data.createQuery('companies') .includeFields(&#39;name&#39;, &#39;addresses.state&#39;) var records_19 = sys.data.find(query_19); log('total: '+records_19.count()); while (records_19.hasNext()) { log(records_19.next().label()); } // you can also indicate nested fields GET /data/contacts?_fields=name,addresses.state System field will always be returned (id, version, label).
Fetch related records # This parameter only functions with the REST API; it will not have any effect when used with the Javascript API. If you wish to reduce the number of requests to the server, you can retrieve a record and its related records by using the _relationshipsToFetch parameter. This parameter accepts a comma-separated list of relationship fields.
REST API // Fetches the primary records along with company information GET /data/contacts?_relationshipsToFetch=company&amp;_size=10 REST API // You can specify multiple relationship fields separated by commas, even if the relationship field is multi-valued GET /data/contacts?_relationshipsToFetch=company,skills&amp;_size=10 Global search # This is only allowed for entities with global search enabled. When querying using the global search feature, it will attempt to match the provided string in any field within the entity, rather than targeting a specific field. For example:
JS Query MapJS Query BuilderREST API // Finds records where any field contains &#39;lacinia&#39; or &#39;erat&#39; var records_22 = sys.data.find('companies', { _globalSearch: &#39;lacinia erat&#39; }); log('total: '+records_22.count()); while (records_22.hasNext()) { log(records_22.next().label()); } // Finds records where any field contains &#39;lacinia&#39; or &#39;erat&#39; var query_22 = sys.data.createQuery('companies') .globalSearch(&#39;lacinia erat&#39;) var records_22 = sys.data.find(query_22); log('total: '+records_22.count()); while (records_22.hasNext()) { log(records_22.next().label()); } // Finds records where any field contains &#39;lacinia&#39; or &#39;erat&#39; GET /data/contacts?_globalSearch=lacinia erat Note that to match the entire phrase, you should enclose it with double quotes:
JS Query MapJS Query BuilderREST API // finds record where any field has the tense &#39;lacinia erat&#39; var records_23 = sys.data.find('companies', { _globalSearch: &#39;&#34;lacinia erat&#34;&#39; }); log('total: '+records_23.count()); while (records_23.hasNext()) { log(records_23.next().label()); } // finds record where any field has the tense &#39;lacinia erat&#39; var query_23 = sys.data.createQuery('companies') .globalSearch(&#39;&#34;lacinia erat&#34;&#39;) var records_23 = sys.data.find(query_23); log('total: '+records_23.count()); while (records_23.hasNext()) { log(records_23.next().label()); } // finds record where any field has the tense &#39;lacinia erat&#39; GET /data/contacts?_globalSearch=&#34;lacinia erat&#34; Please be aware that all searches are case-insensitive.
Format # This parameter only works with the REST API; it will not have any effect when used with the Javascript API. In the REST API, you can utilize the _format parameter to specify the format of the returned records. There are two options:
native: Returns the &ldquo;raw&rdquo; values for each field. For example, a date-time field will be returned as milliseconds. This is the default format. plainText: Returns field values converted to strings using the display options of each field. For example, a date-time field will be returned as a string based on the field&rsquo;s display options. The plainText format is useful when you need to display information to users in an external application outside of the Slingr runtime, and you do not want to handle formatting.
REST API // Companies query sample GET /data/contacts?_format=plainText&amp;_size=10 Format using one specific user&rsquo;s settings # This can be achieved using the _formatForUser parameter and is only meaningful when using the plainText option in _format.
You should provide either the user&rsquo;s ID or email that will be used to format the record. For instance, if the user has configured a different time zone, date-time fields will use that setting to format dates. This is useful when you need to send emails to individuals residing in different time zones.
REST API // Companies query sample GET /data/contacts?_format=plainText&amp;_formatForUser=test1.docs@slingr.io&amp;_size=10 `}),e.add({id:151,href:"/dev-reference/queries/aggregate-queries/",title:"Aggregated queries",description:`Overview # Aggregated queries enable you to perform aggregation operations on records in entities, such as counting, summing, or averaging.
This feature is implemented using the MongoDB&rsquo;s aggregation framework, so you&rsquo;ll notice many similarities. This guide provides all the information you need to write aggregate queries, and you shouldn&rsquo;t need to refer to MongoDB&rsquo;s documentation.
In essence, there is a pipeline where the input consists of records in the entity, and you apply various operations to filter, sort, and aggregate the data.`,content:`Overview # Aggregated queries enable you to perform aggregation operations on records in entities, such as counting, summing, or averaging.
This feature is implemented using the MongoDB&rsquo;s aggregation framework, so you&rsquo;ll notice many similarities. This guide provides all the information you need to write aggregate queries, and you shouldn&rsquo;t need to refer to MongoDB&rsquo;s documentation.
In essence, there is a pipeline where the input consists of records in the entity, and you apply various operations to filter, sort, and aggregate the data. Here&rsquo;s an example of an aggregate query in JavaScript:
var resultSet = sys.data.aggregate('contacts', [ {match: {'company.isCustomer': true}}, {group: {by: 'company', totalSkills: 'sum(numberOfSkills)'}} ]); while (resultSet.hasNext()) { var result = resultSet.next(); // the format of the result is a simple object you can stringify log(JSON.stringify(result)); } In this pipeline, we have two steps:
Select only records associated with a customer. Group by company and sum the field numberOfSkills, storing it in the field totalSkills. The input of one step is the result of the previous one, which is why it&rsquo;s called a pipeline. The result set for the above example will contain records with the following structure:
{ &quot;company&quot;: { &quot;id&quot;: &quot;57fd2d61e4b0ce322b0c530d&quot;, &quot;label&quot;: &quot;Flashset&quot; }, &quot;totalSkills&quot;: 12 } As you can see, you get a simple JavaScript object (it follows the JSON representation you can see in the REST API object) instead of something like a record object. This is because the structure changes based on the operations in your pipeline, and the result is no longer a record from an entity. You should check each type&rsquo;s documentation to verify the format used in the JSON representation.
Aggregated queries, like other queries, can be expressed using a query map, a query builder, and the REST API. Below, you&rsquo;ll find samples for all versions.
Operations # Count # The Count operation allows you to count elements and store the result in a field. This field cannot contain special characters; only numbers and letters are allowed, and it will be the only field in the result.
Here are some samples of how you can use it:
JS Query MapJS Query BuilderREST API // Counts companies from New York var records_01 = sys.data.find('companies', {match: {&#39;address.state&#39;: &#39;NY&#39;}, count: &#39;counter_field&#39;}); log('total: '+records_01.count()); while (records_01.hasNext()) { log(records_01.next().label()); } // Counts companies from New York var query_01 = sys.data.createQuery('companies') query.match().field(&#39;address.state&#39;).equals(&#39;NY&#39;); query.count().counterName(&#39;counter_field&#39;); var records_01 = sys.data.find(query_01); log('total: '+records_01.count()); while (records_01.hasNext()) { log(records_01.next().label()); } // Counts companies from New York GET /data/contacts?{&#34;match&#34;: {&#34;address.state&#34;: &#34;NY&#34;}, &#34;count&#34;: &#34;counter_field&#34;} When you run the above query, you will get output similar to this:
{&quot;counter_field&quot;:2} Skip # The Skip operation allows you to skip a specified number of elements. This operator is configured with a positive integer, which determines how many results to omit from the beginning.
Here are some samples of how you can use it:
JS Query MapJS Query BuilderREST API // Retrieves contacts while skipping the first 3 results var records_02 = sys.data.find('contacts', {skip: 3}); log('total: '+records_02.count()); while (records_02.hasNext()) { log(records_02.next().label()); } // Retrieves contacts while skipping the first 3 results var query_02 = sys.data.createQuery('contacts') query.skip().step(3); var records_02 = sys.data.find(query_02); log('total: '+records_02.count()); while (records_02.hasNext()) { log(records_02.next().label()); } // Retrieves contacts while skipping the first 3 results GET /data/contacts?{&#34;skip&#34;: 3} Limit # The Limit operation allows you to limit the number of elements in your aggregation results. This operator is configured with a positive integer and retrieves the specified number of results.
Here are some samples of how you can use it:
JS Query MapJS Query BuilderREST API // retrieves first 5 contacts var records_03 = sys.data.find('contacts', {limit: 5}); log('total: '+records_03.count()); while (records_03.hasNext()) { log(records_03.next().label()); } // retrieves first 5 contacts var query_03 = sys.data.createQuery('contacts') query.limit().step(5); var records_03 = sys.data.find(query_03); log('total: '+records_03.count()); while (records_03.hasNext()) { log(records_03.next().label()); } // retrieves first 5 contacts GET /data/contacts?{&#34;limit&#34;: 5} Unwind # The Unwind operation allows you to unwind multi-valued fields. This operator is configured with a field; if this field is an array, it will retrieve the same record with a single value for the selected field for each element in the array.
Here are some samples of how you can use it:
JS Query MapJS Query BuilderREST API // retrieves companies unwinding services var records_04 = sys.data.find('companies', {unwind: {fieldPath: &#39;services&#39;, includeEmpty: true}}); log('total: '+records_04.count()); while (records_04.hasNext()) { log(records_04.next().label()); } // retrieves companies unwinding services var query_04 = sys.data.createQuery('companies') query.unwind().path(&#39;services&#39;).includeEmpty(true); var records_04 = sys.data.find(query_04); log('total: '+records_04.count()); while (records_04.hasNext()) { log(records_04.next().label()); } // retrieves companies unwinding services GET /data/contacts?{&#34;unwind&#34;: {&#34;fieldPath&#34;: &#34;services&#34;, &#34;includeEmpty&#34;: true}} When you run the above query, you will get output similar to this:
{&quot;id&quot;:&quot;57fd2d64e4b0ce322b0c8349&quot;,&quot;name&quot;:&quot;Photolist&quot;,&quot;services&quot;:&quot;SERVICE_A&quot;} {&quot;id&quot;:&quot;57fd2d64e4b0ce322b0c8349&quot;,&quot;name&quot;:&quot;Photolist&quot;,&quot;services&quot;:&quot;SERVICE_C&quot;} {&quot;id&quot;:&quot;57fd2d62e4b0ce322b0c6268&quot;,&quot;name&quot;:&quot;DabZ&quot;,&quot;services&quot;:&quot;SERVICE_A&quot;} {&quot;id&quot;:&quot;57fd2d62e4b0ce322b0c6268&quot;,&quot;name&quot;:&quot;DabZ&quot;,&quot;services&quot;:&quot;SERVICE_B&quot;} {&quot;id&quot;:&quot;57fd2d62e4b0ce322b0c6268&quot;,&quot;name&quot;:&quot;DabZ&quot;,&quot;services&quot;:&quot;SERVICE_D&quot;} {&quot;id&quot;:&quot;57fd2d60e4b0ce322b0c50f0&quot;,&quot;name&quot;:&quot;Mydo&quot;,&quot;services&quot;:null} {&quot;id&quot;:&quot;57fd2d64e4b0ce322b0c7d12&quot;,&quot;name&quot;:&quot;Zazio&quot;,&quot;services&quot;:&quot;SERVICE_C&quot;} ... Lookup # The Lookup operation allows you to lookup elements from other entities in current records. This operator is equivalent to a SQL left-join using the name of a foreign entity, a foreign field in that entity, and a local field in the current entity (set in the query).
Here are some samples of how you can use it:
JS Query MapJS Query BuilderREST API // retrieves companies with related contacts var records_05 = sys.data.find('companies', {&#39;lookup&#39;: {&#39;localFieldPath&#39;: &#39;id&#39;, &#39;foreignFieldPath&#39;: &#39;company.id&#39;, &#39;foreignEntityName&#39;: &#39;contacts&#39;, &#39;as&#39;: &#39;relatedContacts&#39;}}); log('total: '+records_05.count()); while (records_05.hasNext()) { log(records_05.next().label()); } // retrieves companies with related contacts var query_05 = sys.data.createQuery('companies') query.lookup().localField(&#39;id&#39;).foreignField(&#39;company.id&#39;).foreignEntity(&#39;contacts&#39;).as(&#39;relatedContacts&#39;); var records_05 = sys.data.find(query_05); log('total: '+records_05.count()); while (records_05.hasNext()) { log(records_05.next().label()); } // retrieves companies with related contacts GET /data/contacts?{&#34;lookup&#34;: {&#34;localFieldPath&#34;: &#34;id&#34;, &#34;foreignFieldPath&#34;: &#34;company.id&#34;, &#34;foreignEntityName&#34;: &#34;contacts&#34;, &#34;as&#34;: &#34;relatedContacts&#34;}} When you run the above query, you will get output like this:
{&quot;id&quot;:&quot;57fd2d64e4b0ce322b0c8349&quot;, &quot;name&quot;:&quot;Photolist&quot;, &quot;relatedContacts&quot;:[ { &quot;id&quot;: &quot;5506fc44c2eee3b1a702694c&quot;, &quot;company&quot;: { &quot;id&quot;: &quot;5506fc43c2eee3b1a7026944&quot;, &quot;label&quot;: &quot;Photolist&quot; }, &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Doe&quot;, &quot;email&quot;: &quot;john.doe@abcinc.com&quot;, &quot;phoneNumbers&quot;: [ &quot;3039514211&quot;, &quot;3039514210&quot; ] }, { &quot;id&quot;: &quot;5506fc44c2eee3b1a702694d&quot;, &quot;company&quot;: { &quot;id&quot;: &quot;5506fc43c2eee3b1a7026944&quot;, &quot;label&quot;: &quot;Photolist&quot; }, &quot;firstName&quot;: &quot;Martin&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;email&quot;: &quot;martin.smith@abcinc.com&quot; }] } {&quot;id&quot;:&quot;57fd2d62e4b0ce322b0c6268&quot;,&quot;name&quot;:&quot;DabZ&quot;,&quot;relatedContacts&quot;:[ { &quot;id&quot;: &quot;5506fc44c2eee3b1a702694e&quot;, &quot;company&quot;: { &quot;id&quot;: &quot;5506fc43c2eee3b1a7026946&quot;, &quot;label&quot;: &quot;DabZ&quot; }, &quot;firstName&quot;: &quot;William&quot;, &quot;lastName&quot;: &quot;Brown&quot;, &quot;email&quot;: &quot;william.brown@acme.com&quot;, &quot;phoneNumbers&quot;: [ &quot;3039514211&quot;, &quot;3039514210&quot; ]}] } {&quot;id&quot;:&quot;57fd2d60e4b0ce322b0c50f0&quot;,&quot;name&quot;:&quot;Mydo&quot;,&quot;relatedContacts&quot;:[]} {&quot;id&quot;:&quot;57fd2d64e4b0ce322b0c7d12&quot;,&quot;name&quot;:&quot;Zazio&quot;,&quot;relatedContacts&quot;:[]} ... Match # The Match operation allows you to filter records in the pipeline. You need to use this operation to select the records you want to use for your aggregation.
This filter works the same way as the ones for regular queries, which means you can pass a query map or query builder (if you are using the JavaScript API). Keep in mind that only filters by fields are supported here while other parameters are ignored.
Here are some samples of matching operations:
JS Query MapJS Query BuilderREST API // Counts the number of skills for contacts of customers // see how the match operator filters contacts where company is a customer var records_06 = sys.data.find('contacts', {match: {&#39;company.isCustomer&#39;: true}}, {group: {totalNumberOfSkills: &#39;sum(numberOfSkills)&#39;}}); log('total: '+records_06.count()); while (records_06.hasNext()) { log(records_06.next().label()); } // Counts the number of skills for contacts of customers // see how the match operator filters contacts where company is a customer var query_06 = sys.data.createQuery('contacts') query.match().field(&#39;company.isCustomer&#39;).equals(true); query.group().accumulate(&#39;totalNumberOfSkills&#39;).sum(&#39;numberOfSkills&#39;); var records_06 = sys.data.find(query_06); log('total: '+records_06.count()); while (records_06.hasNext()) { log(records_06.next().label()); } // Counts the number of skills for contacts of customers // see how the match operator filters contacts where company is a customer GET /data/contacts?{&#34;match&#34;: {&#34;company.isCustomer&#34;: true}}, {&#34;group&#34;: {&#34;totalNumberOfSkills&#34;: &#34;sum(numberOfSkills)&#34;}} JS Query MapJS Query BuilderREST API // counts the number of skills for contacts // the match operator filters contacts by customers and state equals to New Jersey var records_07 = sys.data.find('contacts', {match: {&#39;company.isCustomer&#39;: true, &#39;address.state&#39;: &#39;NJ&#39;}}, {group: {totalNumberOfSkills: &#39;sum(numberOfSkills)&#39;}}); log('total: '+records_07.count()); while (records_07.hasNext()) { log(records_07.next().label()); } // counts the number of skills for contacts // the match operator filters contacts by customers and state equals to New Jersey var query_07 = sys.data.createQuery('contacts') query.match().field(&#39;company.isCustomer&#39;).equals(true).field(&#39;address.state&#39;).equals(&#39;NJ&#39;); query.group().accumulate(&#39;totalNumberOfSkills&#39;).sum(&#39;numberOfSkills&#39;); var records_07 = sys.data.find(query_07); log('total: '+records_07.count()); while (records_07.hasNext()) { log(records_07.next().label()); } // counts the number of skills for contacts // the match operator filters contacts by customers and state equals to New Jersey GET /data/contacts?{&#34;match&#34;: {&#34;company.isCustomer&#34;: true, &#34;address.state&#34;: &#34;NJ&#34;}}, {&#34;group&#34;: {&#34;totalNumberOfSkills&#34;: &#34;sum(numberOfSkills)&#34;}} Sort # Allows to change the sorting of records in your aggregation pipeline. This is useful for sorting the final result or to use together with accumulators like first() or last() in the group operator.
Here are some samples of how you can use it:
JS Query MapJS Query BuilderREST API // finds the contact with more skills per company var records_08 = sys.data.find('contacts', {sort: {&#39;numberOfSkills&#39;: &#39;desc&#39;}}, {group: {by: &#39;company&#39;, firstName: &#39;first(firstName)&#39;, lastName: &#39;first(lastName)&#39;, skills: &#39;first(numberOfSkills)&#39;}}); log('total: '+records_08.count()); while (records_08.hasNext()) { log(records_08.next().label()); } // finds the contact with more skills per company var query_08 = sys.data.createQuery('contacts') query.sort().by(&#39;numberOfSkills&#39;, &#39;desc&#39;); query.group().by(&#39;company&#39;).accumulate(&#39;firstName&#39;).first(&#39;firstName&#39;).accumulate(&#39;lastName&#39;).first(&#39;lastName&#39;).accumulate(&#39;skills&#39;).first(&#39;numberOfSkills&#39;); var records_08 = sys.data.find(query_08); log('total: '+records_08.count()); while (records_08.hasNext()) { log(records_08.next().label()); } // finds the contact with more skills per company GET /data/contacts?{&#34;sort&#34;: {&#34;numberOfSkills&#34;: &#34;desc&#34;}}, {&#34;group&#34;: {&#34;by&#34;: &#34;company&#34;, &#34;firstName&#34;: &#34;first(firstName)&#34;, &#34;lastName&#34;: &#34;first(lastName)&#34;, &#34;skills&#34;: &#34;first(numberOfSkills)&#34;}} JS Query MapJS Query BuilderREST API // finds the contact with more skills per company and sorts the result by skills and last name var records_09 = sys.data.find('contacts', {sort: {&#39;numberOfSkills&#39;: &#39;desc&#39;}}, {group: {by: &#39;company&#39;, firstName: &#39;first(firstName)&#39;, lastName: &#39;first(lastName)&#39;, skills: &#39;first(numberOfSkills)&#39;}}, {sort: {&#39;skills&#39;: &#39;desc&#39;, &#39;lastName&#39;: &#39;asc&#39;}}); log('total: '+records_09.count()); while (records_09.hasNext()) { log(records_09.next().label()); } // finds the contact with more skills per company and sorts the result by skills and last name var query_09 = sys.data.createQuery('contacts') query.sort().by(&#39;numberOfSkills&#39;, &#39;desc&#39;); query.group().by(&#39;company&#39;).accumulate(&#39;firstName&#39;).first(&#39;firstName&#39;).accumulate(&#39;lastName&#39;).first(&#39;lastName&#39;).accumulate(&#39;skills&#39;).first(&#39;numberOfSkills&#39;); query.sort().by(&#39;skills&#39;, &#39;desc&#39;).by(&#39;lastName&#39;, &#39;asc&#39;); var records_09 = sys.data.find(query_09); log('total: '+records_09.count()); while (records_09.hasNext()) { log(records_09.next().label()); } // finds the contact with more skills per company and sorts the result by skills and last name GET /data/contacts?{&#34;sort&#34;: {&#34;numberOfSkills&#34;: &#34;desc&#34;}}, {&#34;group&#34;: {&#34;by&#34;: &#34;company&#34;, &#34;firstName&#34;: &#34;first(firstName)&#34;, &#34;lastName&#34;: &#34;first(lastName)&#34;, &#34;skills&#34;: &#34;first(numberOfSkills)&#34;}}, {&#34;sort&#34;: {&#34;skills&#34;: &#34;desc&#34;, &#34;lastName&#34;: &#34;asc&#34;}} Project # The Project operation allows you to remove fields from records and reduce memory usage. This is important if you need to process many records but only need a few fields.
Here are some samples of how to use it:
JS Query MapJS Query BuilderREST API // leaves only number of employees and the sums up var records_10 = sys.data.find('companies', {project: &#39;name,numberOfEmployees&#39;}); log('total: '+records_10.count()); while (records_10.hasNext()) { log(records_10.next().label()); } // leaves only number of employees and the sums up var query_10 = sys.data.createQuery('companies') query.project().field(&#39;name&#39;).field(&#39;numberOfEmployees&#39;); var records_10 = sys.data.find(query_10); log('total: '+records_10.count()); while (records_10.hasNext()) { log(records_10.next().label()); } // leaves only number of employees and the sums up GET /data/contacts?{&#34;project&#34;: &#34;name,numberOfEmployees&#34;} When you run the above query, you will get output like this:
{&quot;id&quot;:&quot;57fd2d64e4b0ce322b0c8349&quot;,&quot;name&quot;:&quot;Photolist&quot;,&quot;numberOfEmployees&quot;:83} {&quot;id&quot;:&quot;57fd2d62e4b0ce322b0c6268&quot;,&quot;name&quot;:&quot;DabZ&quot;,&quot;numberOfEmployees&quot;:635} {&quot;id&quot;:&quot;57fd2d60e4b0ce322b0c50f0&quot;,&quot;name&quot;:&quot;Mydo&quot;,&quot;numberOfEmployees&quot;:917} {&quot;id&quot;:&quot;57fd2d64e4b0ce322b0c7d12&quot;,&quot;name&quot;:&quot;Zazio&quot;,&quot;numberOfEmployees&quot;:618} ... You can see that only the fields name and numberOfEmployees were included in the output (and id that is always there).
Group # The Group operation is the most important operation in your aggregation pipeline as it aggregates data. It allows you to group a set of records based on some fields and accumulate the results of those records into a field.
For example:
JS Query MapJS Query BuilderREST API // calculate the total number of skills per company var records_11 = sys.data.find('contacts', {project: &#39;company,numberOfSkills&#39;}, {group: {by: &#39;company&#39;, totalSkills: &#39;sum(numberOfSkills)&#39;}}); log('total: '+records_11.count()); while (records_11.hasNext()) { log(records_11.next().label()); } // calculate the total number of skills per company var query_11 = sys.data.createQuery('contacts') query.project().field(&#39;company&#39;).field(&#39;numberOfSkills&#39;); query.group().by(&#39;company&#39;).accumulate(&#39;totalSkills&#39;).sum(&#39;numberOfSkills&#39;); var records_11 = sys.data.find(query_11); log('total: '+records_11.count()); while (records_11.hasNext()) { log(records_11.next().label()); } // calculate the total number of skills per company GET /data/contacts?{&#34;project&#34;: &#34;company,numberOfSkills&#34;}, {&#34;group&#34;: {&#34;by&#34;: &#34;company&#34;, &#34;totalSkills&#34;: &#34;sum(numberOfSkills)&#34;}} For this query, you will get a result set like this:
{&quot;company&quot;:{&quot;id&quot;:&quot;57fd2d60e4b0ce322b0c503d&quot;,&quot;label&quot;:&quot;Jabbercube&quot;},&quot;totalSkills&quot;:4} {&quot;company&quot;:{&quot;id&quot;:&quot;57fd2d63e4b0ce322b0c75b0&quot;,&quot;label&quot;:&quot;Skilith&quot;},&quot;totalSkills&quot;:4} {&quot;company&quot;:{&quot;id&quot;:&quot;57fd2d61e4b0ce322b0c5dc6&quot;,&quot;label&quot;:&quot;Trupe&quot;},&quot;totalSkills&quot;:4} {&quot;company&quot;:{&quot;id&quot;:&quot;57fd2d60e4b0ce322b0c4c22&quot;,&quot;label&quot;:&quot;Feedbug&quot;},&quot;totalSkills&quot;:8} {&quot;company&quot;:{&quot;id&quot;:&quot;57fd2d62e4b0ce322b0c65ce&quot;,&quot;label&quot;:&quot;Realcube&quot;},&quot;totalSkills&quot;:8} {&quot;company&quot;:{&quot;id&quot;:&quot;57fd2d61e4b0ce322b0c530d&quot;,&quot;label&quot;:&quot;Flashset&quot;},&quot;totalSkills&quot;:12} {&quot;company&quot;:{&quot;id&quot;:&quot;57fd2d60e4b0ce322b0c51fe&quot;,&quot;label&quot;:&quot;Thoughtworks&quot;},&quot;totalSkills&quot;:8} {&quot;company&quot;:{&quot;id&quot;:&quot;57fd2d60e4b0ce322b0c4e02&quot;,&quot;label&quot;:&quot;Mynte&quot;},&quot;totalSkills&quot;:0} Here, you can see how data was grouped by the fields indicated in the by option (in this case, the company field), and then you have accumulators defined that are added as fields in the output (in this case, the totalSkills field).
Basically, the by option indicates how records will be grouped. Records that have the same value(s) in the fields listed in this option will belong to the same group. You can put more than one field if you separate the names using commas or call by() multiple times in the query builder.
Then you can define any number of accumulators. Each accumulator will be a field in the output and must use one of the accumulator operations available:
count()
This operation returns the number of records in the group. For example, you can count the number of contacts for each company.
JS Query MapJS Query BuilderREST API // counts contacts on each company var records_12 = sys.data.find('contacts', {project: &#39;company&#39;}, {group: {by: &#39;company&#39;, numberOfContacts: &#39;count()&#39;}}); log('total: '+records_12.count()); while (records_12.hasNext()) { log(records_12.next().label()); } // counts contacts on each company var query_12 = sys.data.createQuery('contacts') query.project().field(&#39;company&#39;).field(&#39;numberOfSkills&#39;); query.group().by(&#39;company&#39;).accumulate(&#39;numberOfContacts&#39;).count(); var records_12 = sys.data.find(query_12); log('total: '+records_12.count()); while (records_12.hasNext()) { log(records_12.next().label()); } // counts contacts on each company GET /data/contacts?{&#34;project&#34;: &#34;company&#34;}, {&#34;group&#34;: {&#34;by&#34;: &#34;company&#34;, &#34;numberOfContacts&#34;: &#34;count()&#34;}} sum(field)
This operation calculates the sum of the values in a specified field for the records in the group. For example, you can calculate the total number of skills per company.
JS Query MapJS Query BuilderREST API // calculate the total number of skills per company var records_13 = sys.data.find('contacts', {project: &#39;company,numberOfSkills&#39;}, {group: {by: &#39;company&#39;, totalSkills: &#39;sum(numberOfSkills)&#39;}}); log('total: '+records_13.count()); while (records_13.hasNext()) { log(records_13.next().label()); } // calculate the total number of skills per company var query_13 = sys.data.createQuery('contacts') query.project().field(&#39;company&#39;).field(&#39;numberOfSkills&#39;); query.group().by(&#39;company&#39;).accumulate(&#39;totalSkills&#39;).sum(&#39;numberOfSkills&#39;); var records_13 = sys.data.find(query_13); log('total: '+records_13.count()); while (records_13.hasNext()) { log(records_13.next().label()); } // calculate the total number of skills per company GET /data/contacts?{&#34;project&#34;: &#34;company,numberOfSkills&#34;}, {&#34;group&#34;: {&#34;by&#34;: &#34;company&#34;, &#34;totalSkills&#34;: &#34;sum(numberOfSkills)&#34;}} This only works for number fields like integer, money, decimal or percentage.
avg(field)
This operation calculates the average of the values in a specified field for the records in the group. It works for number fields like integer, money, decimal, or percentage.
JS Query MapJS Query BuilderREST API // calculate the average number of skills per company per contact var records_14 = sys.data.find('contacts', {project: &#39;company,numberOfSkills&#39;}, {group: {by: &#39;company&#39;, avgSkills: &#39;avg(numberOfSkills)&#39;}}); log('total: '+records_14.count()); while (records_14.hasNext()) { log(records_14.next().label()); } // calculate the average number of skills per company per contact var query_14 = sys.data.createQuery('contacts') query.project().field(&#39;company&#39;).field(&#39;numberOfSkills&#39;); query.group().by(&#39;company&#39;).accumulate(&#39;avgSkills&#39;).avg(&#39;numberOfSkills&#39;); var records_14 = sys.data.find(query_14); log('total: '+records_14.count()); while (records_14.hasNext()) { log(records_14.next().label()); } // calculate the average number of skills per company per contact GET /data/contacts?{&#34;project&#34;: &#34;company,numberOfSkills&#34;}, {&#34;group&#34;: {&#34;by&#34;: &#34;company&#34;, &#34;avgSkills&#34;: &#34;avg(numberOfSkills)&#34;}} Keep in mind that if the value of the field is null or the field isn&rsquo;t present at all in the record it won&rsquo;t count for the average calculation.
first(field)
This operation selects the value of the first record as the value of the output. It is often used in combination with the sort operator to find the first value of a field.
JS Query MapJS Query BuilderREST API // finds the contact with more skills per company var records_15 = sys.data.find('contacts', {sort: {&#39;numberOfSkills&#39;: &#39;desc&#39;}}, {group: {by: &#39;company&#39;, firstName: &#39;first(firstName)&#39;, lastName: &#39;first(lastName)&#39;, skills: &#39;first(numberOfSkills)&#39;}}); log('total: '+records_15.count()); while (records_15.hasNext()) { log(records_15.next().label()); } // finds the contact with more skills per company var query_15 = sys.data.createQuery('contacts') query.sort().by(&#39;numberOfSkills&#39;, &#39;desc&#39;); query.group().by(&#39;company&#39;).accumulate(&#39;firstName&#39;).first(&#39;firstName&#39;).accumulate(&#39;lastName&#39;).first(&#39;lastName&#39;).accumulate(&#39;skills&#39;).first(&#39;numberOfSkills&#39;); var records_15 = sys.data.find(query_15); log('total: '+records_15.count()); while (records_15.hasNext()) { log(records_15.next().label()); } // finds the contact with more skills per company GET /data/contacts?{&#34;sort&#34;: {&#34;numberOfSkills&#34;: &#34;desc&#34;}}, {&#34;group&#34;: {&#34;by&#34;: &#34;company&#34;, &#34;firstName&#34;: &#34;first(firstName)&#34;, &#34;lastName&#34;: &#34;first(lastName)&#34;, &#34;skills&#34;: &#34;first(numberOfSkills)&#34;}} last(field)
This operation selects the value of the last record as the value of the output. It is often used in combination with the sort operator to find the last value of a field.
JS Query MapJS Query BuilderREST API // finds the contact with more skills per company var records_16 = sys.data.find('contacts', {sort: {&#39;numberOfSkills&#39;: &#39;asc&#39;}}, {group: {by: &#39;company&#39;, firstName: &#39;last(firstName)&#39;, lastName: &#39;last(lastName)&#39;, skills: &#39;last(numberOfSkills)&#39;}}); log('total: '+records_16.count()); while (records_16.hasNext()) { log(records_16.next().label()); } // finds the contact with more skills per company var query_16 = sys.data.createQuery('contacts') query.sort().by(&#39;numberOfSkills&#39;, &#39;asc&#39;); query.group().by(&#39;company&#39;).accumulate(&#39;firstName&#39;).last(&#39;firstName&#39;).accumulate(&#39;lastName&#39;).last(&#39;lastName&#39;).accumulate(&#39;skills&#39;).last(&#39;numberOfSkills&#39;); var records_16 = sys.data.find(query_16); log('total: '+records_16.count()); while (records_16.hasNext()) { log(records_16.next().label()); } // finds the contact with more skills per company GET /data/contacts?{&#34;sort&#34;: {&#34;numberOfSkills&#34;: &#34;asc&#34;}}, {&#34;group&#34;: {&#34;by&#34;: &#34;company&#34;, &#34;firstName&#34;: &#34;last(firstName)&#34;, &#34;lastName&#34;: &#34;last(lastName)&#34;, &#34;skills&#34;: &#34;last(numberOfSkills)&#34;}} max(field)
This operation selects the maximum value from all records as the value of the output.
JS Query MapJS Query BuilderREST API // finds the maximum number of skills per company for one contact var records_17 = sys.data.find('contacts', {group: {by: &#39;company&#39;, skills: &#39;max(numberOfSkills)&#39;}}); log('total: '+records_17.count()); while (records_17.hasNext()) { log(records_17.next().label()); } // finds the maximum number of skills per company for one contact var query_17 = sys.data.createQuery('contacts') query.group().by(&#39;company&#39;).accumulate(&#39;skills&#39;).max(&#39;numberOfSkills&#39;); var records_17 = sys.data.find(query_17); log('total: '+records_17.count()); while (records_17.hasNext()) { log(records_17.next().label()); } // finds the maximum number of skills per company for one contact GET /data/contacts?{&#34;group&#34;: {&#34;by&#34;: &#34;company&#34;, &#34;skills&#34;: &#34;max(numberOfSkills)&#34;}} min(field)
This operation selects the minimum value from all records as the value of the output.
JS Query MapJS Query BuilderREST API // finds the minimum number of skills per company for one contact var records_18 = sys.data.find('contacts', {group: {by: &#39;company&#39;, skills: &#39;min(numberOfSkills)&#39;}}); log('total: '+records_18.count()); while (records_18.hasNext()) { log(records_18.next().label()); } // finds the minimum number of skills per company for one contact var query_18 = sys.data.createQuery('contacts') query.group().by(&#39;company&#39;).accumulate(&#39;skills&#39;).min(&#39;numberOfSkills&#39;); var records_18 = sys.data.find(query_18); log('total: '+records_18.count()); while (records_18.hasNext()) { log(records_18.next().label()); } // finds the minimum number of skills per company for one contact GET /data/contacts?{&#34;group&#34;: {&#34;by&#34;: &#34;company&#34;, &#34;skills&#34;: &#34;min(numberOfSkills)&#34;}} Limitations # These aggregation operations allow you to perform various calculations and data manipulations in your aggregated queries. However, it&rsquo;s essential to keep in mind that aggregated queries work well for small to moderate-sized datasets. If you need to analyze large datasets, it&rsquo;s recommended to use dedicated data analysis tools and services like Google BigQuery or Amazon Redshift.
`}),e.add({id:152,href:"/dev-reference/queries/ui-queries/",title:"UI queries",description:`Overview # UI Queries, or simplified queries for the UI, can be written in various parts of the UI generated by the app runtime. For instance, filters that you create in a grid view utilize these types of queries.
The primary objective is to enable app users to compose slightly more complex queries using plain text. For instance, you can create the following queries for an integer field:
Value is 10: 10 Value is 5 or 9: 5,9 Value ranges from 0 to 10 (inclusive): 0.`,content:`Overview # UI Queries, or simplified queries for the UI, can be written in various parts of the UI generated by the app runtime. For instance, filters that you create in a grid view utilize these types of queries.
The primary objective is to enable app users to compose slightly more complex queries using plain text. For instance, you can create the following queries for an integer field:
Value is 10: 10 Value is 5 or 9: 5,9 Value ranges from 0 to 10 (inclusive): 0..10 Value is greater than 10: &gt;10 Value is less than or equal to 20 or greater than or equal to 50: &lt;=20,&gt;=50 Not all types support all features, so it&rsquo;s important to check which features are supported by each type in its respective documentation.
These queries do not have a public REST API and can only be utilized through the UI.
Matching of values # Most text types default to using the &ldquo;like&rdquo; operator for matching values. For example, relationship, text, users, groups, etc., will use the &ldquo;like&rdquo; operator when matching values.
On the other hand, types like integer, time, date, etc., default to using the &ldquo;equals&rdquo; operator to match values.
If you want to force an &ldquo;equals&rdquo; match when the default is &ldquo;like,&rdquo; you can use =. For instance, if you want to match the word TEST exactly in a text field, you should use =TEST instead of just TEST.
Some types allow the use of special values for matching. For example, date fields support expressions like tomorrow or next 3 days. Make sure to consult the type&rsquo;s documentation to determine the default matching operator for values and if any special values are available for use.
Finally, you can match empty values by using a dash: -. This will match all records where the value of the field is empty.
Operators # These are the operators you can use for each field. Please refer to each type&rsquo;s documentation to determine which features are supported.
Multiple values # You can specify multiple values by separating them with commas. For example:
Value is like one, two, or three: one,two,three You can use &quot; when dealing with commas in the text. For example, the value should be like one,two or three: &quot;one,two&quot;,three You can use it with various different types. For example, for integers: 3,5,7 You can also combine them with other operators. For example, values ranging from 0 to 10 or from 20 to 30: 0..10,20..30 Between # This operator allows you to specify a range of values, which is useful for numeric types or date types. In this case, you should use the format from..to. Here are some examples:
Filter by integer field with values between 0 and 10 (inclusive): 0..10 Filter by decimal field with values between 2.5 and 4.5 (inclusive): 2.5..4.5 Filter by date field with values between 2016-07-01 and 2016-07-15: 2016-07-01..2016-07-15 Filter by time field with values between 09:00 and 12:00: 09:00..12:00 Less than # This operator allows you to specify the maximum value (exclusive) of a field, which is useful for numeric types or date types. In this case, you should use the format &lt;maxValue. Here are some examples:
Filter by integer field with values less than 10: &lt;10 Filter by decimal field with values less than 2.75: &lt;2.75 Filter by date field with values less than 2016-07-01: &lt;2016-07-01 Filter by time field with values less than 12:00: &lt;12:00 Less than or equal to # This operator allows you to specify the maximum value (inclusive) of a field, which is useful for numeric types or date types. In this case, you should use the format &lt;=maxValue. Here are some examples:
Filter by integer field with values less than or equal to 10: &lt;=10 Filter by decimal field with values less than or equal to 2.75: &lt;=2.75 Filter by date field with values less than or equal to 2016-07-01: &lt;=2016-07-01 Filter by time field with values less than or equal to 12:00: &lt;=12:00 Greater than # This operator allows you to specify the minimum value (exclusive) of a field, which is useful for numeric types or date types. In this case, you should use the format &gt;minValue. Here are some examples:
Filter by integer field with values greater than 10: &gt;10 Filter by decimal field with values greater than 2.75: &gt;2.75 Filter by date field with values greater than 2016-07-01: &gt;2016-07-01 Filter by time field with values greater than 12:00: &gt;12:00 Greater than or equal to # This operator allows you to specify the minimum value (inclusive) of a field, which is useful for numeric types or date types. In this case, you should use the format &gt;=minValue. Here are some examples:
Filter by integer field with values greater than or equal to 10: &gt;=10 Filter by decimal field with values greater than or equal to 2.75: &gt;=2.75 Filter by date field with values greater than or equal to 2016-07-01: &gt;=2016-07-01 Filter by time field with values greater than or equal to 12:00: &gt;=12:00 Starts with # This operator allows you to find strings that begin with the specified characters of a field, which is useful for text types. In this case, you should use the format /charToStartWith. Here are some examples:
Filter by text field with values that start with &rsquo;s&rsquo;: /s Filter by text field with values that start with &lsquo;Will&rsquo;: /Will Ends with # This operator allows you to find strings that end with the specified characters of a field, which is useful for text types. In this case, you should use the format charToEndWith/. Here are some examples:
Filter by text field with values that end with &rsquo;n&rsquo;: n/ Filter by text field with values that end with &lsquo;own&rsquo;: own/ Regular expressions # This operator allows you to find strings that match a specific regular expression in a field, which is useful for text types. In this case, you should use the format /regExp/. Here are some examples:
Filter by text field with values that start with an &lsquo;S&rsquo; or end with &rsquo;n&rsquo;: /^S.*|.*n$/ Filter by text field with values that end with &lsquo;own&rsquo;: /own$/ `}),e.add({id:153,href:"/getting-started/getting/first-steps/task-mananger/groups/",title:"Groups and permissions",description:"In this section, we&rsquo;ll cover how to set up permissions in your Slingr app. We&rsquo;ll create a new field for tasks to identify the user assigned to each task. Additionally, we&rsquo;ll create two groups: Manager and Support. The users in the Manager group will have access to all tasks, while the users in the Support group will only be able to see tasks assigned to them and won&rsquo;t be able to reassign tasks or change the task title.",content:`In this section, we&rsquo;ll cover how to set up permissions in your Slingr app. We&rsquo;ll create a new field for tasks to identify the user assigned to each task. Additionally, we&rsquo;ll create two groups: Manager and Support. The users in the Manager group will have access to all tasks, while the users in the Support group will only be able to see tasks assigned to them and won&rsquo;t be able to reassign tasks or change the task title.
Create the field &ldquo;Assignee&rdquo; on tasks # To start, let&rsquo;s create the new field for tasks:
Right-click on the node Model &gt; Entities &gt; Tasks &gt; Fields, and select New Field from the dropdown menu.
Fill in the form with the following details:
Label: Assignee Name: assignee Type: Relationship Related entity: System &gt; Users Click on Create and Edit.
Set the Default value to Script.
Complete the field Script.
return sys.context.getCurrentUserRecord(); Save the changes. Create &ldquo;Managers&rdquo; group # Now let’s add the two new groups:
Click the node Security &gt; Groups.
Click on the Create button on the top-right of the page.
Fill in the form with:
Label: Manager Name: manager Click on Create and Edit.
Now we need to add permissions to access entities and views. Click on the node Security &gt; Groups &gt; Manager &gt; Entity permissions.
Select the Task entity and then click on Apply permissions:
There select the option Read/write and click on Apply.
Then click on the configuration button under the Edit column, and configure fields permissions so fields Status and Rank are read-only.
This is the correct way to enforce permissions instead of just making the field read-only in the UI. Now, select the System &gt; Users entity and then click on Apply permissions, and this time select Read-Only.
Finally, click the Apply button on the top-right of the listing to persist changes.
Click on the node Security &gt; Groups &gt; Manager &gt; View permissions.
Set the flag in the column Permission for both views:
Finally, click the Apply button on the top-right of the listing to persist changes. Create a &ldquo;Support&rdquo; group # Now that we have our first group, create a new group called Support, and add some permissions to it:
Click on the node Security &gt; Groups &gt; Support &gt; Entity permissions.
In the Tasks entity, click on the configuration button under the Edit column.
Configure entity permissions like this:
Configure field permissions like this: Configure action permissions like this: Click on Apply.
Now, select the System &gt; Users entity, click on Apply permissions, and select Read-Only.
Save changes by clicking on Apply.
Configure view permissions in Security &gt; Groups &gt; Support &gt; View permissions in the same way as for managers.
Now that we have created the groups and defined their permissions, let&rsquo;s push the changes so we can use these groups when creating users.
Create different users # It&rsquo;s time to create a few users (make sure you have pushed the changes before):
Click on the node Security &gt; Users.
Click on the Create button at the top right of the page.
Fill in the form with:
First name: Manager1 Last name: Test Email: manager1@test.com Generate Password: true Groups: Add the Manager group as Primary Click on Create to save the user. Then repeat the same process for these users:
First name Last name Email Primary group Support1 Test support1@test.com Support Support2 Test support2@test.com Support You don't need to push changes when working with users because users are modified directly in the runtime as they aren't part of the metadata of the app. 😊
Awesome! We have finished this section and are almost done with our app.
In the next section, we will learn how to work with different users in the runtime.
`}),e.add({id:154,href:"/dev-reference/rest-apis/",title:"REST APIs",description:"",content:""}),e.add({id:155,href:"/dev-reference/rest-apis/apps-api/",title:"Apps REST API",description:`The Slingr API provides a versatile means of interacting with your app&rsquo;s data, executing actions, checking job statuses, reviewing logs, and more, all via a straightforward REST interface. Essentially, anything that can be accomplished through the app&rsquo;s user interface can also be achieved using these web services.
The Slingr API adheres to REST principles, although there may be some variations. Our primary data format is JSON.
To access the Slingr API, you can make requests to the following endpoint:`,content:`The Slingr API provides a versatile means of interacting with your app&rsquo;s data, executing actions, checking job statuses, reviewing logs, and more, all via a straightforward REST interface. Essentially, anything that can be accomplished through the app&rsquo;s user interface can also be achieved using these web services.
The Slingr API adheres to REST principles, although there may be some variations. Our primary data format is JSON.
To access the Slingr API, you can make requests to the following endpoint:
https://&lt;appName&gt;.slingrs.io/&lt;env&gt;/runtime/api Where:
&lt;appName&gt; is the name of your app. &lt;env&gt; is the name of the environment, such as dev or prod. Please note that HTTPS must always be used. Attempting to access our API via HTTP will result in an error.
All API requests should include the following headers:
- Content-Type: application/json - Accept: application/json - token: &lt;token_received_after_login&gt; General error codes # Here is a list of common HTTP status codes used in the Slingr API along with their descriptions:
HTTP Status Code Description 200 OK: The request was successful, and there are no errors. 400 Bad Request: The request is invalid. This can occur due to validation errors in the data you are sending or because the requested operation is not valid. 401 Unauthorized: You are not authorized to access this resource. You need to log in or the provided authentication token is not valid. 403 Forbidden: You have valid credentials, but you are attempting to access data or perform an operation for which you do not have the necessary permissions. 404 Not Found: The resource you are trying to access does not exist. 409 Conflict: This error occurs in the case of an optimistic locking exception. It happens when two users attempt to update the same record simultaneously, and the second user to make the update receives this error. 500 Internal Server Error: An unexpected internal error has occurred. If you encounter this error, please contact our support team as it indicates an issue on our end. 503 Service Unavailable: This error is returned when the application is undergoing maintenance and is temporarily unavailable. For specific details on errors related to each API method, please refer to the documentation for that specific method.
Authentication # Before you can make requests to the Slingr API, you must log in and obtain a valid token. Follow the steps below to acquire and utilize the token.
To obtain a token, make a POST request to the following URL:
POST /auth/login This method has no additional parameters, and the request body should have the following structure:
{ &quot;email&quot;: &quot;user@test.com&quot;, &quot;password&quot;: &quot;abcdefgh&quot; } The response will resemble the following:
{ &quot;app&quot;: &quot;appname&quot;, &quot;adminUserEmail&quot;: null, &quot;ip&quot;: &quot;::ffff:10.240.0.38&quot;, &quot;userEmail&quot;: &quot;user@test.com&quot;, &quot;userName&quot;: &quot;User Test&quot;, &quot;userId&quot;: &quot;57fce0c3e4b0ce322b0c06b2&quot;, &quot;token&quot;: &quot;eLJjYSjLUPLlIEe8lfJUOmzsVNvSRpOv&quot; } It will include the following fields:
Field Name Description app The code of the app to which the token belongs. adminUserEmail This field is used when impersonating another user. Refer to the following section for more details. ip The IP address from which the user logged in. userEmail The email address of the user you have logged in with. userName The full name of the user you have logged in with. userId The unique identifier of the user you have logged in with. token The most critical field, containing the token necessary for subsequent API requests. Keep in mind that this token may expire, so ensure your integration can handle token expiration. Once you have acquired the token, include it in the header of every API request as follows:
GET /data/companies &gt; Accept: application/json &gt; token: eLJjYSjLUPLlIEe8lfJUOmzsVNvSRpOv Be aware that tokens have a limited lifespan, typically expiring after 8 hours of inactivity. However, they may expire sooner due to maintenance or other internal tasks. If your token expires, you will receive a 401 error, indicating that you need to log in again.
Please ensure the security and confidentiality of your access token, as it provides authentication to your Slingr account.
Impersonating other users # Developer users or users with the appropriate permissions, such as the &ldquo;manage groups&rdquo; flag, have the capability to impersonate other users for various purposes. To perform user impersonation when logging in, you should include the following structure in the request body:
{ &quot;email&quot;: &quot;manager@test.com&quot;, &quot;password&quot;: &quot;manager_password&quot;, &quot;emailImpersonatedUser&quot;: &quot;employee@test.com&quot; } username: Your own username for authentication. password: Your own password for authentication. adminUserEmail: The email address of the user you wish to impersonate. When you provide the adminUserEmail field in the request body, you will log in as the specified user with their permissions and privileges. This feature is particularly valuable for testing and administrative purposes, allowing authorized users to perform actions on behalf of different users.
Ensure that user impersonation is used responsibly and only by users with the necessary permissions to prevent any unauthorized actions within the system.
The token response will include fields that reflect the impersonation scenario. Here&rsquo;s an example of what the response might look like:
{ &quot;app&quot;: &quot;appname&quot;, &quot;adminUserEmail&quot;: &quot;manager@test.com&quot;, &quot;ip&quot;: &quot;::ffff:10.240.0.39&quot;, &quot;userEmail&quot;: &quot;employee@test.com&quot;, &quot;userName&quot;: &quot;Employee Test&quot;, &quot;userId&quot;: &quot;57fe52ade4b0ce322b0cea32&quot;, &quot;token&quot;: &quot;NE8lUuA2Yi9K6gL9EaQaTLIQLvYIhIyv&quot; } Possible errors # When making login requests to the API, you may encounter the following error codes and their corresponding HTTP status codes along with their descriptions:
Error Code HTTP Status Code Description unauthorized 401 This error is thrown when the provided credentials are invalid. It can occur when either the user email does not exist or the password does not match. notFound 404 Indicates that the user you are trying to impersonate does not exist. forbidden 403 If the credentials are valid but you are not allowed to log in. This can happen due to various reasons, such as IP restrictions or attempting to impersonate a user without sufficient permissions. badRequest 400 Denotes a malformed request. For instance, this error occurs when the mandatory fields such as email and password are not provided in the request. applicationUnavailable 503 If the application is currently suspended or undergoing maintenance. Developer users may still have the capability to log in despite this condition. These error codes provide specific information about the issues encountered during the login process and can help troubleshoot any authentication problems effectively.
App data # For each entity within the app, a set of methods is automatically generated. For instance, if there is an entity named companies, the following methods will be available:
GET /data/companies GET /data/companies/{id} PUT /data/companies/{id} POST /data/companies DELETE /data/companies/{ids} These fundamental operations are available for every entity and enable you to perform common CRUD (Create, Read, Update, Delete) operations on your app&rsquo;s data.
The structure of the data returned or manipulated by these methods is determined by the fields defined within each entity. For example, when fetching a company record, the response will resemble the following:
{ &quot;id&quot;: &quot;57fd2d65e4b0ce322b0c8665&quot;, &quot;version&quot;: 379, &quot;label&quot;: &quot;Browsezoom&quot;, &quot;name&quot;: &quot;Browsezoom&quot;, &quot;state&quot;: &quot;pending&quot;, &quot;type&quot;: &quot;a&quot;, &quot;numberOfEmployees&quot;: 95, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;phoneNumber&quot;: &quot;1-702-845-9380&quot;, &quot;email&quot;: &quot;jwoodsrq@spotify.com&quot;, &quot;id&quot;: &quot;58837fdd3b063a0007603547&quot;, &quot;label&quot;: &quot;Contact Information&quot; }, &quot;addresses&quot;: [ { &quot;addressLine&quot;: &quot;4 Magdeline Place&quot;, &quot;zipCode&quot;: &quot;89145&quot;, &quot;city&quot;: &quot;Las Vegas&quot;, &quot;state&quot;: &quot;NV&quot;, &quot;id&quot;: &quot;57fd45aee4b0ce322b0c86aa&quot;, &quot;label&quot;: &quot;NV - 89145&quot; } ], &quot;homepage&quot;: &quot;http://www.browsezoom.com&quot;, &quot;taxId&quot;: &quot;350-KWM&quot;, &quot;rating&quot;: &quot;2.8&quot;, &quot;notes&quot;: &quot;modified notes&quot;, &quot;lastMeeting&quot;: 1429623180000, &quot;lastUpdate&quot;: 1485012900000 } There are basically two types of fields:
Record fields: Record fields are fields defined within each entity of your app. The format and characteristics of these fields depend on the data type assigned to them during entity creation. The types can include text, numbers, dates, and more. For specific details about the types and their format, please refer to the types documentation.
System fields: System fields are inherent to every record in your app and are automatically included. They provide essential information about the record and are crucial for various functionalities. The system fields include:
id: This is the unique identifier for each record. It is used to distinguish one record from another.
label: The label field contains the record&rsquo;s label, which is generated based on the instance label expression defined within the entity. This label is often used for display purposes and makes it easier to identify records.
version: The version field represents the record&rsquo;s version and is primarily used for optimistic locking. Optimistic locking ensures that record updates are synchronized and avoids conflicts when multiple users attempt to modify the same record simultaneously.
Understanding both record fields and system fields is essential for effectively working with your app&rsquo;s data and ensuring the integrity and consistency of your records. You can incorporate this revised information into your documentation to provide a clear distinction between record fields and system fields and their respective roles in your app&rsquo;s data.
Basic operations # Read one record # GET /data/{entityName}/{id} Reads one record by ID
Request # GET /data/{entityName}/{id} &gt; Accept: application/json &gt; token: token Parameter Required Default Description entityName Yes - The name of the entity to which the record belongs. id Yes - The unique identifier (ID) of the record you want to fetch. _fields No all By default, all fields of the record will be fetched. If you want to specify which fields to retrieve, you can pass this parameter. You can list multiple fields separated by commas, for example: _fields=name,type.
Note that system fields (e.g., id, version, etc.) will always be returned. _format No native Specifies the format in which to fetch the fields. There are two options: - native: Returns the raw values of each field. - plainText: Returns the values of the fields converted using the display option of each field. _relationshipsToFetch No - A comma-separated list of relationship fields to be fetched within the record. For instance, if an entity has relationship fields named company and region, you can fetch those referenced records like this: _relationshipsToFetch=company,region. Response # The JSON representation of the record is returned. More info about the format can be found here.
GET /data/{entityName}/{id} &lt; Content-Type: application/json { &quot;id&quot;: &quot;57fd2d65e4b0ce322b0c8665&quot;, &quot;version&quot;: 1, &quot;label&quot;: &quot;label&quot;, &quot;fieldA&quot;: &quot;value&quot;, &quot;fieldB&quot;: &quot;value&quot; &quot;fieldC&quot;: &quot;value&quot; } Posible errors # Error code HTTP status code Description forbidden 403 Provided token does not have permissions to access this record. notFound 404 Either entity or record ID does not exist. Samples # fetches one company record GET /data/companies/57fd2d65e4b0ce322b0c8665 &gt; Accept: application/json &gt; token: token GET /data/companies/57fd2d65e4b0ce322b0c8665 &lt; Content-Type: application/json { &quot;id&quot;: &quot;57fd2d65e4b0ce322b0c8665&quot;, &quot;version&quot;: 379, &quot;label&quot;: &quot;Browsezoom&quot;, &quot;name&quot;: &quot;Browsezoom&quot;, &quot;state&quot;: &quot;pending&quot;, &quot;type&quot;: &quot;a&quot;, &quot;numberOfEmployees&quot;: 95, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;phoneNumber&quot;: &quot;1-702-845-9380&quot;, &quot;email&quot;: &quot;jwoodsrq@spotify.com&quot;, &quot;id&quot;: &quot;58837fdd3b063a0007603547&quot;, &quot;label&quot;: &quot;Contact Information&quot; }, &quot;addresses&quot;: [ { &quot;addressLine&quot;: &quot;4 Magdeline Place&quot;, &quot;zipCode&quot;: &quot;89145&quot;, &quot;city&quot;: &quot;Las Vegas&quot;, &quot;state&quot;: &quot;NV&quot;, &quot;id&quot;: &quot;57fd45aee4b0ce322b0c86aa&quot;, &quot;label&quot;: &quot;NV - 89145&quot; } ], &quot;homepage&quot;: &quot;http://www.browsezoom.com&quot;, &quot;taxId&quot;: &quot;350-KWM&quot;, &quot;rating&quot;: &quot;2.8&quot;, &quot;notes&quot;: &quot;modified notes&quot;, &quot;lastMeeting&quot;: 1429623180000, &quot;lastUpdate&quot;: 1485012900000 } List records # GET /data/{entityName} Reads many records from one entity. You can specify filters and other options in the URL.
More information about queries can be found in Query language.
Request # GET /data/{entityName} &gt; Accept: application/json &gt; token: token Parameter Required Description entityName Yes Name of the entity the record belongs to. id No You can find information about other parameters in Query language. Response # A list of records in JSON representation will be returned.
GET /data/{entityName} &lt; Content-Type: application/json { &quot;total&quot;: 10, &quot;offset&quot;: &quot;57fd2d65e4b0ce322b0c8565&quot;, &quot;items&quot;: [ { &quot;id&quot;: &quot;57fd2d65e4b0ce322b0c8665&quot;, &quot;version&quot;: 1, &quot;label&quot;: &quot;label&quot;, &quot;fieldA&quot;: &quot;value&quot;, &quot;fieldB&quot;: &quot;value&quot; }, { &quot;id&quot;: &quot;57fd2d65e4b0ce322b0c8565&quot;, &quot;version&quot;: 1, &quot;label&quot;: &quot;label&quot;, &quot;fieldA&quot;: &quot;value&quot;, &quot;fieldB&quot;: &quot;value&quot; } ] } Path Description total The total number of records matched. If there are more than the records returned, you should use pagination to fetch more records. offset The offset to pass to get more records. items This is the list of records fetched. Posible errors # Error code HTTP status code Description badRequest 400 Query is not valid. forbidden 403 Provided token does not have permissions to access this entity or some of the fields you are querying by. notFound 404 Entity name does not exist. Samples # // fetches fields name and type of two companies in pending status GET /data/companies?state=pending&amp;_fields=name,type&amp;_size=2 &gt; Accept: application/json &gt; token: token GET /data/companies?state=pending&amp;_fields=name,type&amp;_size=2 &lt; Content-Type: application/json { &quot;total&quot;: 135, &quot;offset&quot;: &quot;57fd2d65e4b0ce322b0c8565&quot;, &quot;items&quot;: [ { &quot;id&quot;: &quot;57fd2d65e4b0ce322b0c8665&quot;, &quot;version&quot;: 379, &quot;label&quot;: &quot;Browsezoom&quot;, &quot;name&quot;: &quot;Browsezoom&quot;, &quot;type&quot;: &quot;a&quot; }, { &quot;id&quot;: &quot;57fd2d65e4b0ce322b0c8565&quot;, &quot;version&quot;: 375, &quot;label&quot;: &quot;Blogpad&quot;, &quot;name&quot;: &quot;Blogpad&quot;, &quot;type&quot;: &quot;b&quot; } ] } Create record # POST /data/{entityName} Creates a new record for the given entity.
Data is sent in the body and should be valid according to the entity structure and fields rules.
Request # The body of this request should be a record in JSON format based on the entity structure.
All fields you are sending have to be present in the entity definition and values have to match the format required by the type. Also, there might be validation rules you have to take into account.
POST /data/{entityName} &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;fieldA&quot;: &quot;value&quot;, &quot;fieldB&quot;: &quot;value&quot; &quot;fieldC&quot;: 10, &quot;nestedFields&quot;: [ { &quot;innerA&quot;: &quot;value&quot;, &quot;innerB&quot;: &quot;value&quot; }, { &quot;innerA&quot;: &quot;value&quot;, &quot;innerB&quot;: &quot;value&quot; } ] } Parameter Required Description entityName Yes Name of the entity the record will be added to. Response # The response is the same as if you do a GET /data/companies/{id}, which means that you will be able to get the ID and label of the created record, as well as other calculated/default fields the entity might have.
POST /data/{entityName} &lt; Content-Type: application/json { &quot;id&quot;: &quot;588775f63b063a0007604f4c&quot;, &quot;version&quot;: 0, &quot;label&quot;: &quot;label&quot;, &quot;fieldA&quot;: &quot;value&quot;, &quot;fieldB&quot;: &quot;value&quot; &quot;fieldC&quot;: 10, &quot;nestedFields&quot;: [ { &quot;id&quot;: &quot;588775f63b063a0007604f4c&quot;, &quot;label&quot;: &quot;label&quot;, &quot;innerA&quot;: &quot;value&quot;, &quot;innerB&quot;: &quot;value&quot; }, { &quot;id&quot;: &quot;588775f63b063a0007604f8a&quot;, &quot;label&quot;: &quot;label&quot;, &quot;innerA&quot;: &quot;value&quot;, &quot;innerB&quot;: &quot;value&quot; } ], &quot;calculatedField&quot;: &quot;value&quot; } Posible errors # Error code HTTP status code Description validationErrors 400 If there are validations errors, the response will look like this:
{ &ldquo;code&rdquo;: &ldquo;validationErrors&rdquo;,
&ldquo;message&rdquo;: &ldquo;There are validation errors&rdquo;, &ldquo;errors&rdquo;: [ { &ldquo;field&rdquo;: &ldquo;name&rdquo;, &ldquo;fieldLabel&rdquo;: &ldquo;Name&rdquo;, &ldquo;code&rdquo;: &ldquo;required&rdquo;, &ldquo;message&rdquo;: &ldquo;This field is required&rdquo;, &ldquo;additionalInfo&rdquo;: null }, { &ldquo;field&rdquo;: &ldquo;state&rdquo;, &ldquo;fieldLabel&rdquo;: &ldquo;State&rdquo;, &ldquo;code&rdquo;: &ldquo;invalid&rdquo;, &ldquo;message&rdquo;: &ldquo;Not a valid choice&rdquo;, &ldquo;additionalInfo&rdquo;: { &ldquo;rejectedValue&rdquo;: &ldquo;sdfsdfsd&rdquo; } }]
}
In this case you will get details information about the field having issues, the error code and a human readable description of the error. Additional information might be added depending on the type of error, for example the rejected value. forbidden 403 Provided token does not have permissions to create records on this entity. notFound 404 If entity name does not exist. Samples # // creates a new company POST /data/companies &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;name&quot;: &quot;Test 1&quot;, &quot;state&quot;: &quot;pending&quot;, &quot;type&quot;: &quot;a&quot;, &quot;numberOfEmployees&quot;: 95, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;phoneNumber&quot;: &quot;1-702-845-9380&quot;, &quot;email&quot;: &quot;jwoodsrq@spotify.com&quot; }, &quot;addresses&quot;: [ { &quot;addressLine&quot;: &quot;4 Magdeline Place&quot;, &quot;zipCode&quot;: &quot;89145&quot;, &quot;city&quot;: &quot;Las Vegas&quot;, &quot;state&quot;: &quot;NV&quot; } ], &quot;homepage&quot;: &quot;http://www.browsezoom.com&quot;, &quot;taxId&quot;: &quot;350-KWM&quot;, &quot;rating&quot;: &quot;2.8&quot;, &quot;notes&quot;: &quot;test notes&quot;, &quot;lastMeeting&quot;: 1429623180000 } POST /data/companies &lt; Content-Type: application/json { &quot;id&quot;: &quot;588775f63b063a0007604f4c&quot;, &quot;version&quot;: 0, &quot;label&quot;: &quot;Test 1&quot;, &quot;name&quot;: &quot;Test 1&quot;, &quot;state&quot;: &quot;pending&quot;, &quot;type&quot;: &quot;a&quot;, &quot;numberOfEmployees&quot;: 95, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;phoneNumber&quot;: &quot;1-702-845-9380&quot;, &quot;email&quot;: &quot;jwoodsrq@spotify.com&quot;, &quot;id&quot;: &quot;588775f63b063a0007604f4a&quot;, &quot;label&quot;: &quot;Contact Information&quot; }, &quot;addresses&quot;: [ { &quot;addressLine&quot;: &quot;4 Magdeline Place&quot;, &quot;zipCode&quot;: &quot;89145&quot;, &quot;city&quot;: &quot;Las Vegas&quot;, &quot;state&quot;: &quot;NV&quot;, &quot;id&quot;: &quot;588775f63b063a0007604f4b&quot;, &quot;label&quot;: &quot;NV - 89145&quot; } ], &quot;homepage&quot;: &quot;http://www.browsezoom.com&quot;, &quot;taxId&quot;: &quot;350-KWM&quot;, &quot;rating&quot;: &quot;2.8&quot;, &quot;notes&quot;: &quot;test notes&quot;, &quot;lastMeeting&quot;: 1429623180000, &quot;lastUpdate&quot;: 1485272566096 } Update record # PUT /data/{entityName}/{id} Updates a record data.
Data is sent in the body and should be valid according to the entity structure and fields rules.
Request # To update a record via the API, you should provide a JSON-formatted record in the request body. The fields you include in this JSON body must align with the structure defined in the entity. Additionally, the values must conform to the format required by the data type assigned to each field. Be aware that there might be validation rules enforced by the entity that you need to adhere to.
Key points to consider when sending an update request:
You can specify only the fields you wish to update. Fields that are not included in the JSON request body won&rsquo;t be modified. If you want to clear a field&rsquo;s value, set it to null explicitly.
An essential field to mention is version, which signifies the version of the record you are updating. This field is crucial for managing concurrency issues, especially when two users attempt to update the same record simultaneously. (Refer to the optimistic locking section below for further details.) If you do not provide the version field, your update will always overwrite existing data, regardless of other user modifications.
Please make sure to structure your update requests accordingly, taking into account the entity&rsquo;s schema, data type requirements, and any validation rules in place.
PUT /data/{entityName}/{id} &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;version&quot;: 1, &quot;fieldA&quot;: &quot;newValue&quot;, &quot;fieldB&quot;: &quot;newValue&quot;, &quot;nestedFields&quot;: [ { &quot;id&quot;: &quot;588775f63b063a0007604f4c&quot;, &quot;innerA&quot;: &quot;newValue&quot; }, { &quot;id&quot;: &quot;588775f63b063a0007604f8a&quot;, &quot;innerB&quot;: &quot;newValue&quot; } ] } Parameter Required Description entityName yes Name of the entity the record will be added to. id yes The ID of the record to update. If you provide the ID on the body it will be discarded and the ID sent in the URL parameter will be used. Response # The response is the same as if you do a GET /data/companies/{id}, which means that you will be able to get the ID and label of the created record, as well as other calculated/default fields the entity might have.
PUT /data/{entityName}/{id} &lt; Content-Type: application/json { &quot;id&quot;: &quot;588775f63b063a0007604ab2&quot;, &quot;version&quot;: 0, &quot;label&quot;: &quot;label&quot;, &quot;fieldA&quot;: &quot;newValue&quot;, &quot;fieldB&quot;: &quot;newValue&quot; &quot;fieldC&quot;: 10, &quot;nestedFields&quot;: [ { &quot;id&quot;: &quot;588775f63b063a0007604f4c&quot;, &quot;label&quot;: &quot;label&quot;, &quot;innerA&quot;: &quot;newValue&quot;, &quot;innerB&quot;: &quot;value&quot; }, { &quot;id&quot;: &quot;588775f63b063a0007604f8a&quot;, &quot;label&quot;: &quot;label&quot;, &quot;innerA&quot;: &quot;value&quot;, &quot;innerB&quot;: &quot;newValue&quot; } ], &quot;calculatedField&quot;: &quot;value&quot; } Posible errors # Error code HTTP status code Description validationErrors 400 If there are validations errors, the response will look like this:
{ &ldquo;code&rdquo;: &ldquo;validationErrors&rdquo;,
&ldquo;message&rdquo;: &ldquo;There are validation errors&rdquo;, &ldquo;errors&rdquo;: [ { &ldquo;field&rdquo;: &ldquo;name&rdquo;, &ldquo;fieldLabel&rdquo;: &ldquo;Name&rdquo;, &ldquo;code&rdquo;: &ldquo;required&rdquo;, &ldquo;message&rdquo;: &ldquo;This field is required&rdquo;, &ldquo;additionalInfo&rdquo;: null }, { &ldquo;field&rdquo;: &ldquo;state&rdquo;, &ldquo;fieldLabel&rdquo;: &ldquo;State&rdquo;, &ldquo;code&rdquo;: &ldquo;invalid&rdquo;, &ldquo;message&rdquo;: &ldquo;Not a valid choice&rdquo;, &ldquo;additionalInfo&rdquo;: { &ldquo;rejectedValue&rdquo;: &ldquo;sdfsdfsd&rdquo; } }]
}
In this case you will get details information about the field having issues, the error code and a human readable description of the error. Additional information might be added depending on the type of error, for example the rejected value. forbidden 403 Provided token does not have permissions to create records on this entity. notFound 404 If entity name does not exist. optimisticLocking 409 If another user modified the data in the middle. This can be determined only if you provide the version field. Samples # // updates a few fields in a company record PUT /data/companies/588775f63b063a0007604f4c &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;version&quot;: 1, &quot;state&quot;: &quot;active&quot;, &quot;type&quot;: &quot;b&quot;, &quot;numberOfEmployees&quot;: 100 } PUT /data/companies/588775f63b063a0007604f4c &lt; Content-Type: application/json { &quot;id&quot;: &quot;588775f63b063a0007604f4c&quot;, &quot;version&quot;: 2, &quot;label&quot;: &quot;Test 1&quot;, &quot;name&quot;: &quot;Test 1&quot;, &quot;state&quot;: &quot;active&quot;, &quot;type&quot;: &quot;b&quot;, &quot;numberOfEmployees&quot;: 100, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;phoneNumber&quot;: &quot;1-702-845-9380&quot;, &quot;email&quot;: &quot;jwoodsrq@spotify.com&quot;, &quot;id&quot;: &quot;588775f63b063a0007604f4a&quot;, &quot;label&quot;: &quot;Contact Information&quot; }, &quot;addresses&quot;: [ { &quot;addressLine&quot;: &quot;4 Magdeline Place&quot;, &quot;zipCode&quot;: &quot;89145&quot;, &quot;city&quot;: &quot;Las Vegas&quot;, &quot;state&quot;: &quot;NV&quot;, &quot;id&quot;: &quot;588775f63b063a0007604f4b&quot;, &quot;label&quot;: &quot;NV - 89145&quot; } ], &quot;homepage&quot;: &quot;http://www.browsezoom.com&quot;, &quot;taxId&quot;: &quot;350-KWM&quot;, &quot;rating&quot;: &quot;2.8&quot;, &quot;notes&quot;: &quot;test notes&quot;, &quot;lastMeeting&quot;: 1429623180000, &quot;lastUpdate&quot;: 1485288240000 } Delete one record # DELETE /data/{entityName}/{id} Deletes a record from the database. You won’t be able to recover the deleted record (except that you have enabled history for that entity).
Request # DELETE /data/{entityName}/{id} &gt; Accept: application/json &gt; token: token Parameter Required Description entityName yes Name of the entity the record belongs to. id yes ID of the record to delete. _async no This parameter indicates whether the deletion should be executed in the background, which is necessary if the execution is expected to take more than 30 seconds. When you set this parameter to true, the response from this method will provide a reference to the job responsible for executing the deletion. Response # The response will vary based on the async parameter. There are two possible responses:
Record: If the async parameter is set to false, this method will return the deleted record.
Job Reference: If the async parameter is set to true, the method will return a reference to the job responsible for executing the deletion process. Once the job is completed, you can retrieve the process&rsquo;s response from the job&rsquo;s results.
Posible errors # Error code HTTP status code Description forbidden 403 Provided token does not have permissions to delete this record. notFound 404 Either entity or record ID does not exist. Samples # // deletes one company DELETE /data/companies/588775f63b063a0007604f4c &gt; Accept: application/json &gt; token: token DELETE /data/companies/588775f63b063a0007604f4c &lt; Content-Type: application/json { &quot;id&quot;: &quot;588775f63b063a0007604f4c&quot;, &quot;version&quot;: 10, &quot;label&quot;: &quot;Test 1&quot;, &quot;name&quot;: &quot;Test 1&quot;, &quot;state&quot;: &quot;active&quot;, &quot;type&quot;: &quot;b&quot;, &quot;numberOfEmployees&quot;: 100, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;phoneNumber&quot;: &quot;1-702-845-9380&quot;, &quot;email&quot;: &quot;jwoodsrq@spotify.com&quot;, &quot;id&quot;: &quot;588775f63b063a0007604f4a&quot;, &quot;label&quot;: &quot;Contact Information&quot; }, &quot;addresses&quot;: [ { &quot;addressLine&quot;: &quot;4 Magdeline Place&quot;, &quot;zipCode&quot;: &quot;89145&quot;, &quot;city&quot;: &quot;Las Vegas&quot;, &quot;state&quot;: &quot;NV&quot;, &quot;id&quot;: &quot;588775f63b063a0007604f4b&quot;, &quot;label&quot;: &quot;NV - 89145&quot; } ], &quot;homepage&quot;: &quot;http://www.browsezoom.com&quot;, &quot;taxId&quot;: &quot;350-KWM&quot;, &quot;rating&quot;: &quot;2.8&quot;, &quot;notes&quot;: &quot;test notes&quot;, &quot;lastMeeting&quot;: 1429623180000, &quot;lastUpdate&quot;: 1485288240000 } // deletes one company in the background DELETE /data/companies/588775f63b063a0007604f4c?_async=true &gt; Accept: application/json &gt; token: token DELETE /data/companies/588775f63b063a0007604f4c?_async=true &lt; Content-Type: application/json { &quot;jobLink&quot;: &quot;/api/status/jobs/5887b6f23b063a0007604fa8&quot;, &quot;jobId&quot;: &quot;5887b6f23b063a0007604fa8&quot; } Delete many records # DELETE /data/{entityName}/{ids} This method allows you to delete multiple records from the database. It&rsquo;s important to note that once records are deleted, they cannot be recovered unless you have enabled history tracking for the respective entity.
Upon initiating this method, a job will be created to handle the record deletions in the background. While the method itself returns immediately, you can monitor the status of the job to determine when it completes.
Request # DELETE /data/{entityName}/{ids} &gt; Accept: application/json &gt; token: token Parameter Required Description entityName yes Name of the entity the records belongs to. id yes IDs of the records to delete separated by commas. _async no This parameter indicates whether the deletion should be executed in the background. This is necessary if either the execution is expected to take more than 30 seconds or if you intend to delete more than 1,000 records.
When you set this parameter to true, the method&rsquo;s response will provide a reference to the job responsible for executing the deletion. Response # The response varies depending on the value of the _async parameter. There are two possible responses:
1. Map with Records (if _async is false):
If the _async parameter is set to false, the result will be a map. Each record&rsquo;s ID will serve as the key, and the corresponding value will be a map containing fields for the status and response (which represents the deleted record in JSON format). In case of an error, the value will contain an errorMessage.
2. Job Reference (if _async is true):
When the _async parameter is set to true, the method returns a reference to the job responsible for executing the deletion process. Once the job is completed, you can find the response of the process within the job&rsquo;s results.
Posible errors # Error code HTTP status code Description forbidden 403 Provided token does not have permissions to delete records on this entity. notFound 404 If the entity name does not exist. Samples # // deletes two companies DELETE /data/companies/57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565 &gt; Accept: application/json &gt; token: token DELETE /data/companies/57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565 &lt; Content-Type: application/json { &quot;57fd2d65e4b0ce322b0c8665&quot;: { &quot;status&quot;: &quot;ok&quot;, &quot;response&quot;: { &quot;id&quot;: &quot;57fd2d65e4b0ce322b0c8665&quot;, &quot;version&quot;: 381, &quot;label&quot;: &quot;Browsezoom&quot;, &quot;entity&quot;: { &quot;id&quot;: &quot;57fce228e4b0f6600fdfb836&quot;, &quot;name&quot;: &quot;Companies&quot; }, &quot;name&quot;: &quot;Browsezoom&quot;, &quot;state&quot;: &quot;pending&quot;, &quot;type&quot;: &quot;a&quot;, &quot;numberOfEmployees&quot;: 95, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;id&quot;: &quot;58837fdd3b063a0007603547&quot;, &quot;label&quot;: &quot;Contact Information&quot; &quot;phoneNumber&quot;: &quot;1-702-845-9380&quot;, &quot;email&quot;: &quot;jwoodsrq@spotify.com&quot; }, &quot;addresses&quot;: [ { &quot;id&quot;: &quot;57fd45aee4b0ce322b0c86aa&quot;, &quot;label&quot;: &quot;NV - 89145&quot;, &quot;addressLine&quot;: &quot;4 Magdeline Place&quot;, &quot;zipCode&quot;: &quot;89145&quot;, &quot;city&quot;: &quot;Las Vegas&quot;, &quot;state&quot;: &quot;NV&quot; } ], &quot;homepage&quot;: &quot;http://www.browsezoom.com&quot;, &quot;taxId&quot;: &quot;350-KWM&quot;, &quot;rating&quot;: &quot;2.8&quot;, &quot;notes&quot;: &quot;modified notes&quot;, &quot;lastMeeting&quot;: 1429623180000, &quot;lastUpdate&quot;: 1485292080000 } }, &quot;57fd2d65e4b0ce322b0c8565&quot;: { &quot;status&quot;: &quot;ok&quot;, &quot;response&quot;: { &quot;id&quot;: &quot;57fd2d65e4b0ce322b0c8565&quot;, &quot;version&quot;: 377, &quot;label&quot;: &quot;Blogpad&quot;, &quot;name&quot;: &quot;Blogpad&quot;, &quot;state&quot;: &quot;pending&quot;, &quot;type&quot;: &quot;b&quot;, &quot;numberOfEmployees&quot;: 534, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;id&quot;: &quot;581224c8e4b0285870237cc5&quot;, &quot;label&quot;: &quot;Contact Information&quot;, &quot;phoneNumber&quot;: &quot;1-405-298-5885&quot;, &quot;email&quot;: &quot;molsonre@rakuten.co.jp&quot; }, &quot;addresses&quot;: [ { &quot;id&quot;: &quot;57fd45aee4b0ce322b0c86ac&quot;, &quot;label&quot;: &quot;OK - 73157&quot;, &quot;addressLine&quot;: &quot;4 Crownhardt Plaza&quot;, &quot;zipCode&quot;: &quot;73157&quot;, &quot;city&quot;: &quot;Oklahoma City&quot;, &quot;state&quot;: &quot;OK&quot; } ], &quot;homepage&quot;: &quot;http://www.blogpad.com&quot;, &quot;taxId&quot;: &quot;123-ABC&quot;, &quot;rating&quot;: &quot;3.3&quot;, &quot;notes&quot;: &quot;Aenean fermentum. Donec ut mauris eget massa tempor convallis. Nulla neque libero, convallis eget, eleifend luctus, ultricies eu, nibh.&quot;, &quot;lastMeeting&quot;: 1422111300000, &quot;lastUpdate&quot;: 1485292500000 } } } // deletes two companies in the background DELETE /data/companies/588775f63b063a0007604f4c,588775f63b063a0007604f8b?_async=true &gt; Accept: application/json &gt; token: token DELETE /data/companies/588775f63b063a0007604f4c,588775f63b063a0007604f8b?_async=true &lt; Content-Type: application/json { &quot;jobLink&quot;: &quot;/api/status/jobs/5887b6f23b063a0007604fa8&quot;, &quot;jobId&quot;: &quot;5887b6f23b063a0007604fa8&quot; } Delete records over query # DELETE /data/{entityName} This method is used to delete all records that match a specified query. It&rsquo;s important to note that once records are deleted, they cannot be recovered unless you have enabled history tracking for the corresponding entity.
Upon initiating this method, a job will be generated to handle the deletion of the records in the background. While the method itself returns promptly, you have the option to monitor the job&rsquo;s status to determine when the deletion process is complete.
Request # DELETE /data/{entityName} &gt; Accept: application/json &gt; token: token Parameter Required Default Description entityName yes - Name of the entity records belongs to. queryParameters no - These are the query parameters. See Query language for more information. _async no - This parameter indicates whether the deletion should be executed in the background, which is necessary if the execution is expected to take more than 30 seconds or you want to delete more than 1,000 records. When you set this parameter to true, the response from this method will provide a reference to the job responsible for executing the deletion. _lowPriority no - Sets job as low priority will make the deletion only happen when there are no many jobs running. _triggerEvents no true - _cascatdeOperations no true - Response # The response varies depending on the value of the _async parameter. There are two possible responses:
1. Map with Records (if _async is false):
If the _async parameter is set to false, the result will be a map. Each record&rsquo;s ID will serve as the key, and the corresponding value will be a map containing fields for the status and response (which represents the deleted record in JSON format). In case of an error, the value will contain an errorMessage.
2. Job Reference (if _async is true):
When the _async parameter is set to true, the method returns a reference to the job responsible for executing the deletion process. Once the job is completed, you can find the response of the process within the job&rsquo;s results.
Posible errors # Error code HTTP status code Description forbidden 403 Provided token does not have permissions to delete records on this entity. notFound 404 If the entity name does not exist. Samples # // deletes companies with type 'a' DELETE /data/companies?type=a &gt; Accept: application/json &gt; token: token DELETE /data/companies?type=a &lt; Content-Type: application/json { &quot;57fd2d65e4b0ce322b0c8665&quot;: { &quot;status&quot;: &quot;ok&quot;, &quot;response&quot;: { &quot;id&quot;: &quot;57fd2d65e4b0ce322b0c8665&quot;, &quot;version&quot;: 381, &quot;label&quot;: &quot;Browsezoom&quot;, &quot;entity&quot;: { &quot;id&quot;: &quot;57fce228e4b0f6600fdfb836&quot;, &quot;name&quot;: &quot;Companies&quot; }, &quot;name&quot;: &quot;Browsezoom&quot;, &quot;state&quot;: &quot;pending&quot;, &quot;type&quot;: &quot;a&quot;, &quot;numberOfEmployees&quot;: 95, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;id&quot;: &quot;58837fdd3b063a0007603547&quot;, &quot;label&quot;: &quot;Contact Information&quot; &quot;phoneNumber&quot;: &quot;1-702-845-9380&quot;, &quot;email&quot;: &quot;jwoodsrq@spotify.com&quot; }, &quot;addresses&quot;: [ { &quot;id&quot;: &quot;57fd45aee4b0ce322b0c86aa&quot;, &quot;label&quot;: &quot;NV - 89145&quot;, &quot;addressLine&quot;: &quot;4 Magdeline Place&quot;, &quot;zipCode&quot;: &quot;89145&quot;, &quot;city&quot;: &quot;Las Vegas&quot;, &quot;state&quot;: &quot;NV&quot; } ], &quot;homepage&quot;: &quot;http://www.browsezoom.com&quot;, &quot;taxId&quot;: &quot;350-KWM&quot;, &quot;rating&quot;: &quot;2.8&quot;, &quot;notes&quot;: &quot;modified notes&quot;, &quot;lastMeeting&quot;: 1429623180000, &quot;lastUpdate&quot;: 1485292080000 } } } deletes companies with type 'a' in the background DELETE /data/companies?_async=true&amp;type=a &gt; Accept: application/json &gt; token: token DELETE /data/companies?_async=true&amp;type=a &lt; Content-Type: application/json { &quot;jobLink&quot;: &quot;/api/status/jobs/5887b6f23b063a0007604fa8&quot;, &quot;jobId&quot;: &quot;5887b6f23b063a0007604fa8&quot; } Optimistic locking # Optimistic locking is a feature designed to prevent inadvertent overwriting of changes made by other users to a record. It accomplishes this by utilizing a record version, represented as a numerical value that increments each time a record undergoes modification.
When updating a record, if you include the version field within the request body and this version does not match the record&rsquo;s current version on the server, the operation will result in a 409 error. This mechanism effectively safeguards against unintentional overwrites of changes made by other users.
If the version field is omitted from the request, no version control will be applied, potentially leading to the unintentional overwriting of changes made by others. Consequently, it is strongly recommended to always include the version field when updating records.
Aggregate queries # PUT /data/{entityName}/aggregate You can perform aggregation operations like count, sum or average.
For detailed documentation please check Aggregate queries.
Request # The request’s body contains the chain of operations to execute over the entity records. For more information please check documentation for Aggregate queries.
PUT /data/{entityName}/aggregate &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token [ {&quot;operation1&quot;: &quot;settings&quot;}, {&quot;operation2&quot;: &quot;settings&quot;}, {&quot;operationN&quot;: &quot;settings&quot;} ] Parameter Required Description entityName Yes Name of the entity the record belongs to. Response # The result of the aggregation is returned. The format is specific to the aggregation done, so please check the documentation for Aggregate queries.
Posible errors # Error code HTTP status code Description badRequest 400 Aggregation query is not valid. forbidden 403 You are trying to aggregate data you don’t have permissions to read. This applies at the entity level, record level and field level. Samples # // counts the number of skills per company PUT /data/contacts/aggregate &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token [ {&quot;project&quot;: &quot;company,numberOfSkills&quot;}, {&quot;group&quot;: {&quot;by&quot;: &quot;company&quot;, &quot;totalSkills&quot;: &quot;sum(numberOfSkills)&quot;}} ] PUT /data/contacts/aggregate &lt; Content-Type: application/json { &quot;total&quot;: 6, &quot;items&quot;: [ { &quot;company&quot;: &quot;Trudoo&quot;, &quot;totalSkills&quot;: 1 }, { &quot;company&quot;: &quot;Riffwire&quot;, &quot;totalSkills&quot;: 3 }, { &quot;company&quot;: &quot;Snaptags&quot;, &quot;totalSkills&quot;: 2 }, { &quot;company&quot;: &quot;Edgeify&quot;, &quot;totalSkills&quot;: 0 }, { &quot;company&quot;: &quot;Flipopia&quot;, &quot;totalSkills&quot;: 3 }, { &quot;company&quot;: &quot;Rooxo&quot;, &quot;totalSkills&quot;: 4 } } ] Actions # Execute action over one record # PUT /data/{entityName}/{id}/{actionName} Execute an action over one record.
Request # When the action includes parameters, you can send these parameters within the request body. The format should follow the same structure as when creating or updating records. However, in this context, instead of fields, you should provide the parameters relevant to the action.
In cases where the action does not require any parameters, you can simply leave the request body empty.
PUT /data/{entityName}/{id}/{actionName} &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;param1&quot;: &quot;value&quot;, &quot;param2&quot;: value } Parameter Required Description entityName yes Name of the entity the record belongs to. id yes ID of the record to execute the action on. actionName yes The name of the action that has to be executed. _async no This parameter indicates whether the deletion should be executed in the background, which is necessary if the execution is expected to take more than 30 seconds. When you set this parameter to true, the response from this method will provide a reference to the job responsible for executing the deletion.
This parameter will override the default configured in the action. Response # The response varies based on the action type and the _async parameter. There are three possible response scenarios:
1. Record Response (if _async is false and the action type is &lsquo;One record&rsquo;):
When _async is set to false and the action does not return a custom response, this method will return the updated record. This scenario is applicable only to actions of type &lsquo;One record.&rsquo;
2. Custom Action&rsquo;s Response (if _async is false and the action returns a custom response):
When _async is false, and the action returns a custom response, that specific response will be returned. Note that actions of type &lsquo;Many records&rsquo; should always provide a custom response. If they do not return anything, an empty response will be generated.
3. Job Reference (if _async is true):
In cases where _async is set to true, the method will return a reference to the job responsible for executing the action. Once the action is completed, you can locate the response of the action within the job&rsquo;s results.
Below, you can find examples illustrating each of these response types.
Posible errors # Error code HTTP status code Description badRequest 400 If request is not allowed. For example, pre-conditions in the actions are not met. forbidden 403 You don’t have permissions to execute the action or you don’t have permissions for the record. notFound 404 Either entity or record ID does not exist. Samples # // executes a simple action over a company record, no custom response PUT /data/companies/57fd2d65e4b0ce322b0c8665/logSomething &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;param1&quot;: &quot;a&quot;, &quot;param2&quot;: &quot;b&quot; } PUT /data/companies/57fd2d65e4b0ce322b0c8665/logSomething &lt; Content-Type: application/json { &quot;id&quot;: &quot;57fd2d65e4b0ce322b0c8665&quot;, &quot;version&quot;: 381, &quot;label&quot;: &quot;Browsezoom&quot;, &quot;name&quot;: &quot;Browsezoom&quot;, &quot;state&quot;: &quot;pending&quot;, &quot;type&quot;: &quot;a&quot;, &quot;numberOfEmployees&quot;: 95, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;id&quot;: &quot;58837fdd3b063a0007603547&quot;, &quot;label&quot;: &quot;Contact Information&quot;, &quot;phoneNumber&quot;: &quot;1-702-845-9380&quot;, &quot;email&quot;: &quot;jwoodsrq@spotify.com&quot;, }, &quot;addresses&quot;: [ { &quot;id&quot;: &quot;57fd45aee4b0ce322b0c86aa&quot;, &quot;label&quot;: &quot;NV - 89145&quot;, &quot;addressLine&quot;: &quot;4 Magdeline Place&quot;, &quot;zipCode&quot;: &quot;89145&quot;, &quot;city&quot;: &quot;Las Vegas&quot;, &quot;state&quot;: &quot;NV&quot; } ], &quot;homepage&quot;: &quot;http://www.browsezoom.com&quot;, &quot;taxId&quot;: &quot;350-KWM&quot;, &quot;rating&quot;: &quot;2.8&quot;, &quot;notes&quot;: &quot;modified notes&quot;, &quot;lastMeeting&quot;: 1429623180000, &quot;lastUpdate&quot;: 1485292080000 } // executes a simple action over a company record in the background, no custom response PUT /data/companies/57fd2d65e4b0ce322b0c8665/logSomething?_async=true &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;param1&quot;: &quot;a&quot;, &quot;param2&quot;: &quot;b&quot; } PUT /data/companies/57fd2d65e4b0ce322b0c8665/logSomething?_async=true &lt; Content-Type: application/json { &quot;jobLink&quot;: &quot;/api/status/jobs/588f3e65b45fc9000bc1baa7&quot;, &quot;jobId&quot;: &quot;588f3e65b45fc9000bc1baa7&quot; } // executes an action that works with many records and returns a custom response PUT /data/companies/57fd2d65e4b0ce322b0c8665/countEmployees &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token PUT /data/companies/57fd2d65e4b0ce322b0c8665/countEmployees &lt; Content-Type: application/json { &quot;numberOfEmployees&quot;: 95 } Execute action over many records # PUT /data/{entityName}/{ids}/{actionName} Execute an action over many records. The action will be executed in each record one by one if the action is of type One record.
Request # When the action includes parameters, you can send these parameters within the request body. The format should follow the same structure as when creating or updating records. However, in this context, instead of fields, you should provide the parameters relevant to the action.
In cases where the action does not require any parameters, you can simply leave the request body empty.
PUT /data/{entityName}/{ids}/{actionName} &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;param1&quot;: &quot;value&quot;, &quot;param2&quot;: value } Parameter Required Description entityName yes Name of the entity the record belongs to. ids yes IDs of the records to execute the action on separated by commas. actionName yes The name of the action that has to be executed. _async no This parameter indicates whether the deletion should be executed in the background, which is necessary if the execution is expected to take more than 30 seconds or if it is applied over more than 1,000 records. When you set this parameter to true, the response from this method will provide a reference to the job responsible for executing the deletion.
This parameter will override the default configured in the action. Response # The response varies based on the action type and the _async parameter. There are three possible response scenarios:
1. Map with Records (if _async is false and the action type is &lsquo;One record&rsquo;):
When _async is set to false, and the action does not return a custom response, the result will be a map. Each record&rsquo;s ID serves as the key, and the corresponding value includes fields for the status and response (representing the record as JSON) or an errorMessage in case of an error. This applies specifically to actions of type &lsquo;One record.&rsquo;
2. Custom Action&rsquo;s Responses (if _async is false and the action returns a custom response):
When _async is false, and the action returns a custom response, a map is returned with each record&rsquo;s ID (for each record) serving as a key. Each key is associated with a map containing the status (&ldquo;ok&rdquo; or &ldquo;error&rdquo;) and a response field containing the custom response. Note that actions of type &lsquo;Many records&rsquo; should always provide a custom response. If they do not return anything, an empty response will be generated.
3. Job Reference (if _async is true):
In cases where _async is set to true, the method will return a reference to the job responsible for executing the action. Once the action is completed, you can find the response of the action within the results of the job.
Below, you can find examples illustrating each of these response types.
Posible errors # Error code HTTP status code Description forbidden 403 You don’t have permissions to execute the action. notFound 404 If the entity name does not exist. Samples # // executes a simple action over two company records, no custom response PUT /data/companies/57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565/logSomething &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;param1&quot;: &quot;a&quot;, &quot;param2&quot;: &quot;b&quot; } PUT /data/companies/57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565/logSomething &lt; Content-Type: application/json { &quot;57fd2d65e4b0ce322b0c8665&quot;: { &quot;status&quot;: &quot;ok&quot;, &quot;response&quot;: { &quot;id&quot;: &quot;57fd2d65e4b0ce322b0c8665&quot;, &quot;version&quot;: 381, &quot;label&quot;: &quot;Browsezoom&quot;, &quot;entity&quot;: { &quot;id&quot;: &quot;57fce228e4b0f6600fdfb836&quot;, &quot;name&quot;: &quot;Companies&quot; }, &quot;name&quot;: &quot;Browsezoom&quot;, &quot;state&quot;: &quot;pending&quot;, &quot;type&quot;: &quot;a&quot;, &quot;numberOfEmployees&quot;: 95, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;id&quot;: &quot;58837fdd3b063a0007603547&quot;, &quot;label&quot;: &quot;Contact Information&quot; &quot;phoneNumber&quot;: &quot;1-702-845-9380&quot;, &quot;email&quot;: &quot;jwoodsrq@spotify.com&quot; }, &quot;addresses&quot;: [ { &quot;id&quot;: &quot;57fd45aee4b0ce322b0c86aa&quot;, &quot;label&quot;: &quot;NV - 89145&quot;, &quot;addressLine&quot;: &quot;4 Magdeline Place&quot;, &quot;zipCode&quot;: &quot;89145&quot;, &quot;city&quot;: &quot;Las Vegas&quot;, &quot;state&quot;: &quot;NV&quot; } ], &quot;homepage&quot;: &quot;http://www.browsezoom.com&quot;, &quot;taxId&quot;: &quot;350-KWM&quot;, &quot;rating&quot;: &quot;2.8&quot;, &quot;notes&quot;: &quot;modified notes&quot;, &quot;lastMeeting&quot;: 1429623180000, &quot;lastUpdate&quot;: 1485292080000 } }, &quot;57fd2d65e4b0ce322b0c8565&quot;: { &quot;status&quot;: &quot;ok&quot;, &quot;response&quot;: { &quot;id&quot;: &quot;57fd2d65e4b0ce322b0c8565&quot;, &quot;version&quot;: 377, &quot;label&quot;: &quot;Blogpad&quot;, &quot;name&quot;: &quot;Blogpad&quot;, &quot;state&quot;: &quot;pending&quot;, &quot;type&quot;: &quot;b&quot;, &quot;numberOfEmployees&quot;: 534, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;id&quot;: &quot;581224c8e4b0285870237cc5&quot;, &quot;label&quot;: &quot;Contact Information&quot;, &quot;phoneNumber&quot;: &quot;1-405-298-5885&quot;, &quot;email&quot;: &quot;molsonre@rakuten.co.jp&quot; }, &quot;addresses&quot;: [ { &quot;id&quot;: &quot;57fd45aee4b0ce322b0c86ac&quot;, &quot;label&quot;: &quot;OK - 73157&quot;, &quot;addressLine&quot;: &quot;4 Crownhardt Plaza&quot;, &quot;zipCode&quot;: &quot;73157&quot;, &quot;city&quot;: &quot;Oklahoma City&quot;, &quot;state&quot;: &quot;OK&quot; } ], &quot;homepage&quot;: &quot;http://www.blogpad.com&quot;, &quot;taxId&quot;: &quot;123-ABC&quot;, &quot;rating&quot;: &quot;3.3&quot;, &quot;notes&quot;: &quot;Aenean fermentum. Donec ut mauris eget massa tempor convallis. Nulla neque libero, convallis eget, eleifend luctus, ultricies eu, nibh.&quot;, &quot;lastMeeting&quot;: 1422111300000, &quot;lastUpdate&quot;: 1485292500000 } } } // executes a simple action over two company records with custom response PUT /data/companies/57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565/customResponse &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token PUT /data/companies/57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565/customResponse &lt; Content-Type: application/json { &quot;57fd2d65e4b0ce322b0c8665&quot;: { &quot;status&quot;: &quot;ok&quot;, &quot;response&quot;: &quot;This is a custom response&quot; }, &quot;57fd2d65e4b0ce322b0c8565&quot;: { &quot;status&quot;: &quot;ok&quot;, &quot;response&quot;: &quot;This is a custom response&quot; } } // executes a simple action over two company records in the background PUT /data/companies/57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565/logSomething?_async=true &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;param1&quot;: &quot;a&quot;, &quot;param2&quot;: &quot;b&quot; } PUT /data/companies/57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565/logSomething?_async=true &lt; Content-Type: application/json { &quot;jobLink&quot;: &quot;/api/status/jobs/588f45e2b45fc9000bc1bd1f&quot;, &quot;jobId&quot;: &quot;588f45e2b45fc9000bc1bd1f&quot; } // executes an action that works with many records over two records and returns a custom response PUT /data/companies/57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565/countEmployees &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token PUT /data/companies/57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565/countEmployees &lt; Content-Type: application/json { &quot;numberOfEmployees&quot;: 629 } Execute action over query # PUT /data/{entityName}/{actionName} Execute an action over records matched by a query.
Request # When the action includes parameters, you can send these parameters within the request body. The format should follow the same structure as when creating or updating records. However, in this context, instead of fields, you should provide the parameters relevant to the action.
In cases where the action does not require any parameters, you can simply leave the request body empty.
PUT /data/{entityName}/{actionName} &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;param1&quot;: &quot;value&quot;, &quot;param2&quot;: value } Parameter Required Description entityName yes Name of the entity the records belongs to. id yes ID of the records to execute the action on. actionName yes The name of the action that has to be executed. _async no This parameter indicates whether the deletion should be executed in the background, which is necessary if the execution is expected to take more than 30 seconds or if it is applied over more than 1,000 records. When you set this parameter to true, the response from this method will provide a reference to the job responsible for executing the deletion.
This parameter will override the default configured in the action. queryParameters no These are the query parameters. See Query language for more information. Response # The response varies based on the action type and the _async parameter. There are three possible response scenarios:
1. Map with Records (if _async is false and the action type is &lsquo;One record&rsquo;):
When _async is set to false, and the action does not return a custom response, the result will be a map. Each record&rsquo;s ID serves as the key, and the corresponding value includes fields for the status and response (representing the record as JSON) or an errorMessage in case of an error. This applies specifically to actions of type &lsquo;One record.&rsquo;
2. Custom Action&rsquo;s Responses (if _async is false and the action returns a custom response):
When _async is false, and the action returns a custom response, a map is returned with each record&rsquo;s ID (for each record) serving as a key. Each key is associated with a map containing the status (&ldquo;ok&rdquo; or &ldquo;error&rdquo;) and a response field containing the custom response. Note that actions of type &lsquo;Many records&rsquo; should always provide a custom response. If they do not return anything, an empty response will be generated.
3. Job Reference (if _async is true):
In cases where _async is set to true, the method will return a reference to the job responsible for executing the action. Once the action is completed, you can find the response of the action within the results of the job.
Below, you can find examples illustrating each of these response types.
Posible errors # Error code HTTP status code Description forbidden 403 You don’t have permissions to execute the action. notFound 404 If the entity name does not exist. Samples # // executes a simple action over two company records, no custom response PUT /data/companies/logSomething?id=57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565 &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;param1&quot;: &quot;a&quot;, &quot;param2&quot;: &quot;b&quot; } PUT /data/companies/logSomething?id=57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565 &lt; Content-Type: application/json { &quot;57fd2d65e4b0ce322b0c8665&quot;: { &quot;status&quot;: &quot;ok&quot;, &quot;response&quot;: { &quot;id&quot;: &quot;57fd2d65e4b0ce322b0c8665&quot;, &quot;version&quot;: 381, &quot;label&quot;: &quot;Browsezoom&quot;, &quot;entity&quot;: { &quot;id&quot;: &quot;57fce228e4b0f6600fdfb836&quot;, &quot;name&quot;: &quot;Companies&quot; }, &quot;name&quot;: &quot;Browsezoom&quot;, &quot;state&quot;: &quot;pending&quot;, &quot;type&quot;: &quot;a&quot;, &quot;numberOfEmployees&quot;: 95, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;phoneNumber&quot;: &quot;1-702-845-9380&quot;, &quot;email&quot;: &quot;jwoodsrq@spotify.com&quot;, &quot;id&quot;: &quot;58837fdd3b063a0007603547&quot;, &quot;label&quot;: &quot;Contact Information&quot; }, &quot;addresses&quot;: [ { &quot;addressLine&quot;: &quot;4 Magdeline Place&quot;, &quot;zipCode&quot;: &quot;89145&quot;, &quot;city&quot;: &quot;Las Vegas&quot;, &quot;state&quot;: &quot;NV&quot;, &quot;id&quot;: &quot;57fd45aee4b0ce322b0c86aa&quot;, &quot;label&quot;: &quot;NV - 89145&quot; } ], &quot;homepage&quot;: &quot;http://www.browsezoom.com&quot;, &quot;taxId&quot;: &quot;350-KWM&quot;, &quot;rating&quot;: &quot;2.8&quot;, &quot;notes&quot;: &quot;modified notes&quot;, &quot;lastMeeting&quot;: 1429623180000, &quot;lastUpdate&quot;: 1485292080000 } }, &quot;57fd2d65e4b0ce322b0c8565&quot;: { &quot;status&quot;: &quot;ok&quot;, &quot;response&quot;: { &quot;id&quot;: &quot;57fd2d65e4b0ce322b0c8565&quot;, &quot;version&quot;: 377, &quot;label&quot;: &quot;Blogpad&quot;, &quot;name&quot;: &quot;Blogpad&quot;, &quot;state&quot;: &quot;pending&quot;, &quot;type&quot;: &quot;b&quot;, &quot;numberOfEmployees&quot;: 534, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;phoneNumber&quot;: &quot;1-405-298-5885&quot;, &quot;email&quot;: &quot;molsonre@rakuten.co.jp&quot;, &quot;id&quot;: &quot;581224c8e4b0285870237cc5&quot;, &quot;label&quot;: &quot;Contact Information&quot; }, &quot;addresses&quot;: [ { &quot;addressLine&quot;: &quot;4 Crownhardt Plaza&quot;, &quot;zipCode&quot;: &quot;73157&quot;, &quot;city&quot;: &quot;Oklahoma City&quot;, &quot;state&quot;: &quot;OK&quot;, &quot;id&quot;: &quot;57fd45aee4b0ce322b0c86ac&quot;, &quot;label&quot;: &quot;OK - 73157&quot; } ], &quot;homepage&quot;: &quot;http://www.blogpad.com&quot;, &quot;taxId&quot;: &quot;123-ABC&quot;, &quot;rating&quot;: &quot;3.3&quot;, &quot;notes&quot;: &quot;Aenean fermentum. Donec ut mauris eget massa tempor convallis. Nulla neque libero, convallis eget, eleifend luctus, ultricies eu, nibh.&quot;, &quot;lastMeeting&quot;: 1422111300000, &quot;lastUpdate&quot;: 1485292500000 } } } // executes a simple action over two company records with custom response PUT /data/companies/customResponse?id=57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565 &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token PUT /data/companies/customResponse?id=57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565 &lt; Content-Type: application/json { &quot;57fd2d65e4b0ce322b0c8665&quot;: { &quot;status&quot;: &quot;ok&quot;, &quot;response&quot;: &quot;This is a custom response&quot; }, &quot;57fd2d65e4b0ce322b0c8565&quot;: { &quot;status&quot;: &quot;ok&quot;, &quot;response&quot;: &quot;This is a custom response&quot; } } // executes a simple action over two company records in the background PUT /data/companies/logSomething?_async=true&amp;id=57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565 &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;param1&quot;: &quot;a&quot;, &quot;param2&quot;: &quot;b&quot; } PUT /data/companies/logSomething?_async=true&amp;id=57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565 &lt; Content-Type: application/json { &quot;jobLink&quot;: &quot;/api/status/jobs/588f45e2b45fc9000bc1bd1f&quot;, &quot;jobId&quot;: &quot;588f45e2b45fc9000bc1bd1f&quot; } // executes an action that works with many records over two records and returns a custom response PUT /data/companies/countEmployees?id=57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565 &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token PUT /data/companies/countEmployees?id=57fd2d65e4b0ce322b0c8665,57fd2d65e4b0ce322b0c8565 &lt; Content-Type: application/json { &quot;numberOfEmployees&quot;: 629 } Import records # POST /data/{entityName}/import Imports records from a CSV file.
Request # This feature allows you to import records from a CSV file into your system. When preparing the CSV file, please adhere to the following rules:
Headers:
Headers in the CSV file should correspond to the field paths you wish to import. For instance, a field named &ldquo;name&rdquo; located at the root of the entity should have &ldquo;name&rdquo; as its header. For nested fields, use the full path, such as &ldquo;address.state.&rdquo; When dealing with multi-valued fields, specify the index, like &ldquo;phoneNumbers[0]&rdquo; or &ldquo;phoneNumbers[1].&rdquo;
Data Format:
The data format in the CSV file should match the type of each field being imported. Refer to the documentation for each field type to ensure you are using the correct format.
Template Creation:
To create a CSV file template, you can often export existing records using field names instead of labels as a starting point.
Record Handling:
Records will be created if they do not already exist in the system. If records already exist, they will be updated. To determine if a record exists, a unique field must be included in the CSV file&rsquo;s headers. If multiple unique fields are present, the first one encountered will be used. Importing into Related Entities:
It is also possible to import records into related entities. For example, if you have a &ldquo;contacts&rdquo; entity with a relationship called &ldquo;company&rdquo; pointing to the &ldquo;companies&rdquo; entity, your CSV file headers can reflect this relationship structure:
company.name,company.type,firstName,lastName,email Your CSV file includes headers like &ldquo;company.name&rdquo; and &ldquo;company.type&rdquo; referring to fields within the &ldquo;companies&rdquo; entity. In this scenario:
The import process will attempt to match an existing company based on the &ldquo;name&rdquo; field (assuming &ldquo;name&rdquo; is a unique field) and update its &ldquo;type&rdquo; field if a match is found.
If no match is found, a new record will be created in the &ldquo;companies&rdquo; entity, and it will be associated with the record in the &ldquo;contacts&rdquo; entity. This enables you to create records in multiple entities with just a single import.
The entire import process occurs within the context of a background job, ensuring efficient handling of the data.
POST /data/{entityName}/import &gt; Content-Type: multipart/form-data &gt; Accept: application/json &gt; token: token Parameter Required Default Description entityName Yes - Specifies the name of the entity to which the record belongs. file Yes - Indicates the multi-part CSV file to be imported. lowPriority No - When set, the import process is scheduled to execute when there are fewer concurrent jobs running. This is particularly useful for large imports to prevent delays in other job executions. updateCalculatedFields No True Allows you to expedite large imports by skipping the recalculation of calculated fields. However, this may result in calculated fields having outdated values, which can be recalculated later. (Note: This option is intended for developers.) updateRelationships No True Controls whether an import updating a record&rsquo;s label triggers a cascade update in related records. Disabling this feature can improve performance for large imports. (Note: This option is intended for developers.) performValidations No True By setting this to false, you can skip type-based validations during import. Structural and data format validations remain active, ensuring data integrity. For example, an integer field may skip max and min value validations but still require a numeric value. (Note: This option is intended for developers.) filterByAccessRules No True Determines whether fields should be filtered based on access rules. Disabling this feature results in importing all fields regardless of their accessibility, potentially enhancing import performance. (Note: This option is intended for developers.) performSecurityChecks No True When set to false, security permissions are bypassed during import. This can improve performance or mitigate certain issues during the import process. (Note: This option is intended for developers.) triggerEvents No True Governs the execution of event listeners associated with record creation or updates. If disabled (set to false), these listeners will not be triggered. (Note: This option is intended for developers.) setDefaultValues No True Controls whether default values are calculated for fields during import. Disabling this feature can enhance performance during large imports. (Note: This option is intended for developers.) supportTransientFields No True Decides whether transient fields are managed as transient during import. Disabling this feature may improve performance in large imports. (Note: This option is intended for developers.) cascadeOperations No True Specifies whether importing or updating records can trigger various cascade operations, such as copying fields or aggregating data. Setting this to false prevents these operations. (Note: This option is intended for developers.) skipRecordsWithInvalidFields No True Determines the treatment of records with invalid fields (validation errors). If set to false, records will be created or updated with errors that must be corrected later. (Note: This option is intended for developers.) Response # A reference to the job in charge of perform the import.
POST /data/{entityName}/import &lt; Content-Type: application/json { &quot;jobLink&quot;: &quot;/api/status/jobs/588f8357b45fc9000bc1bd2a&quot;, &quot;jobId&quot;: &quot;588f8357b45fc9000bc1bd2a&quot; } Posible errors # Error code HTTP status code Description forbidden 403 You don’t have permissions to import records on this entity. notFound 404 The entity name does not exist. Samples # // imports a few companies from a CSV file POST /data/companies/import &gt; Content-Type: multipart/form-data &gt; Accept: application/json &gt; token: token name,type test1,a test2,b test3,c POST /data/companies/import &lt; Content-Type: application/json { &quot;jobLink&quot;: &quot;/api/status/jobs/588f3e65b45fc9000bc1baa7&quot;, &quot;jobId&quot;: &quot;588f3e65b45fc9000bc1baa7&quot; } Export records # PUT /data/{entityName}/export This feature allows you to export records to a CSV file. You have the flexibility to apply filters to determine which records to export using a query and select specific fields to include in the export.
To specify which fields should be included in the CSV file, you can use the _fields parameter. Its usage is similar to queries, but with a few distinctions:
You can include related fields, which are fields located in the entities pointed to by relationship fields. For instance, if you have a relationship field named &ldquo;company&rdquo; that references the &ldquo;companies&rdquo; entity, you can specify &ldquo;company.type&rdquo; to be included in the CSV file. If you only specify &ldquo;company,&rdquo; only the label will be exported.
If you leave the _fields parameter empty, all fields will be included in the export, except for related fields.
System fields such as &quot;id,&quot; &quot;label,&quot; and &quot;version&quot; are not included in the export.
This flexibility allows you to tailor your CSV exports to your specific needs.
Request # PUT /data/{entityName}/export &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token Parameter Required Description entityName Yes Name of the entity the record belongs to. _useFieldNames No This flag modifies how headers are generated. If it is set to true it will use the name instead of the label to build the headers. Otherwise the label will be used, which is the default. queryParameters No These are the query parameters. See Query language for more information. Response # A reference to the job in charge of perform the import. To actually fetch the file you need to check when the job is finished and look into the results of the job, where you’ll find something like this:
{ ... &quot;hasErrors&quot;: false, &quot;results&quot;: { &quot;fileLink&quot;: &quot;https://docs.slingrs.io/dev/runtime/api/files/588f864eb45fc9000bc1bd5c&quot;, &quot;fileId&quot;: &quot;588f864eb45fc9000bc1bd5c&quot;, &quot;recordsExported&quot;: 283 }, &quot;status&quot;: &quot;FINISHED&quot; } The field results.fileLink contains the URL to download the file. You need to pass the token in the headers when fetching the file or the token needs to be set in cookies.
PUT /data/{entityName}/export &lt; Content-Type: application/json { &quot;jobLink&quot;: &quot;/api/status/jobs/588f8357b45fc9000bc1bd2a&quot;, &quot;jobId&quot;: &quot;588f8357b45fc9000bc1bd2a&quot; } Posible errors # Error code HTTP status code Description badRequest 400 If you are trying to export more than 1,000,000 records or if query is invalid. forbidden 403 You don’t have permissions to export records on this entity. notFound 404 The entity name does not exist. Samples # // exports companies with type 'b', with a maxium of 50 records PUT /data/companies/export?type=b&amp;_size=50 &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token PUT /data/companies/export?type=b&amp;_size=50 &lt; Content-Type: application/json { &quot;jobLink&quot;: &quot;/api/status/jobs/588f3e65b45fc9000bc1baa7&quot;, &quot;jobId&quot;: &quot;588f3e65b45fc9000bc1baa7&quot; } // exports companies with type 'b', with a maxium of 50 records but only the fields name, address-&gt;state and mainContact-&gt;email. PUT /data/companies/export?type=b&amp;_size=50&amp;_fields=name,address.state,mainContact.email &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token PUT /data/companies/export?type=b&amp;_size=50&amp;_fields=name,address.state,mainContact.email &lt; Content-Type: application/json { &quot;jobLink&quot;: &quot;/api/status/jobs/588f3e65b45fc9000bc1baa8&quot;, &quot;jobId&quot;: &quot;588f3e65b45fc9000bc1baa8&quot; } History # History for one record # GET /data/{entityName}/{id}/history Returns the history of a record. The entity needs to have history logs enabled.
Request # GET /data/{entityName}/{id}/history &gt; Accept: application/json &gt; token: token Parameter Required Description entityName Yes Name of the entity the record belongs to. id Yes The ID of the record to get its history. _size No The number of history records to fetch. Always the latests logs will be retrieved. _offset No Specifies an ID of a history log to start fetching logs from. This is to allow pagination. Response # The list of history logs for that record, sorted from the newest to the oldest ones.
GET /data/{entityName}/{id}/history &lt; Content-Type: application/json { &quot;total&quot;: 2, &quot;offset&quot;: &quot;588f8b99b45fc9000bc1bfc5&quot;, &quot;items&quot;: [ { &quot;id&quot;: &quot;588f8ba7b45fc9000bc1bfce&quot;, &quot;entityId&quot;: &quot;57fce228e4b0f6600fdfb836&quot;, &quot;entityName&quot;: &quot;companies&quot;, &quot;entityVersion&quot;: 57, &quot;recordId&quot;: &quot;588f8b99b45fc9000bc1bfc4&quot;, &quot;recordName&quot;: &quot;test1&quot;, &quot;user&quot;: &quot;dgaviola@slingr.io&quot;, &quot;timestamp&quot;: 1485802407010, &quot;ip&quot;: &quot;::ffff:10.240.0.15&quot;, &quot;eventType&quot;: &quot;USER_RECORD_CHANGED&quot;, &quot;eventCategory&quot;: &quot;USER&quot;, &quot;contextPath&quot;: &quot;entities.companies.update&quot;, &quot;recordDeleted&quot;: null, &quot;deletionDate&quot;: null, &quot;oldRecord&quot;: { &quot;type&quot;: { &quot;json&quot;: &quot;a&quot;, &quot;text&quot;: &quot;{type:a}&quot; }, &quot;addresses&quot;: { &quot;json&quot;: null, &quot;text&quot;: &quot;{}&quot; } }, &quot;newRecord&quot;: { &quot;type&quot;: { &quot;json&quot;: &quot;b&quot;, &quot;text&quot;: &quot;{type:b}&quot; }, &quot;addresses&quot;: { &quot;json&quot;: null, &quot;text&quot;: &quot;{}&quot; } } }, { &quot;id&quot;: &quot;588f8b99b45fc9000bc1bfc5&quot;, &quot;entityId&quot;: &quot;57fce228e4b0f6600fdfb836&quot;, &quot;entityName&quot;: &quot;companies&quot;, &quot;entityVersion&quot;: 57, &quot;recordId&quot;: &quot;588f8b99b45fc9000bc1bfc4&quot;, &quot;recordName&quot;: &quot;test1&quot;, &quot;user&quot;: &quot;dgaviola@slingr.io&quot;, &quot;timestamp&quot;: 1485802393836, &quot;ip&quot;: &quot;::ffff:10.240.0.11&quot;, &quot;eventType&quot;: &quot;USER_RECORD_CREATED&quot;, &quot;eventCategory&quot;: &quot;USER&quot;, &quot;contextPath&quot;: &quot;entities.companies.create&quot;, &quot;recordDeleted&quot;: null, &quot;deletionDate&quot;: null, &quot;oldRecord&quot;: {}, &quot;newRecord&quot;: { &quot;name&quot;: &quot;test1&quot;, &quot;state&quot;: &quot;active&quot;, &quot;type&quot;: &quot;a&quot;, &quot;numberOfEmployees&quot;: null, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;phoneNumber&quot;: null, &quot;email&quot;: null, &quot;id&quot;: &quot;588f8b99b45fc9000bc1bfc3&quot;, &quot;label&quot;: &quot;Contact Information&quot; }, &quot;homepage&quot;: null, &quot;taxId&quot;: null, &quot;rating&quot;: null, &quot;notes&quot;: null, &quot;lastMeeting&quot;: null, &quot;lastUpdate&quot;: 1485802380000 } } ] } Path Description total Total number of history logs for the record. offset ID of the latest history log; include it as the _offset parameter for pagination to retrieve subsequent records. items History logs with various fields; explanations for some key fields are provided below. items[].eventCategory Category of the event, with possible values: 'USER' (change made by a user), 'SCRIPT' (change made by a script), 'SYSTEM' (system changes like cascade updates). items[].eventType Type of event, depending on the category; options include:
- 'USER_RECORD_CREATED',
- 'USER_RECORD_CHANGED',
- 'USER_RECORD_DELETED', - 'USER_ACTION_PERFORMED', - 'SCRIPT_RECORD_CREATED', - 'SCRIPT_RECORD_CHANGED', - 'SCRIPT_RECORD_DELETED', - 'SCRIPT_ACTION_PERFORMED', - 'SYSTEM_CASCADE_UPDATE', and - 'SYSTEM_REFACTORING'. items[].contextPath Path describing where the change occurred; for example, it specifies which script made the change if it was a script. items[].recordDeleted Indicates if the record has been deleted (true or false). items[].deletionDate Date when the record was deleted. items[].oldRecord Contains the old values of modified fields in both JSON format and a more human-readable format. items[].newRecord Contains the new values of modified fields in both JSON format and a more human-readable format. Posible errors # Error code HTTP Status Code Description badRequest 400 Invalid record ID provided. forbidden 403 Insufficient permissions to view the history of records for the entity. notFound 404 Entity name does not exist. Note that this error may not be returned if the record ID does not exist, as it could refer to a deleted record. Samples # // gets the history of a company record GET /data/companies/588f8b99b45fc9000bc1bfc4/history &gt; Accept: application/json &gt; token: token GET /data/companies/588f8b99b45fc9000bc1bfc4/history &lt; Content-Type: application/json { &quot;total&quot;: 2, &quot;offset&quot;: &quot;588f8b99b45fc9000bc1bfc5&quot;, &quot;items&quot;: [ { &quot;id&quot;: &quot;588f8ba7b45fc9000bc1bfce&quot;, &quot;entityId&quot;: &quot;57fce228e4b0f6600fdfb836&quot;, &quot;entityName&quot;: &quot;companies&quot;, &quot;entityVersion&quot;: 57, &quot;recordId&quot;: &quot;588f8b99b45fc9000bc1bfc4&quot;, &quot;recordName&quot;: &quot;test1&quot;, &quot;user&quot;: &quot;dgaviola@slingr.io&quot;, &quot;timestamp&quot;: 1485802407010, &quot;ip&quot;: &quot;::ffff:10.240.0.15&quot;, &quot;eventType&quot;: &quot;USER_RECORD_CHANGED&quot;, &quot;eventCategory&quot;: &quot;USER&quot;, &quot;contextPath&quot;: &quot;entities.companies.update&quot;, &quot;recordDeleted&quot;: null, &quot;deletionDate&quot;: null, &quot;oldRecord&quot;: { &quot;type&quot;: { &quot;json&quot;: &quot;a&quot;, &quot;text&quot;: &quot;{type:a}&quot; }, &quot;addresses&quot;: { &quot;json&quot;: null, &quot;text&quot;: &quot;{}&quot; } }, &quot;newRecord&quot;: { &quot;type&quot;: { &quot;json&quot;: &quot;b&quot;, &quot;text&quot;: &quot;{type:b}&quot; }, &quot;addresses&quot;: { &quot;json&quot;: null, &quot;text&quot;: &quot;{}&quot; } } }, { &quot;id&quot;: &quot;588f8b99b45fc9000bc1bfc5&quot;, &quot;entityId&quot;: &quot;57fce228e4b0f6600fdfb836&quot;, &quot;entityName&quot;: &quot;companies&quot;, &quot;entityVersion&quot;: 57, &quot;recordId&quot;: &quot;588f8b99b45fc9000bc1bfc4&quot;, &quot;recordName&quot;: &quot;test1&quot;, &quot;user&quot;: &quot;dgaviola@slingr.io&quot;, &quot;timestamp&quot;: 1485802393836, &quot;ip&quot;: &quot;::ffff:10.240.0.11&quot;, &quot;eventType&quot;: &quot;USER_RECORD_CREATED&quot;, &quot;eventCategory&quot;: &quot;USER&quot;, &quot;contextPath&quot;: &quot;entities.companies.create&quot;, &quot;recordDeleted&quot;: null, &quot;deletionDate&quot;: null, &quot;oldRecord&quot;: {}, &quot;newRecord&quot;: { &quot;name&quot;: &quot;test1&quot;, &quot;state&quot;: &quot;active&quot;, &quot;type&quot;: &quot;a&quot;, &quot;numberOfEmployees&quot;: null, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;phoneNumber&quot;: null, &quot;email&quot;: null, &quot;id&quot;: &quot;588f8b99b45fc9000bc1bfc3&quot;, &quot;nestedFieldLabel&quot;: &quot;Contact Information&quot;, &quot;id&quot;: &quot;588f8b99b45fc9000bc1bfc3&quot;, &quot;label&quot;: &quot;Contact Information&quot; }, &quot;homepage&quot;: null, &quot;taxId&quot;: null, &quot;rating&quot;: null, &quot;notes&quot;: null, &quot;lastMeeting&quot;: null, &quot;lastUpdate&quot;: 1485802380000 } } ] } History in entity # GET /data/{entityName}/history Returns the history logs for all records in an entity, which needs to have history logs enabled.
Request # GET /data/{entityName}/history &gt; Accept: application/json &gt; token: token Parameter Required Description entityName Yes Name of the entity the record belongs to. eventTypes No Allows to filter by some specific type of events. You can select many separating them by commas. Possible values are: - 'USER_RECORD_CREATED',
- 'USER_RECORD_CHANGED',
- 'USER_RECORD_DELETED', - 'USER_ACTION_PERFORMED', - 'SCRIPT_RECORD_CREATED', - 'SCRIPT_RECORD_CHANGED', - 'SCRIPT_RECORD_DELETED', - 'SCRIPT_ACTION_PERFORMED', - 'SYSTEM_CASCADE_UPDATE', and - 'SYSTEM_REFACTORING'. to No Allows to filter logs by timestamp. This is the maximum date and you should pass the number of milliseconds since Epoch. from No Allows to filter logs by timestamp. This is the minimum date and you should pass the number of milliseconds since Epoch. _size No The number of history records to fetch. Always the latests logs will be retrieved. _offset No Specifies an ID of a history log to start fetching logs from. This is to allow pagination. Response # The list of history logs for that record, sorted from the newest to the oldest ones.
GET /data/{entityName}/history &lt; Content-Type: application/json { &quot;total&quot;: 3, &quot;offset&quot;: &quot;588f8ba7b45fc9000bc1bfce&quot;, &quot;items&quot;: [ { &quot;id&quot;: &quot;588f9757b45fc9000bc1bfe1&quot;, &quot;entityId&quot;: &quot;57fce228e4b0f6600fdfb836&quot;, &quot;entityName&quot;: &quot;companies&quot;, &quot;entityVersion&quot;: 57, &quot;recordId&quot;: &quot;588f9757b45fc9000bc1bfe0&quot;, &quot;recordName&quot;: &quot;test2&quot;, &quot;user&quot;: &quot;dgaviola@slingr.io&quot;, &quot;timestamp&quot;: 1485805399966, &quot;ip&quot;: &quot;::ffff:10.240.0.11&quot;, &quot;eventType&quot;: &quot;USER_RECORD_CREATED&quot;, &quot;eventCategory&quot;: &quot;USER&quot;, &quot;contextPath&quot;: &quot;entities.companies.create&quot;, &quot;recordDeleted&quot;: null, &quot;deletionDate&quot;: null, &quot;oldRecord&quot;: {}, &quot;newRecord&quot;: { &quot;name&quot;: &quot;test2&quot;, &quot;state&quot;: &quot;active&quot;, &quot;type&quot;: &quot;c&quot;, &quot;color&quot;: &quot;#e1e1e1&quot;, &quot;numberOfEmployees&quot;: null, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;phoneNumber&quot;: null, &quot;email&quot;: null, &quot;id&quot;: &quot;588f9757b45fc9000bc1bfdf&quot;, &quot;nestedFieldLabel&quot;: &quot;Contact Information&quot;, &quot;id&quot;: &quot;588f9757b45fc9000bc1bfdf&quot;, &quot;label&quot;: &quot;Contact Information&quot; }, &quot;homepage&quot;: null, &quot;taxId&quot;: null, &quot;rating&quot;: null, &quot;notes&quot;: null, &quot;lastMeeting&quot;: null, &quot;lastUpdate&quot;: 1485805380000 } }, { &quot;id&quot;: &quot;588f8ba7b45fc9000bc1bfce&quot;, &quot;entityId&quot;: &quot;57fce228e4b0f6600fdfb836&quot;, &quot;entityName&quot;: &quot;companies&quot;, &quot;entityVersion&quot;: 57, &quot;recordId&quot;: &quot;588f8b99b45fc9000bc1bfc4&quot;, &quot;recordName&quot;: &quot;test1&quot;, &quot;user&quot;: &quot;dgaviola@slingr.io&quot;, &quot;timestamp&quot;: 1485802407010, &quot;ip&quot;: &quot;::ffff:10.240.0.15&quot;, &quot;eventType&quot;: &quot;USER_RECORD_CHANGED&quot;, &quot;eventCategory&quot;: &quot;USER&quot;, &quot;contextPath&quot;: &quot;entities.companies.update&quot;, &quot;recordDeleted&quot;: null, &quot;deletionDate&quot;: null, &quot;oldRecord&quot;: { &quot;type&quot;: { &quot;json&quot;: &quot;a&quot;, &quot;text&quot;: &quot;{type:a}&quot; }, &quot;addresses&quot;: { &quot;json&quot;: null, &quot;text&quot;: &quot;{}&quot; } }, &quot;newRecord&quot;: { &quot;type&quot;: { &quot;json&quot;: &quot;b&quot;, &quot;text&quot;: &quot;{type:b}&quot; }, &quot;addresses&quot;: { &quot;json&quot;: null, &quot;text&quot;: &quot;{}&quot; } } } ] } Path Description total Total number of history logs for the record. offset ID of the latest history log; include it as the _offset parameter for pagination to retrieve subsequent records. items History logs. Posible errors # Error code HTTP Status Code Description badRequest 400 Invalid query provided. forbidden 403 Insufficient permissions to view the history of records for the entity. notFound 404 Entity name does not exist. Samples # // gets the last two history logs in entity 'companies' GET /data/companies/history?_size=2 &gt; Accept: application/json &gt; token: token GET /data/companies/history?_size=2 &lt; Content-Type: application/json { &quot;total&quot;: 3, &quot;offset&quot;: &quot;588f8ba7b45fc9000bc1bfce&quot;, &quot;items&quot;: [ { &quot;id&quot;: &quot;588f9757b45fc9000bc1bfe1&quot;, &quot;entityId&quot;: &quot;57fce228e4b0f6600fdfb836&quot;, &quot;entityName&quot;: &quot;companies&quot;, &quot;entityVersion&quot;: 57, &quot;recordId&quot;: &quot;588f9757b45fc9000bc1bfe0&quot;, &quot;recordName&quot;: &quot;test2&quot;, &quot;user&quot;: &quot;dgaviola@slingr.io&quot;, &quot;timestamp&quot;: 1485805399966, &quot;ip&quot;: &quot;::ffff:10.240.0.11&quot;, &quot;eventType&quot;: &quot;USER_RECORD_CREATED&quot;, &quot;eventCategory&quot;: &quot;USER&quot;, &quot;contextPath&quot;: &quot;entities.companies.create&quot;, &quot;recordDeleted&quot;: null, &quot;deletionDate&quot;: null, &quot;oldRecord&quot;: {}, &quot;newRecord&quot;: { &quot;name&quot;: &quot;test2&quot;, &quot;state&quot;: &quot;active&quot;, &quot;type&quot;: &quot;c&quot;, &quot;color&quot;: &quot;#e1e1e1&quot;, &quot;numberOfEmployees&quot;: null, &quot;isCustomer&quot;: false, &quot;contactInformation&quot;: { &quot;phoneNumber&quot;: null, &quot;email&quot;: null, &quot;id&quot;: &quot;588f9757b45fc9000bc1bfdf&quot;, &quot;nestedFieldLabel&quot;: &quot;Contact Information&quot;, &quot;id&quot;: &quot;588f9757b45fc9000bc1bfdf&quot;, &quot;label&quot;: &quot;Contact Information&quot; }, &quot;homepage&quot;: null, &quot;taxId&quot;: null, &quot;rating&quot;: null, &quot;notes&quot;: null, &quot;lastMeeting&quot;: null, &quot;lastUpdate&quot;: 1485805380000 } }, { &quot;id&quot;: &quot;588f8ba7b45fc9000bc1bfce&quot;, &quot;entityId&quot;: &quot;57fce228e4b0f6600fdfb836&quot;, &quot;entityName&quot;: &quot;companies&quot;, &quot;entityVersion&quot;: 57, &quot;recordId&quot;: &quot;588f8b99b45fc9000bc1bfc4&quot;, &quot;recordName&quot;: &quot;test1&quot;, &quot;user&quot;: &quot;dgaviola@slingr.io&quot;, &quot;timestamp&quot;: 1485802407010, &quot;ip&quot;: &quot;::ffff:10.240.0.15&quot;, &quot;eventType&quot;: &quot;USER_RECORD_CHANGED&quot;, &quot;eventCategory&quot;: &quot;USER&quot;, &quot;contextPath&quot;: &quot;entities.companies.update&quot;, &quot;recordDeleted&quot;: null, &quot;deletionDate&quot;: null, &quot;oldRecord&quot;: { &quot;type&quot;: { &quot;json&quot;: &quot;a&quot;, &quot;text&quot;: &quot;{type:a}&quot; }, &quot;addresses&quot;: { &quot;json&quot;: null, &quot;text&quot;: &quot;{}&quot; } }, &quot;newRecord&quot;: { &quot;type&quot;: { &quot;json&quot;: &quot;b&quot;, &quot;text&quot;: &quot;{type:b}&quot; }, &quot;addresses&quot;: { &quot;json&quot;: null, &quot;text&quot;: &quot;{}&quot; } } } ] } Files handling # Slingr apps offer the capability to store various types of files that can later be downloaded, shared, or linked to fields within records.
When you need to reference a file within a record using a file field, it&rsquo;s a typical practice to upload the file first. Once you obtain the unique ID of the uploaded file, you can then set it as the value of the corresponding file field in your record.
It&rsquo;s important to note that if a file is not referenced by any record, it will be automatically deleted after a few hours. Therefore, it&rsquo;s advisable to upload files only if you intend to link them to records within your app. Uploading files that are not used within your app is unnecessary and may result in their deletion.
Uploading files # POST /files This function allows you to upload a file to your app. The uploaded file will be stored temporarily until it is referenced by a record. If no record references the file within 12 hours, it will be automatically removed.
Request # To upload a file, you must use a multi-part request. This method supports the uploading of files in any format.
POST /files &gt; Content-Type: multipart/form-data &gt; Accept: application/json &gt; token: token Response # The metadata of the uploaded file.
POST /files &lt; Content-Type: application/json { &quot;fileId&quot;: &quot;588f9f1eb45fc9000bc1c010&quot;, &quot;fileLink&quot;: &quot;/files/588f9f1eb45fc9000bc1c010&quot; } Path Description fileId The ID of the file. You can use this ID to reference the file from file fields in records. Samples # // uploads a file POST /files &gt; Content-Type: multipart/form-data &gt; Accept: application/json &gt; token: token test file in multi-part POST /files &lt; Content-Type: application/json { &quot;fileId&quot;: &quot;588f9f1eb45fc9000bc1c010&quot;, &quot;fileLink&quot;: &quot;/files/588f9f1eb45fc9000bc1c010&quot; } Downloading files # GET /files/{id} Downloads a file. This service is only available for developer and system users.
Request # GET /files/{id} &gt; token: &gt; : token Parameter Required Description id yes The ID of the file to download. Response # Returns the file to download.
GET /files/{id} &gt; Content-Type: application/force-download &gt; Content-Disposition: attachment; filename=file.ext //the content of the file Possible errors # Error code HTTP Status Code Description notFound 404 The file does not exist. Samples # // fetches a file GET /files/588f9f1eb45fc9000bc1c010 &gt; token: &gt; : token GET /files/588f9f1eb45fc9000bc1c010 &gt; Content-Type: application/force-download &gt; Content-Disposition: attachment; filename=file.ext // this is the content of the file Downloading record files # GET /data/{entityName}/{recordId}/files/{fileId} Downloads a file that belongs to a specific record. User permissions check is performed.
Request # GET /data/{entityName}/{recordId}/files/{fileId} &gt; Accept: application/json &gt; token: token Parameter Required Description recordId yes The ID of the record to fetch the file. fileId yes The ID of the file to be retrieved. Response # Returns the record file to download.
GET /data/{entityName}/{recordId}/files/{fileId} &gt; Content-Type: application/force-download &gt; Content-Disposition: attachment; filename=file.ext // the content of the file Possible errors # Error code HTTP Status Code Description notFound 404 The entity or record or file can no be found. forbidden 403 Provided token does not have permissions to access specified file. Samples # // fetches a file that belongs to a record GET /data/companies/57fd2d65e4b0ce322b0c8665/files/588fa383b45fc9000bc1c014 &gt; Accept: application/json &gt; token: token GET /data/companies/57fd2d65e4b0ce322b0c8665/files/588fa383b45fc9000bc1c014 &gt; Content-Type: application/force-download &gt; Content-Disposition: attachment; filename=file.ext // this is the content of the file Sharing files # PUT /files/{id}/share Shares a file through a public link. The link will be valid for an hour.
Request # PUT /files/{id}/share &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token Parameter Required Default Description ttl no 3600000 Time to expire in milliseconds. Response # The public link to download the file. This link won’t require any permission.
PUT /files/{id}/share &lt; Content-Type: application/json { &quot;sharedFileId&quot;: &quot;588fa383b45fc9000bc1c014&quot;, &quot;sharedFileLink&quot;: &quot;/files/shared/588fa383b45fc9000bc1c014&quot; } Path Description sharedFileId This is the ID of the shared file. sharedFileLink The link to download the file. You should prepend the API endpoint. Samples # //shares a file which will expire in one minute PUT /files/588f9f1eb45fc9000bc1c010/share?ttl=60000 &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token PUT /files/588f9f1eb45fc9000bc1c010/share?ttl=60000 &lt; Content-Type: application/json { &quot;sharedFileId&quot;: &quot;588fa383b45fc9000bc1c014&quot;, &quot;sharedFileLink&quot;: &quot;/files/shared/588fa383b45fc9000bc1c014&quot; } Fetch shared file # Sharing files # GET /files/shared/{id} Downloads a shared file.
Request # GET /files/shared/{id} &gt; Accept: application/json &gt; token: token Parameter Required Description id yes The ID of the shared file to download. Response # Returns the shared file to download.
GET /files/shared/{id} &gt; Content-Type: application/force-download &gt; Content-Disposition: attachment; filename=file.ext //the content of the file Possible errors # Error code HTTP Status Code Description notFound 404 The shared file doesn’t exist. Samples # //fetches a shared file GET /files/shared/588fa383b45fc9000bc1c014 &gt; Accept: application/json &gt; token: token GET /files/shared/588fa383b45fc9000bc1c014 &gt; Content-Type: application/force-download &gt; Content-Disposition: attachment; filename=file.ext //this is the content of the file Monitoring and troubleshooting # Logs # Logs allow to know what&rsquo;s going on in the app. The structure of a log is this one:
{ &quot;id&quot;: &quot;57fce0bfe4b0f6600fdfb82c&quot;, &quot;type&quot;: &quot;APP&quot;, &quot;subType&quot;: null, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;PUT /api/metadata/clearCache&quot;, &quot;userEmail&quot;: &quot;system@docs.slingrs.io&quot;, &quot;adminUserEmail&quot;: null, &quot;timestamp&quot;: 1476190399791, &quot;ip&quot;: &quot;10.64.2.3&quot;, &quot;additionalInfo&quot;: {} } Path Description id ID of the log. type Type of log, with possible options:
- 'APP' (generated by the app runtime), - 'ENDPOINT' (generated by an endpoint),
- 'EXTERNAL&rsquo; (generated by a special call in the REST API to save logs). subType Sub-type of the log based on the type. Currently, only &lsquo;APP&rsquo; type has sub-types:
- 'LOGIN', - 'REST_API_RECORD_CREATED',
- 'REST_API_RECORD_READ',
- 'REST_API_RECORD_UPDATED',
- 'REST_API_RECORD_DELETED',
- 'REST_API_ACTION_EXECUTED',
- 'SCRIPT',
- 'EVENT_ARRIVED',
- 'CONFIG_SCRIPT_ARRIVED',
- 'FUNCTION_CALLED'. level Log level, which could be 'INFO', 'WARN', or 'ERROR'. message The log message. userEmail Email of the current user when the log was generated; it could be the system user. adminUserEmail If the user is being impersonated, this is the email of the admin user. timestamp Timestamp when the log was generated, in milliseconds since Epoch. ip IP address associated with the log. additionalInfo This field may contain additional information that could be useful when troubleshooting issues. Note that it should not be used for automating processes as its content may change without notice. Get logs # GET /status/logs Query logs from the app.
Keep in mind that logs rotate and when the maximum size of logs is reached older ones are lost.
Request # GET /status/logs &gt; Accept: application/json &gt; token: token Parameter Required Default Description userEmail No - Allows filtering by user email using partial match. period No - Allows filtering by a time span, e.g., &lsquo;3h 30m&rsquo; for logs in the last 3 hours and 30 minutes. Supports time duration formats and &rsquo;today&rsquo; or &lsquo;yesterday&rsquo;. If specified, &lsquo;from&rsquo; and &rsquo;to&rsquo; parameters are discarded. from No - The minimum timestamp in milliseconds since Epoch for filtering logs. to No - The maximum timestamp in milliseconds since Epoch for filtering logs. level No - Specifies the log levels to find, separated by commas. message No - Allows filtering by partial search of log messages. _size No 200 Sets the maximum number of logs to retrieve. _offset No - Specifies the offset to start retrieving logs. Obtained from previous queries for pagination. Response # A list of logs in JSON format.
GET /status/logs &lt; Content-Type: application/json { &quot;total&quot;: 151 &quot;items&quot;: [ { &quot;id&quot;: &quot;58907c10b45fc9000bc1c020&quot;, &quot;type&quot;: &quot;APP&quot;, &quot;subType&quot;: &quot;LOGIN&quot;, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;POST /login&quot;, &quot;userEmail&quot;: &quot;dgaviola@slingr.io&quot;, &quot;adminUserEmail&quot;: null, &quot;timestamp&quot;: 1485863952895, &quot;ip&quot;: null }, { &quot;id&quot;: &quot;58907c1bb45fc9000bc1c023&quot;, &quot;type&quot;: &quot;APP&quot;, &quot;subType&quot;: null, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;GET /api/users/57fce0c3e4b0ce322b0c06b2?appsVersion=true&quot;, &quot;userEmail&quot;: &quot;dgaviola@slingr.io&quot;, &quot;adminUserEmail&quot;: null, &quot;timestamp&quot;: 1485863963701, &quot;ip&quot;: &quot;::ffff:10.240.0.11&quot; }, { &quot;id&quot;: &quot;589085b0b45fc9000bc1c02f&quot;, &quot;type&quot;: &quot;APP&quot;, &quot;subType&quot;: null, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Validation exceptions on record [test]. Error: [file: Content type is required when uploading a file and must be a string]&quot;, &quot;userEmail&quot;: &quot;dgaviola@slingr.io&quot;, &quot;adminUserEmail&quot;: null, &quot;timestamp&quot;: 1485866416124, &quot;ip&quot;: null, &quot;additionalInfo&quot;: { &quot;recordLabel&quot;: &quot;test&quot;, &quot;errors&quot;: [ { &quot;code&quot;: &quot;INVALID&quot;, &quot;field&quot;: &quot;file&quot;, &quot;message&quot;: &quot;Content type is required when uploading a file and must be a string&quot; } ] } }, { &quot;id&quot;: &quot;589085bdb45fc9000bc1c030&quot;, &quot;type&quot;: &quot;APP&quot;, &quot;subType&quot;: &quot;REST_API_RECORD_UPDATED&quot;, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;PUT /api/data/files/585aea800d29d300072484a8&quot;, &quot;userEmail&quot;: &quot;dgaviola@slingr.io&quot;, &quot;adminUserEmail&quot;: null, &quot;timestamp&quot;: 1485866429630, &quot;ip&quot;: &quot;::ffff:10.240.0.15&quot; }, { &quot;id&quot;: &quot;589085bfb45fc9000bc1c032&quot;, &quot;type&quot;: &quot;APP&quot;, &quot;subType&quot;: null, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Data record of type [files] with label [test] was changed successfully&quot;, &quot;userEmail&quot;: &quot;dgaviola@slingr.io&quot;, &quot;adminUserEmail&quot;: null, &quot;timestamp&quot;: 1485866431823, &quot;ip&quot;: null }, ] } Path Description total Total number of logs matched by the query. offset Offset to use when retrieving more logs. items Logs found. Possible errors # Error code HTTP Status Code Description forbidden 403 If you try to query logs with a user who is not a developer. Samples # //finds two logs for yesterday for one specific user GET /status/logs?period=yesterday&amp;userEmail=test@slingr.io&amp;_size=2 &gt; Accept: application/json &gt; token: token GET /status/logs?period=yesterday&amp;userEmail=test@slingr.io&amp;_size=2 &lt; Content-Type: application/json { &quot;items&quot;: [ { &quot;id&quot;: &quot;58907c10b45fc9000bc1c020&quot;, &quot;type&quot;: &quot;APP&quot;, &quot;subType&quot;: &quot;LOGIN&quot;, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;POST /login&quot;, &quot;userEmail&quot;: &quot;test@slingr.io&quot;, &quot;adminUserEmail&quot;: null, &quot;timestamp&quot;: 1485863952895, &quot;ip&quot;: null }, { &quot;id&quot;: &quot;58907c19b45fc9000bc1c021&quot;, &quot;type&quot;: &quot;APP&quot;, &quot;subType&quot;: null, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;GET /api/users/current&quot;, &quot;userEmail&quot;: &quot;test@slingr.io&quot;, &quot;adminUserEmail&quot;: null, &quot;timestamp&quot;: 1485863961326, &quot;ip&quot;: &quot;::ffff:10.240.0.16&quot; } ], &quot;total&quot;: 151 } Post logs # POST /status/logs Creates a log. You only need to send the message and the level of log. Other fields will be calculated automatically. An optional additionalInfo object can be send to add extra fields.
Request # POST /status/logs &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;This is a test log&quot;, &quot;additionalInfo&quot;: { &quot;test&quot;: &quot;Additional info property&quot; } } Response # The created log in JSON format.
POST /status/logs &lt; Content-Type: application/json { &quot;id&quot;: &quot;589085bdb45fc9000bc1c030&quot;, &quot;type&quot;: &quot;EXTERNAL&quot;, &quot;subType&quot;: null, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;This is a test log&quot;, &quot;userEmail&quot;: &quot;test@slingr.io&quot;, &quot;adminUserEmail&quot;: null, &quot;timestamp&quot;: 1485866429630, &quot;ip&quot;: null, &quot;additionalInfo&quot;: { &quot;test&quot;: &quot;Additional info property&quot; } } Possible errors # Error code HTTP Status Code Description validationErrors 400 If there are validation errors. When this happens you will get the details of the errors in the body:
{
&ldquo;code&rdquo;: &ldquo;validationErrors&rdquo;, &ldquo;message&rdquo;: &ldquo;There are validation errors&rdquo;,
&ldquo;errors&rdquo;: [
{
&ldquo;field&rdquo;: &ldquo;message&rdquo;,
&ldquo;fieldLabel&rdquo;: null,
&ldquo;code&rdquo;: &ldquo;required&rdquo;,
&ldquo;message&rdquo;: &ldquo;Message cannot be empty&rdquo;,
&ldquo;additionalInfo&rdquo;: null
}
]
} forbidden 403 If you try to create a log with a user who is not a developer. Samples # //creates a new log POST /status/logs &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token { &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;This is a test log&quot;, &quot;additionalInfo&quot;: { &quot;test&quot;: &quot;Additional info property&quot; } } POST /status/logs &lt; Content-Type: application/json { &quot;id&quot;: &quot;589085bdb45fc9000bc1c030&quot;, &quot;type&quot;: &quot;EXTERNAL&quot;, &quot;subType&quot;: null, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;This is a test log&quot;, &quot;userEmail&quot;: &quot;test@slingr.io&quot;, &quot;adminUserEmail&quot;: null, &quot;timestamp&quot;: 1485866429630, &quot;ip&quot;: &quot;::ffff:10.240.0.15&quot;, &quot;additionalInfo&quot;: { &quot;test&quot;: &quot;Additional info property&quot; } } Jobs # The API for jobs provides the capability to check various aspects of a job, including its status, progress, logs, and additional information. This helps you gain a comprehensive understanding of the job&rsquo;s current state and execution.
This is the general job structure:
{ &quot;id&quot;: &quot;588a02c13b063a0007605032&quot;, &quot;label&quot;: &quot;Executing action countEmployees on entity companies&quot;, &quot;type&quot;: &quot;EXECUTE_ACTION&quot;, &quot;runBy&quot;: { &quot;id&quot;: &quot;57fce0c3e4b0ce322b0c06b2&quot;, &quot;fullName&quot;: &quot;Diego Gaviola&quot; }, &quot;parentJob&quot;: null, &quot;rootJob&quot;: null, &quot;createDate&quot;: 1485439681643, &quot;startDate&quot;: 1485439681652, &quot;endDate&quot;: 1485439681807, &quot;status&quot;: &quot;FINISHED&quot;, &quot;hasErrors&quot;: false, &quot;progress&quot;: 100, &quot;recordsCount&quot;: 0, &quot;recordsProcessed&quot;: 0, &quot;childrenJobsCount&quot;: 0, &quot;childrenJobsProcessed&quot;: 0, &quot;stoppable&quot;: true, &quot;lowPriority&quot;: false, &quot;data&quot;: {} &quot;results&quot;: {} } Field Description id Unique identifier for the job. label Name of the job, providing a simple description of its purpose. Be aware that this description may change without notice and should not be used for critical decision-making in your code. type The type of job, which can be one of the following supported types: - IMPORT_RECORDS, - EXPORT_RECORDS, - EXECUTE_ACTION, - DELETE_RECORDS, - EXECUTE_LISTENER, - IMPORT_USERS, - EXPORT_USERS, - STOP_APP, - START_APP, - DEPLOY_ENDPOINT, - UNDEPLOY_ENDPOINT.
Other job types are considered system jobs and should not be relied upon, as they may change or be removed. runBy A map containing the id and fullName of the user who triggered the job. parentJob A map containing the id and label of the parent job. If the job is not a child of another job, this field will be null, indicating it is a root job. rootJob A map containing the id and label of the root job. A root job is one that does not have a parent job. If this field is null, it means the job is a root job. createDate The timestamp in milliseconds when the job was created. startDate The timestamp when the job execution started. It can be null if the job has not yet started. endDate The timestamp when the job execution finished. It can be null if the job has not finished. status The current status of the job, which can be one of the following: PENDING, RUNNING, FINISHED, STOPPING, STOPPED, CANCELED. hasErrors If true, indicates that there was at least one error during the job&rsquo;s execution. You should review the logs and results for details. progress A number from 0 to 100 indicating the progress of the job. Note that some jobs may transition directly from 0 to 100 if there is no intermediate progress information. recordsCount If the job involves working with records, this field indicates the number of records involved. recordsProcessed If the job involves working with records, this field indicates the number of records that have been processed. childrenJobsCount The count of children jobs created during the execution of the job. It starts as 0 and may increase over time as more children jobs are created. childrenJobsProcessed The number of children jobs that have finished execution. stoppable If true, the job can be stopped; otherwise, you must wait for its completion (unless it&rsquo;s still pending). lowPriority If true, the job will be executed only when there are few other jobs running. data The content of this field depends on the job and contains additional parameters.
Start AppFieldDescriptionpushChangesIndicates whether changes will be automatically pushed when starting the application. Set to true if changes will be pushed; otherwise, it&rsquo;s false or empty.wakingUpIndicates whether the application was in a sleeping state and is now in the process of waking up. Set to true if the app is waking up; otherwise, it&rsquo;s false.Import RecordsFieldDescriptionfileNameThe name of the file to be imported.entityNameThe name of the entity where records will be imported.Export RecordsFieldDescriptionentityNameThe name of the entity from which records will be exported.Delete RecordsFieldDescriptionentityNameThe name of the entity from which records will be deleted.Execute ActionFieldDescriptionentityNameThe name of the entity to which the action belongs.actionNameThe name of the action to be executed.Execute ListenerFieldDescriptionlistenerNameThe name of the listener to execute.Import UsersFieldDescriptionfileNameThe name of the file to be imported.notifyUsersIndicates whether people will be notified by email when users are created. Set to true if notifications will be sent; otherwise, it&rsquo;s false.Deploy EndpointPathDescriptionendpointNameThe name of the endpoint to deploy.Undeploy EndpointPathDescriptionendpointNameThe name of the endpoint to undeploy.
results The content of this field depends on the job. Here you will find information about the results of executing the job.
Import RecordsPathDescriptionrowsImportedThe number of rows that were imported successfully.rowsWithErrorsThe number of rows that couldn&rsquo;t be imported due to errors.Export RecordsPathDescriptionfileLinkURL to download the CSV file with the exported records. You will need to send the token in the headers to download it.fileIdThe ID of the file that was generated.recordsExportedThe number of records that were exported.Delete Records
The result will be a map like this one:
{
&ldquo;results&rdquo;: {
&ldquo;id1&rdquo;: {
&ldquo;status&rdquo;: &ldquo;ok&rdquo;,
&ldquo;response&rdquo;: &ldquo;response from action&rdquo;
},
&ldquo;id2&rdquo;: {
&ldquo;status&rdquo;: &ldquo;error&rdquo;,
&ldquo;errorMessage&rdquo;: &ldquo;error message&rdquo;
}
}
}
status will indicate if the delete process was executed successfully over that record (ok) or if there were errors (error). The field response will be available only if the action is configured to return the response in the results; otherwise it won&rsquo;t be there.
One important thing to keep in mind is that the maximum number of responses in this map will be 1,000. If you execute the delete process over more than 1,000 records, you might not be able to collect the response for each one.Execute ActionThe results of this job depend on the type of action. If the action is of type One record, the result will be a map like this one:
{
&ldquo;results&rdquo;: {
&ldquo;id1&rdquo;: {
&ldquo;status&rdquo;: &ldquo;ok&rdquo;,
&ldquo;response&rdquo;: &ldquo;response from action&rdquo;
},
&ldquo;id2&rdquo;: {
&ldquo;status&rdquo;: &ldquo;error&rdquo;,
&ldquo;errorMessage&rdquo;: &ldquo;error message&rdquo;
}
}
}
status will indicate if the action was executed successfully over that record (ok) or if there were errors (error). The field response will be available only if the action is configured to return the response in the results; otherwise it won&rsquo;t be there. The field errorMessage will be present when there is an error, providing some insight into the problem. One important thing to keep in mind is that the maximum number of responses in this map will be 1,000. If you execute the action over more than 1,000 records, you might not be able to collect the response for each one.
If the action is of type Many records, you will only get a map with fields status and response:
{
&ldquo;results&rdquo;: {
&ldquo;status&rdquo;: &ldquo;ok&rdquo;,
&ldquo;response&rdquo;: &ldquo;response from action&rdquo;
}
}Import UsersPathDescriptionfileLinkURL to download the CSV file with the exported users. You will need to send the token in the headers to download it.Export UsersPathDescriptionfileLinkURL to download the CSV file with the exported users. You will need to send the token in the headers to download it.fileIdThe ID of the file that was generated.usersExportedThe number of users that were exported.
Get one job # GET /status/jobs/{id} Gets one job by ID.
Request # GET /status/jobs/{id} &gt; Accept: application/json &gt; token: token Parameter Required Description id yes The ID of the job. Response # The job in JSON format.
GET /status/jobs/{id} &lt; Content-Type: application/json { &quot;id&quot;: &quot;588a02c13b063a0007605032&quot;, &quot;label&quot;: &quot;Execute action countEmployees from entity companies&quot;, &quot;type&quot;: &quot;EXECUTE_ACTION&quot;, &quot;runBy&quot;: { &quot;id&quot;: &quot;57fce0c3e4b0ce322b0c06b2&quot;, &quot;fullName&quot;: &quot;Diego Gaviola&quot; }, &quot;parentJob&quot;: null, &quot;rootJob&quot;: null, &quot;createDate&quot;: 1485439681643, &quot;startDate&quot;: 1485439681652, &quot;endDate&quot;: 1485439681807, &quot;status&quot;: &quot;FINISHED&quot;, &quot;hasErrors&quot;: false, &quot;progress&quot;: 100, &quot;recordsCount&quot;: 0, &quot;recordsProcessed&quot;: 0, &quot;childrenJobsCount&quot;: 0, &quot;childrenJobsProcessed&quot;: 0, &quot;stoppable&quot;: true, &quot;lowPriority&quot;: false } Possible errors # Error code HTTP Status Code Description notFound 404 The job doesn’t exist. Samples # // gets a job by ID GET /status/jobs/588a02c13b063a0007605032 &gt; Accept: application/json &gt; token: token GET /status/jobs/588a02c13b063a0007605032 &lt; Content-Type: application/json { &quot;id&quot;: &quot;588a02c13b063a0007605032&quot;, &quot;label&quot;: &quot;Execute action countEmployees from entity companies&quot;, &quot;type&quot;: &quot;EXECUTE_ACTION&quot;, &quot;runBy&quot;: { &quot;id&quot;: &quot;57fce0c3e4b0ce322b0c06b2&quot;, &quot;fullName&quot;: &quot;Diego Gaviola&quot; }, &quot;parentJob&quot;: null, &quot;rootJob&quot;: null, &quot;createDate&quot;: 1485439681643, &quot;startDate&quot;: 1485439681652, &quot;endDate&quot;: 1485439681807, &quot;status&quot;: &quot;FINISHED&quot;, &quot;hasErrors&quot;: false, &quot;progress&quot;: 100, &quot;recordsCount&quot;: 0, &quot;recordsProcessed&quot;: 0, &quot;childrenJobsCount&quot;: 0, &quot;childrenJobsProcessed&quot;: 0, &quot;stoppable&quot;: true, &quot;lowPriority&quot;: false } List jobs # GET /status/jobs Lists jobs in the app.
Request # GET /status/jobs &gt; Accept: application/json &gt; token: token Parameter Required Default Description type no The type of job(s) to filter. Possible values include: IMPORT_RECORDS, EXPORT_RECORDS, EXECUTE_ACTION, DELETE_RECORDS, EXECUTE_LISTENER, IMPORT_USERS, EXPORT_USERS, STOP_APP, START_APP, DEPLOY_ENDPOINT, UNDEPLOY_ENDPOINT.
Multiple types can be specified, separated by commas. status no The status of the job(s) to filter. Possible values include: PENDING, RUNNING, FINISHED, STOPPING, STOPPED, CANCELING, CANCELED.
Multiple statuses can be specified, separated by commas. hasErrors no Filter jobs based on whether they have errors. Use &ldquo;true&rdquo; to retrieve only jobs with errors or &ldquo;false&rdquo; to get jobs without errors. startFrom no Filter jobs by their start date, specifying the initial range limit. Can be used alone or in combination with startTo. startTo no Filter jobs by their start date, specifying the final range limit. Can be used alone or in combination with startFrom. endFrom no Filter jobs by their end date, specifying the initial range limit. Can be used alone or in combination with endTo. endTo no Filter jobs by their end date, specifying the final range limit. Can be used alone or in combination with endFrom. createFrom no Filter jobs by their creation date, specifying the initial range limit. Can be used alone or in combination with createTo. createTo no Filter jobs by their creation date, specifying the final range limit. Can be used alone or in combination with createFrom. _size no 20 The maximum number of jobs to retrieve in a single query. _offset no The offset to start retrieving jobs. The query will return the appropriate offset for subsequent requests to retrieve more jobs. Response # A list of jobs in JSON format.
GET /status/jobs &lt; Content-Type: application/json { &quot;total&quot;: 54, &quot;offset&quot;: &quot;5890d8ddb45fc9000bc1c2cf&quot;, &quot;items&quot;: [ { &quot;id&quot;: &quot;5890d8deb45fc9000bc1c2d3&quot;, ... }, { &quot;id&quot;: &quot;5890d8deb45fc9000bc1c2d1&quot;, ... }, { &quot;id&quot;: &quot;5890d8ddb45fc9000bc1c2cf&quot;, ... ] } Path Description total The total number of jobs matched by the query. offset The offset to use to get more jobs. items The jobs found. Samples # // finds up to three finished jobs GET /status/jobs?status=FINISHED&amp;_size=3 &gt; Accept: application/json &gt; token: token GET /status/jobs?status=FINISHED&amp;_size=3 &lt; Content-Type: application/json { &quot;total&quot;: 50, &quot;offset&quot;: &quot;5890d8ddb45fc9000bc1c2cf&quot;, &quot;items&quot;: [ { &quot;id&quot;: &quot;5890d8deb45fc9000bc1c2d3&quot;, ... }, { &quot;id&quot;: &quot;5890d8deb45fc9000bc1c2d1&quot;, ... }, { &quot;id&quot;: &quot;5890d8ddb45fc9000bc1c2cf&quot;, ... ] } Get logs of a job # GET /status/jobs/{id}/logs Query logs from a job.
Request # GET /status/jobs/{id}/logs &gt; Accept: application/json &gt; token: token Parameter Required Default Description period no Filter logs by a time span. For example, you can use &ldquo;3h 30m&rdquo; to query logs from the last 3 hours and 30 minutes. You can also specify &quot;today&quot; or &quot;yesterday.&quot;
If specified, the &ldquo;from&rdquo; and &ldquo;to&rdquo; parameters will be ignored. The format is the same as used for time duration fields. from no The minimum timestamp in milliseconds since Epoch. to no The maximum timestamp in milliseconds since Epoch. level no Filter logs by log levels. Multiple levels can be specified, separated by commas. Possible values include INFO, WARN, and ERROR. message no Filter logs by searching for a partial message match. _size no 200 The maximum number of log entries to retrieve in a single query. _offset no The offset to start retrieving log entries. The query will return the appropriate offset for subsequent requests to retrieve more log entries. Response # A list of logs in JSON format.
GET /status/jobs/{id}/logs &lt; Content-Type: application/json { &quot;total&quot;: 3, &quot;items&quot;: [ { &quot;timestamp&quot;: 1485887710544, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Starting processing&quot; }, { &quot;timestamp&quot;: 1485887710546, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Cleaning up&quot; }, { &quot;timestamp&quot;: 1485887710704, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Process completed&quot; } ] } Path Description total The total number of logs matched by the query. offset The offset to use to get more logs. items The logs found, each containing three fields:
- timestamp: The timestamp when the log was created. - level: The level of the log, which could be INFO, WARN, or ERROR.
- message: The message in the logs. Possible errors # Error code HTTP Status Code Description notFound 404 The job doesn’t exist. Samples # // finds logs for one job GET /status/job/5890d8deb45fc9000bc1c2d3/logs &gt; Accept: application/json &gt; token: token GET /status/job/5890d8deb45fc9000bc1c2d3/logs &lt; Content-Type: application/json { &quot;total&quot;: 3, &quot;items&quot;: [ { &quot;timestamp&quot;: 1485887710544, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Starting processing&quot; }, { &quot;timestamp&quot;: 1485887710546, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Cleaning up&quot; }, { &quot;timestamp&quot;: 1485887710704, &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Process completed&quot; } ] } Stop job # PUT /status/jobs/{id}/stop This action allows you to stop a job. If the job was running, it might take some time to stop gracefully. During this time, the status will be set to &quot;STOPPING.&quot; Once the job has been successfully stopped in a graceful manner, the status will change to &quot;STOPPED.&quot;
It&rsquo;s important to note that jobs that have been stopped can be resumed.
Request # PUT /status/jobs/{id}/stop &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token Response # The job in JSON format.
PUT /status/jobs/{id}/stop &lt; Content-Type: application/json { &quot;id&quot;: &quot;588a02c13b063a0007605032&quot;, ... &quot;status&quot;: &quot;STOPPING&quot;, ... } Possible errors # Error Code HTTP Status Code Description badRequest 404 Indicates that the job cannot be stopped. This can happen if jobs of this type cannot be stopped or if the job is not a root job. forbidden 403 Signifies that you don&rsquo;t have the necessary permissions to stop this job. If you are not a developer, you can only stop jobs that you initiated. notFound 404 Indicates that the job was not found. Samples # stops a job PUT /status/jobs/588a02c13b063a0007605032/stop &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token PUT /status/jobs/588a02c13b063a0007605032/stop &lt; Content-Type: application/json { &quot;id&quot;: &quot;588a02c13b063a0007605032&quot;, ... &quot;status&quot;: &quot;STOPPING&quot;, ... } Force to stop job # PUT /status/jobs/{id}/forceStop When attempting to stop a job, the system will first try to stop it gracefully. However, if the job continues to run and you need to forcibly terminate it, you have the option to force stop it, which will immediately terminate the job.
It&rsquo;s important to keep in mind that forcibly stopping a job can lead to the interruption of the processing it was performing, potentially leaving data in an inconsistent or undesirable state. Therefore, it should only be used in exceptional cases where no other option is available.
Request # PUT /status/jobs/{id}/forceStop &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token Response # The job in JSON format.
PUT /status/jobs/{id}/forceStop &lt; Content-Type: application/json { &quot;id&quot;: &quot;588a02c13b063a0007605032&quot;, ... &quot;status&quot;: &quot;STOPPED&quot;, ... } Possible errors # Error Code HTTP Status Code Description badRequest 404 Indicates that the job cannot be stopped. This may occur if jobs of this type cannot be stopped, if it&rsquo;s not a root job, or if its status is different from STOPPING. forbidden 403 Signifies that you don&rsquo;t have the necessary permissions to stop this job. If you are not a developer, you can only stop jobs that you initiated. notFound 404 Indicates that the job was not found. Samples # // force to stop a job PUT /status/jobs/588a02c13b063a0007605032/forceStop &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token PUT /status/jobs/588a02c13b063a0007605032/forceStop &lt; Content-Type: application/json { &quot;id&quot;: &quot;588a02c13b063a0007605032&quot;, ... &quot;status&quot;: &quot;STOPPED&quot;, ... } Cancel job # PUT /status/jobs/{id}/cancel Cancels a job. Only jobs that are in STOPPED can be canceled.
It&rsquo;s important to note that jobs that have been canceled can be resumed.
Request # PUT /status/jobs/{id}/cancel &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token Response # The job in JSON format.
PUT /status/jobs/{id}/cancel &lt; Content-Type: application/json { &quot;id&quot;: &quot;588a02c13b063a0007605032&quot;, ... &quot;status&quot;: &quot;CANCELED&quot;, ... } Possible errors # Error Code HTTP Status Code Description badRequest 404 Indicates that the job cannot be canceled. This could be due to the job being in a bad status or not being a root job. forbidden 403 Signifies that you lack the necessary permissions to cancel this job. If you are not a developer, you can only cancel jobs that you initiated. notFound 404 Indicates that the job was not found. Samples # // cancels a job PUT /status/jobs/588a02c13b063a0007605032/cancel &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token PUT /status/jobs/588a02c13b063a0007605032/cancel &lt; Content-Type: application/json { &quot;id&quot;: &quot;588a02c13b063a0007605032&quot;, ... &quot;status&quot;: &quot;CANCELED&quot;, ... } Resume job # PUT /status/jobs/{id}/resume Resuming a job that has been stopped will allow it to continue execution from where it left off. However, if the job was not started when it was stopped, its status will be set to &quot;PENDING&quot; instead of &quot;RUNNING.&quot;
Request # PUT /status/jobs/{id}/resume &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token Response # The job in JSON format.
PUT /status/jobs/{id}/resume &lt; Content-Type: application/json { &quot;id&quot;: &quot;588a02c13b063a0007605032&quot;, ... &quot;status&quot;: &quot;RUNNING&quot;, ... } Possible errors # Error Code HTTP Status Code Description badRequest 404 Indicates that the job cannot be resumed. This may occur if the job is in a bad status or is not a root job. forbidden 403 Signifies that you lack the necessary permissions to resume this job. If you are not a developer, you can only resume jobs that you initiated. notFound 404 Indicates that the job was not found. Samples # // resumes a job PUT /status/jobs/588a02c13b063a0007605032/resume &gt; Content-Type: application/json &gt; Accept: application/json &gt; token: token PUT /status/jobs/588a02c13b063a0007605032/resume &lt; Content-Type: application/json { &quot;id&quot;: &quot;588a02c13b063a0007605032&quot;, ... &quot;status&quot;: &quot;RUNNING&quot;, ... } `}),e.add({id:156,href:"/dev-reference/rest-apis/apps-api-doc/",title:"Apps REST API documentation",description:`Developers who want to interact with your app&rsquo;s REST API need essential information about entities, fields, actions, permissions, and more. However, this critical information is typically locked within the app builder and inaccessible to external developers. To bridge this gap, Slingr offers a solution to auto-generate comprehensive REST API documentation, providing all the details required for seamless API interaction.
Understanding REST APIs # In your app builder, navigate to the Model &gt; REST API section to find a list of APIs associated with your app.`,content:`Developers who want to interact with your app&rsquo;s REST API need essential information about entities, fields, actions, permissions, and more. However, this critical information is typically locked within the app builder and inaccessible to external developers. To bridge this gap, Slingr offers a solution to auto-generate comprehensive REST API documentation, providing all the details required for seamless API interaction.
Understanding REST APIs # In your app builder, navigate to the Model &gt; REST API section to find a list of APIs associated with your app. While your app technically has one API based on your model, certain features may be restricted depending on the user&rsquo;s permissions. This section allows you to define the permissions for different types of API users you expect.
There will always be one API called Full API, which cannot be deleted. It serves as the API for developer users or individuals with comprehensive permissions. Additionally, you can create other APIs to specify the groups to which API users belong. These groups are instrumental in determining user permissions.
Once you configure a REST API and push changes, you can access the API&rsquo;s documentation at this URL:
https://{{site.slingr_domain}}/&lt;env&gt;/runtime/api/docs/&lt;api-name&gt; Please note that these REST APIs defined here serve the sole purpose of auto-generating documentation. Any user who doesn&rsquo;t belong to the specified groups can still use the API but won&rsquo;t have access to the documentation.
REST API Settings # When creating a new REST API, you must provide the following settings:
Label # A user-friendly, human-readable name for the REST API.
Name # The internal name of the REST API, used in the API documentation&rsquo;s URL. It should consist only of letters and numbers, with no special characters or spaces.
Groups # A list of groups that define the permissions for this REST API. Only the components accessible to these groups will be documented.
`}),e.add({id:157,href:"/dev-reference/embed-api/",title:"Embed API",description:"",content:""}),e.add({id:158,href:"/dev-reference/embed-api/embedded-views/",title:"Embedded views",description:`Using private tokens # If authentication is required, you need to obtain a token from the REST API and set it within the iframe that will embed the view.
Views can be embedded in external websites through iframes. To embed a view, you can use the following URL:
{app}.slingrs.io/{env}/runtime/#views/embed/{viewId} For entity views, you need to set the recordId parameter:
{app}.slingrs.io/{env}/runtime/#views/embed/{viewId}?recordId={recordId}\` When a page is loaded, it requires the token, which should be sent using window messages as follows:`,content:`Using private tokens # If authentication is required, you need to obtain a token from the REST API and set it within the iframe that will embed the view.
Views can be embedded in external websites through iframes. To embed a view, you can use the following URL:
{app}.slingrs.io/{env}/runtime/#views/embed/{viewId} For entity views, you need to set the recordId parameter:
{app}.slingrs.io/{env}/runtime/#views/embed/{viewId}?recordId={recordId}\` When a page is loaded, it requires the token, which should be sent using window messages as follows:
window.postMessage({ type: 'auth:login', token: 'XwY8XPh6sQUDLmuhzDcdJd6bSMuEAHo0' }, '*'); When the token expires, the page will request the token by sending a message for auth:requestLogin. You can listen for this message to process the login.
window.addEventListener('message', function (event) { if (typeof event.data === 'object' &amp;&amp; event.data.type == 'auth:requestLogin' &amp;&amp; event.data.token) { var token = 'XwY8XPh6sQUDLmuhzDcdJd6bSMuEAHo0'; // ...required when using the REST API window.postMessage({ type: 'auth:login', token: token }, '*'); } }); Sometimes, the postMessage should be sent to the proper embed container. Refer to the documentation of your web content system, such as Squarespace or Wix, for more details.
Using API tokens # In this case, authentication is not required. API tokens should already be generated, and they provide access to the REST API. For more information about API tokens, see here.
You can embed views with API tokens by setting up the URL like this:
{app}.slingrs.io/{env}/runtime/#views/embed/{viewId}?token={apiTokenKey}\` `}),e.add({id:159,href:"/dev-reference/monitoring/",title:"Monitoring",description:"",content:""}),e.add({id:160,href:"/dev-reference/monitoring/overview/",title:"Overview",description:`The App Monitor provides you with insights into the status and functionality of your app. With the App Monitor, you can perform the following actions:
Check the global status of your app Modify environment settings Manage and monitor background jobs View logs for your app Manage legacy services Access detailed information about your database Execute ad-hoc scripts in your environment Manage users Handle storage Explore metadata related to your app Monitor the REST API The App Monitor is accessible in all environments.`,content:`The App Monitor provides you with insights into the status and functionality of your app. With the App Monitor, you can perform the following actions:
Check the global status of your app Modify environment settings Manage and monitor background jobs View logs for your app Manage legacy services Access detailed information about your database Execute ad-hoc scripts in your environment Manage users Handle storage Explore metadata related to your app Monitor the REST API The App Monitor is accessible in all environments.
`}),e.add({id:161,href:"/dev-reference/monitoring/dashboard/",title:"Dashboard",description:`In the App Monitor&rsquo;s dashboard, you can quickly assess the status of your app. By default, it displays activity from the last hour, but you have the flexibility to adjust the time frame to cover a longer period.
Here, you&rsquo;ll find the following key metrics:
API Calls: This metric reflects the number of API calls made, serving as an essential indicator to identify any anomalies. A sudden drop or spike in API calls may indicate issues that require attention.`,content:`In the App Monitor&rsquo;s dashboard, you can quickly assess the status of your app. By default, it displays activity from the last hour, but you have the flexibility to adjust the time frame to cover a longer period.
Here, you&rsquo;ll find the following key metrics:
API Calls: This metric reflects the number of API calls made, serving as an essential indicator to identify any anomalies. A sudden drop or spike in API calls may indicate issues that require attention.
Response Time: This metric provides insight into your app&rsquo;s response time to API calls. If this value consistently increases and remains high, it may signal the need to scale your app by adding more instances to maintain an acceptable response time.
Jobs Queue: This metric measures the time jobs have spent waiting for execution. An increasing and consistently high value here may suggest the need to scale your app by adding more instances to process jobs efficiently.
Database: This metric offers a quick overview of the total database storage utilized. It&rsquo;s particularly valuable if you&rsquo;re approaching your storage limit and considering an upgrade.
Errors: This metric indicates the number of errors detected in the logs during the specified time frame.
Active Users: Here, you can find the count of active users within your app during the specified time period.
Storage: This metric shows the number of keys stored in your app&rsquo;s storage.
Integrations: In this section, you can assess the status of each of your legacy services, along with the number of events and functions processed and discarded. If you observe no activity in your legacy services, it may indicate underlying issues that require investigation.
`}),e.add({id:162,href:"/dev-reference/monitoring/environment-settings/",title:"Environment settings",description:`In the Environment settings section of the App Monitor, you have the capability to modify various environment settings that directly impact your app&rsquo;s behavior. These settings encompass:
Environment variables: Configure and manage environment-specific variables that influence the app&rsquo;s behavior.
UI settings: Customize the user interface settings to tailor the app&rsquo;s appearance and behavior to your preferences.
Logs and alerts: Fine-tune logging and alerting configurations to stay informed about critical events and issues within your app.`,content:`In the Environment settings section of the App Monitor, you have the capability to modify various environment settings that directly impact your app&rsquo;s behavior. These settings encompass:
Environment variables: Configure and manage environment-specific variables that influence the app&rsquo;s behavior.
UI settings: Customize the user interface settings to tailor the app&rsquo;s appearance and behavior to your preferences.
Logs and alerts: Fine-tune logging and alerting configurations to stay informed about critical events and issues within your app.
Localization: Adjust localization settings to provide a tailored experience for users in different regions and languages.
API Tokens: Manage API tokens that enable secure access to your app&rsquo;s resources.
When you make changes to these settings, they take immediate effect within your app. For instance, if you modify the app&rsquo;s theme, simply reloading the app will reflect the updated theme.
The only exception to this rule is when you make changes to environment variables that impact legacy services, such as when a variable is utilized in an legacy service&rsquo;s configuration. In such cases, if you alter the variable&rsquo;s value, you will be prompted to restart the affected legacy services. However, you can choose to postpone this action if you don&rsquo;t wish to restart them immediately.
`}),e.add({id:163,href:"/dev-reference/monitoring/background-jobs/",title:"Background jobs",description:`In the App Monitor&rsquo;s &ldquo;Jobs&rdquo; section, you can track the status and details of various jobs associated with your application. Jobs come in different types and are generated as a result of various operations within the app runtime. Some common triggers for background jobs include:
Executing an action in the background Receiving an event from an legacy service Exporting or importing records Within the App Monitor, you can monitor jobs responsible for these operations, view their statuses, progress, and access relevant logs.`,content:`In the App Monitor&rsquo;s &ldquo;Jobs&rdquo; section, you can track the status and details of various jobs associated with your application. Jobs come in different types and are generated as a result of various operations within the app runtime. Some common triggers for background jobs include:
Executing an action in the background Receiving an event from an legacy service Exporting or importing records Within the App Monitor, you can monitor jobs responsible for these operations, view their statuses, progress, and access relevant logs.
Here&rsquo;s the information available for each job:
Create date: Indicates when the job was created. Waiting: Shows the elapsed time between job creation and the start of execution. This value increases while the job is pending. Start date: Marks when the job&rsquo;s execution commenced. Duration: Reflects the time taken for the job to complete since its start date. This value continues to grow while the job is in progress. Status: Indicates the current status of the job, such as &quot;Pending,&quot; &quot;In Progress,&quot; or &quot;Finished.&quot; Errors: Flags the presence of errors during job execution, with detailed information available in the job&rsquo;s logs. Low priority: Marks jobs as low priority, impacting their execution when the app experiences heavy loads. Run by: Identifies the user who triggered the job; it may be empty for system jobs. Progress: Offers an estimate of the job&rsquo;s progress, although some jobs may not update this accurately. Children execution: Shows the progress of child jobs, if any exist. Note that additional child jobs might be created during execution, adjusting the overall progress. Operations on jobs # You can perform several operations on jobs by selecting the relevant jobs:
Stop: Attempts to gracefully halt a running job. After stopping, you can choose to resume it. Please note that certain jobs, such as those executing listeners, may not be stoppable mid-execution and will remain in a &quot;Stopping&quot; state until completion. System jobs may not have the option to stop.
Resume: Resumes the execution of a job in the &quot;Stopped&quot; state, continuing from where it left off.
Force Stop: Forces a job in the &quot;Stopping&quot; state to halt. Use this cautiously, as it may result in inconsistent data if no alternative exists.
Cancel: Discards a job in the &quot;Stopped&quot; state, making it unrecoverable.
Restart: Available for specific job types, this operation re-executes a &quot;Finished&quot; job if necessary.
Set low priority: Marks a job as low priority, scheduling it for execution during low app load periods.
Remove low priority: Removes the low priority flag, ensuring a job is executed as usual.
Logs # For each job, you can access logs specific to its execution. Log searching and filtering function similarly to app logs.
Children jobs # During a job&rsquo;s execution, it may trigger other jobs known as children jobs. These not only help maintain the clarity of the main jobs list but also influence job scheduling. The scheduler allocates execution time based on root jobs (those without parents) to prevent a single job with numerous children from blocking others.
System jobs # You can view system jobs by clicking the &ldquo;Show system jobs&rdquo; button in the secondary menu. System jobs are generated by the platform to perform essential tasks, such as data refactorings or automatic updates to relationship fields.
System jobs are typically not necessary to monitor but can be inspected when needed.
Statistics # In the &quot;Jobs &gt; Statistics&quot; section of the App Monitor, you can find valuable insights into job execution over time, including:
Number of creations: Indicates the total number of jobs created, useful for detecting anomalies in your app.
Average waiting time: Reflects the average duration a job waits before execution. An increase in this value suggests a performance issue, possibly requiring additional app instances.
Min waiting time: Displays the shortest waiting time among jobs before execution.
Max waiting time: Highlights the longest waiting time a job experienced before execution.
`}),e.add({id:164,href:"/dev-reference/monitoring/logs-and-alerts/",title:"Monitoring logs and alerts",description:`Access and manage logs from the App Monitor&rsquo;s &ldquo;Logs&rdquo; section to gain valuable insights into your app&rsquo;s activities. Logs are essential for diagnosing issues and identifying anomalies within your application.
In the logs, you&rsquo;ll find entries generated by both the system and those created using JavaScript API methods like sys.logs.info() or sys.logs.error().
Logs are organized from the oldest to the newest, and as you scroll down, more logs will be automatically loaded until the entire log history is displayed.`,content:`Access and manage logs from the App Monitor&rsquo;s &ldquo;Logs&rdquo; section to gain valuable insights into your app&rsquo;s activities. Logs are essential for diagnosing issues and identifying anomalies within your application.
In the logs, you&rsquo;ll find entries generated by both the system and those created using JavaScript API methods like sys.logs.info() or sys.logs.error().
Logs are organized from the oldest to the newest, and as you scroll down, more logs will be automatically loaded until the entire log history is displayed.
It&rsquo;s important to note that there&rsquo;s a limit on the amount of storage allocated for logs (refer to the &ldquo;Logs and Alerts&rdquo; section). Once this limit is reached, older logs will be rotated out and removed.
Filtering logs # Logs can be filtered based on various criteria, including log level (info, warn, error), time, and a search string. When filtering by time, you can specify a time duration such as &ldquo;5m&rdquo; (for the last five minutes), &ldquo;2h&rdquo; (for the last two hours), or &ldquo;3d&rdquo; (for the last three days). For more precision, you can also use a date range.
The search string allows you to find log entries containing a specific text or regular expression. For example, by using regex: .*GET.*, you can filter logs related to HTTP GET requests.
Additional log details # Two flags, &quot;Show IP&quot; and &quot;Show Location,&quot; provide supplementary information in logs. Enabling &quot;Show IP&quot; displays the IP address of the request source (if available), while &ldquo;Show Location&rdquo; reveals the geographical location (city/state/country) of the request source (if available).
Log categories # You can choose to view specific categories of logs:
&quot;External Only&quot;: Displays logs related to interactions between the app and external systems, such as REST API calls or legacy service interactions.
&quot;UI Only&quot;: Shows logs originating from user interface (UI) requests.
Exploring log details # Some logs contain extensive information that cannot be displayed in a single log line to maintain readability. Look for a &ldquo;More Info&rdquo; button on such logs. Clicking it reveals additional details. For example, in a legacy service event, you can view data sent by the legacy service, error locations within the code, and stack traces—valuable information for debugging.
Contextual log viewing # When filtering logs, you&rsquo;ll find a &ldquo;Context&rdquo; button next to each log entry. Clicking it displays logs both before and after the selected log entry, helping you understand the context of the log without altering your filters.
Alerts # Alerts can be configured based on logs. For instance, in a production environment, you may want to receive alerts when errors or warnings are logged. This can be set up in the App Monitor or App Builder under &ldquo;Environment Settings &gt; Logs and Alerts.&rdquo; Refer to the documentation for more details.
Downloading logs # You have the option to export app logs in a compressed JSON format file based on your current filtering selection. The log entries file will be generated as a background task. Once the task completes, the file download will initiate automatically.
`}),e.add({id:165,href:"/getting-started/getting/first-steps/task-mananger/testingusers/",title:"Testing users and permissions",description:`In this section, we will test the different permissions and users that we created in the previous section.
Log in as a Developer # 👉 Log in to the runtime with your developer account (the same one we have been using). We don’t need to log in and out with the different users we created just for our app.
👉 Developers can switch users with a special feature that allows them to emulate other users, which is useful for testing different users and permissions.`,content:`In this section, we will test the different permissions and users that we created in the previous section.
Log in as a Developer # 👉 Log in to the runtime with your developer account (the same one we have been using). We don’t need to log in and out with the different users we created just for our app.
👉 Developers can switch users with a special feature that allows them to emulate other users, which is useful for testing different users and permissions.
👉 Once you are logged in as a developer, follow these steps:
Click on the sandwich button with your name on the header to show a dropdown menu.
Click on &quot;Switch user&quot;, and a pop-up should open.
In the &quot;Switch user&quot; field of the dropdown menu, select &quot;Manager1 Test&quot;, and then click on &quot;Switch&quot;.
👉 You should now be logged in as &ldquo;Manager1 Test&rdquo; and able to see all tasks.
Testing Permissions # Follow these steps to test permissions:
Create two tasks: assign one to &quot;Support1 Test&quot; and the other to &quot;Support2 Test&quot;.
Switch to user &quot;Support1 Test&quot; using the &quot;Switch user&quot; option in the user menu.
You should only see the tasks assigned to &quot;Support1 Test&quot;.
Switch to user &quot;Support2 Test&quot; using the &quot;Switch user&quot; option in the user menu.
You should only see the tasks assigned to &quot;Support2 Test&quot;.
You can switch back to your developer user using the same &quot;Switch user&quot; option.
That’s the basics about permissions, but there are more features to allow more fine-grained permissions management. For more information, check the &ldquo;Developer’s Reference&rdquo; section.
😍
Almost Finished!
Awesome, we are almost finished with our app. Hopefully, everything is working as expected. But if not, don’t worry! In the next section, we will learn how to find out what’s going on by using the app monitor.
`}),e.add({id:166,href:"/dev-reference/monitoring/endpoints/",title:"Legacy services management",description:`In the App Monitor&rsquo;s &quot;legacy services&quot; section, you can gain insights into the status and details of your application&rsquo;s legacy services. These legacy services are essential for integrating your app with external services and systems. Here&rsquo;s what you&rsquo;ll find in this section:
Status: Indicates whether the legacy service is currently deployed, undeployed, or in an intermediate status.
Last 24 Hours Activity: Provides data on the number of function calls and events received in the past 24 hours.`,content:`In the App Monitor&rsquo;s &quot;legacy services&quot; section, you can gain insights into the status and details of your application&rsquo;s legacy services. These legacy services are essential for integrating your app with external services and systems. Here&rsquo;s what you&rsquo;ll find in this section:
Status: Indicates whether the legacy service is currently deployed, undeployed, or in an intermediate status.
Last 24 Hours Activity: Provides data on the number of function calls and events received in the past 24 hours.
Running Instances: Displays the number of active instances for each of your legacy services.
Configuration Details: By clicking on a specific legacy service, you can access its detailed configuration settings.
Managing legacy services # You can perform various operations on your legacy services to ensure they are running as expected:
Deploy: If an legacy service is undeployed, you can activate it by selecting it and clicking the Deploy button.
Undeploy: If an legacy service is deployed but you no longer need it, you can deactivate it by selecting it and clicking the Undeploy button. After undeploying, the endpoint will cease to function, and no further calls or events will be processed, conserving resources.
Redeploy: This option restarts selected legacy services. It can be useful when changes have been made to configuration through environment variables or when there are unusual behavior patterns in a legacy service.
Legacy services configuration # Configuring legacy services to align with your app&rsquo;s requirements is crucial. You can customize various settings:
Generate Token: Legacy services are typically secured with a token to enable communication from external sources. You can regenerate this token here if it is compromised or for security reasons.
Profile: Some legacy services offer different memory profiles, which can be tailored to factors such as the size of your team or usage patterns.
Multiple Instances: If supported, you can adjust the number of instances for an legacy service. Increasing instances can enhance the legacy service&rsquo;s capacity to handle higher loads for your integrations.
Hide Logs Content: For legacy services that process sensitive information, enabling this flag ensures that any sensitive data is not logged. This is particularly important for legacy services dealing with confidential information, such as credit card processing in production.
Managing your legacy services efficiently ensures the smooth operation of your app&rsquo;s integrations and external interactions.
`}),e.add({id:167,href:"/dev-reference/monitoring/database-and-files/",title:"Database and storage",description:`In the App Monitor&rsquo;s &ldquo;Database&rdquo; section, you&rsquo;ll find comprehensive insights into your app&rsquo;s data statistics and the tools to perform essential maintenance operations. This section is invaluable for managing your app&rsquo;s database effectively.
Database information # At the top of the page, you&rsquo;ll find essential information about your data:
Total Database Size: This represents the total storage space used by your database, considered for billing and plans.
App Storage: The space allocated to your app&rsquo;s data, including records within your entities, associated indexes, and historical logs.`,content:`In the App Monitor&rsquo;s &ldquo;Database&rdquo; section, you&rsquo;ll find comprehensive insights into your app&rsquo;s data statistics and the tools to perform essential maintenance operations. This section is invaluable for managing your app&rsquo;s database effectively.
Database information # At the top of the page, you&rsquo;ll find essential information about your data:
Total Database Size: This represents the total storage space used by your database, considered for billing and plans.
App Storage: The space allocated to your app&rsquo;s data, including records within your entities, associated indexes, and historical logs.
System Storage: This portion of the database is dedicated to system-related information such as logs, jobs, indexes, and more.
Entities # The list of entities provides detailed information on each entity:
Total Data Size: This indicates the overall space used by records within the entity, including associated indexes.
Data Size: The space used solely by records within the entity, excluding indexes.
Entries Count: Displays the total number of records stored in the entity.
Indexes Size: Represents the space used by indexes associated with the entity.
Number of Indexes: Indicates the total number of indexes configured for the entity.
Percentage Relative to Data: This provides insight into how much space the entity occupies compared to the total database size.
By clicking on an entity, you can access more detailed information, including index statuses and two critical operations:
Refresh Relationships: Use this operation if your relationship fields become outdated. Running this action updates relationship fields across all records within the entity.
Refresh Calculated Fields: When your calculated fields contain outdated values, use this operation. It updates calculated fields across all records within the entity.
Performance # The &ldquo;Performance&rdquo; section is dedicated to monitoring slow queries. This is crucial if you&rsquo;re experiencing performance issues in your app. You can identify which operations are consuming more time and make informed decisions about creating indexes or making adjustments to enhance your app&rsquo;s performance.
Tools # Under the &ldquo;Tools&rdquo; section, you&rsquo;ll find maintenance utilities for your database:
Repair Database: Trigger this option to initiate cleanup tasks that can resolve unusual behaviors in your app. For instance, if you notice discrepancies in record counts within an entity, using this tool might rectify the issue. Files information # At the top of the page, you&rsquo;ll find data on your app&rsquo;s files:
Total Files Size: This is the cumulative space occupied by both public and private files.
Private Files: These files reside in file fields within your app. Learn more about the &ldquo;File&rdquo; field type here.
Public Files: These files can be managed within the app builder. To learn more about public files, refer to the Public Files documentation.
`}),e.add({id:168,href:"/dev-reference/monitoring/other-tools/",title:"Other tools",description:`In the App Monitor, you have access to a set of valuable tools that assist you in efficiently managing your app environment. These tools offer insights and control over various aspects of your application&rsquo;s runtime.
App explorer # The App Explorer provides a view of your app&rsquo;s metadata in its current runtime state. It&rsquo;s important to note that this metadata might differ from what you see in the App Builder if you haven&rsquo;t pushed all your changes.`,content:`In the App Monitor, you have access to a set of valuable tools that assist you in efficiently managing your app environment. These tools offer insights and control over various aspects of your application&rsquo;s runtime.
App explorer # The App Explorer provides a view of your app&rsquo;s metadata in its current runtime state. It&rsquo;s important to note that this metadata might differ from what you see in the App Builder if you haven&rsquo;t pushed all your changes. In production environments, the App Explorer is the sole method for exploring metadata, as there is no App Builder instance available.
Storage # The Storage section in the App Monitor allows you to interact with the temporary key-value storage engine of your app. Here&rsquo;s what you can do:
View Existing Key-Value Pairs: Inspect the key-value pairs currently stored in the storage engine.
Edit Value of an Existing Key: Modify the value associated with an existing key.
Create New Key-Value Pairs: Add new key-value pairs to the storage engine.
Clear Storage: Remove all key-value pairs from the storage engine, providing a clean slate for your app&rsquo;s temporary data.
Users management # In the Users section of the App Monitor, you gain the capability to manage users within your app environment. For comprehensive details on user management, please refer to our Users Management documentation.
Console # The Console is a powerful tool for executing scripts directly within your app&rsquo;s runtime. This functionality is particularly useful for maintenance tasks, such as mass updates to records in response to unexpected events. Rather than manually updating records one by one, you can write a script to make the necessary changes and execute it from the console.
When you execute a script in the console, a job is created to execute it. All logs generated during the job&rsquo;s execution are displayed in the console output. You can add logs to the job using methods likesys.jobs.logInfo() or sys.jobs.logError(). There&rsquo;s also a convenient shortcut for logging when executing scripts in the console, which is log():
for (var i = 0; i &lt; 10; i++) { log('i: '+i); } Please note that logs generated using sys.jobs.logInfo() or sys.jobs.logError() will appear in the app logs, not in the console output.
REST API # In the REST API section of the App Monitor, you can access essential information about the REST API calls made to your app over time:
Number of Calls: Displays the total number of API calls made to your app.
Average Response Time: Represents the average response time for API calls. If you observe a consistent increase in this value, it might be an indicator that you need to either scale up your app by adding more instances or increase the resource allocation to your existing instances.
Minimum Response Time: Indicates the shortest response time observed for API calls to your app.
Maximum Response Time: Highlights the longest response time recorded for API calls to your app.
`}),e.add({id:169,href:"/dev-reference/miscellaneous/",title:"Miscellaneous",description:"",content:""}),e.add({id:170,href:"/dev-reference/miscellaneous/icons/",title:"Icons",description:`Here is a list of the available icons and their corresponding codes for the app:
Icon Code 3d-rotation airplane-off airplane album archive assignment-account assignment-alert assignment-check assignment-o assignment-return assignment-returned assignment attachment-alt attachment audio badge-check balance-wallet balance-wallet balance battery-alert battery-flash battery-unknown battery bike block-alt block boat book-image book bookmark-outline bookmark brush bug bus cake car-taxi car-wash car card-giftcard card-membership card-travel card case-check case-download case-play case cast-connected cast chart-donut chart city-alt city close-circle-o close-circle close cocktail code-setting code-smartphone code coffee collection-bookmark collection-case-play collection-folder-image collection-image-o collection-image collection-item-1 collection-item-2 collection-item-3 collection-item-4 collection-item-5 collection-item-6 collection-item-7 zmdi-collection-item-8 collection-item-9-plus collection-item-9 collection-item collection-music collection-pdf collection-plus collection-speaker collection-text collection-video compass cutlery delete dialpad dns drink edit email-open email eye-off eye eyedropper favorite-outline favorite filter-list fire flag flare flash-auto flash-off flash flip flower-alt flower font fullscreen-alt fullscreen-exit fullscreen functions gas-station gesture globe-alt fullscreen globe-lock globe graduation-cap group home hospital-alt hospital hotel hourglass-alt hourglass-outline hourglass http image-alt image-o image inbox invert-colors-off invert-colors key label-alt-outline label-alt label-heart label labels lamp landscape layers-off layers library link lock-open lock-outline lock mail-reply-all mail-reply mail-send mall map menu money-box money-off money more-vert more movie-alt movie open-in-browser open-in-new palette parking pin-account pin-assistant pin-drop pin-help pin-off pin pizza plaster power-setting power print puzzle-piece quote railway receipt refresh-alt refresh-sync-alert refresh-sync-off refresh-sync refresh roller ruler scissors screen-rotation-lock screen-rotation search-for search-in-file search-in-page search-replace search seat settings-square settings shape shield-check shield-security shopping-basket shopping-cart-plus shopping-cart sign-in sort-amount-asc sort-amount-desc sort-asc sort-desc spellcheck spinner storage store-24 store subway sun tab-unselected tab tag-close tag-more tag thumb-down thumb-up-down thumb-up ticket-star toll toys traffic translate triangle-down triangle-up truck turning-sign ungroup wallpaper washing-machine window-maximize window-minimize window-restore wrench zoom-in zoom-out alert-circle-o alert-circle alert-octagon alert-polygon alert-triangle help-outline help info-outline info notifications-active notifications-add notifications-none notifications-off notifications-paused notifications account-add account-box-mail account-box-o account-box-phone account-box account-calendar account-circle account-o account accounts-add accounts-alt accounts-list-alt accounts-list accounts-outline accounts face female male-alt male-female male mood-bad mood run walk cloud-box cloud-circle cloud-done cloud-download cloud-off cloud-outline-alt cloud-outline cloud-upload cloud download file-plus file-text file folder-outline folder-person folder-star-alt folder-star folder gif upload border-all border-bottom border-clear border-color border-horizontal border-inner border-left border-outer border-right border-style border-top border-vertical copy crop format-align-center format-align-justify format-align-left format-align-right format-bold format-clear-all format-clear format-color-fill format-color-reset format-color-text format-indent-decrease format-indent-increase format-italic format-line-spacing format-list-bulleted format-list-numbered format-ltr format-rtl format-size format-strikethrough-s format-strikethrough format-subject format-underlined format-valign-bottom format-valign-center format-valign-top redo select-all space-bar text-format transform undo wrap-text comment-alert comment-alt-text comment-alt comment-edit comment-image comment-list comment-more comment-outline comment-text-alt comment-text comment-video comment comments check-all check-circle-u check-circle check-square check circle-o circle dot-circle-alt dot-circle minus-circle-outline minus-circle minus-square minus plus-circle-o-duplicate plus-circle-o plus-circle plus-square plus square-o star-circle star-half star-outline star bluetooth-connected bluetooth-off bluetooth-search bluetooth-setting bluetooth camera-add camera-alt camera-bw camera-front camera-mic camera-party-mode camera-rear camera-roll camera-switch camera card-alert card-off card-sd card-sim desktop-mac desktop-windows device-hub devices-off devices dock floppy gamepad gps-dot gps-off gps headset-mic headset input-antenna input-composite input-hdmi input-power input-svideo keyboard-hide keyboard laptop-chromebook laptop-mac laptop mic-off mic-outline mic-setting mic mouse network-alert network-locked network-off network-outline network-setting network phone-bluetooth phone-end phone-forwarded phone-in-talk phone-locked phone-missed phone-msg phone-paused phone-ring phone-setting phone-sip phone portable-wifi-changes portable-wifi-off portable-wifi radio reader remote-control-alt remote-control router scanner smartphone-android smartphone-download smartphone-erase smartphone-info smartphone-iphone smartphone-landscape-lock smartphone-landscape smartphone-lock smartphone-portrait-lock smartphone-ring smartphone-setting smartphone-setup smartphone speaker tablet-android tablet-mac tablet tv-alt-play tv-list tv-play tv usb videocam-off videocam-switch videocam watch wifi-alt-2 wifi-alt wifi-info wifi-lock wifi-off wifi-outline wifi arrow-left-bottom arrow-left arrow-merge arrow-missed arrow-right-top arrow-right arrow-split arrows caret-down-circle caret-down caret-left-circle chevron-down chevron-left chevron-right chevron-up forward long-arrow-down long-arrow-left long-arrow-return long-arrow-right long-arrow-tab long-arrow-up rotate-ccw rotate-cw rotate-left rotate-right square-down square-right swap-alt swap-vertical-circle swap-vertical swap trending-down trending-flat trending-up unfold-less unfold-more directions-bike directions-boat directions-bus directions-car directions-railway directions-run directions-subway directions-walk directions layers-off layers local-activity local-airport local-atm local-bar local-cafe local-car-wash local-convenience-store local-dining local-drink local-florist local-gas-station local-grocery-store local-hospital local-hotel local-laundry-service local-library local-mall local-movies local-offer local-parking local-pharmacy local-phone local-pizza local-activity local-post-office local-printshop local-see local-shipping local-store local-taxi local-wc map my-location nature-people nature navigation pin-account pin-assistant pin-drop pin-help pin-off pin traffic apps grid-off grid view-agenda view-array view-carousel view-column view-comfy view-compact view-dashboard view-day view-headline view-list-alt view-list view-module view-quilt view-stream view-subtitles view-toc view-web view-week widgets alarm-check alarm-off alarm-plus alarm-snooze alarm calendar-alt calendar-check calendar-close calendar-note calendar time-countdown time-interval time-restore-setting time-restore time timer-off timer android-alt android apple behance codepen dribbble dropbox evernote facebook-box facebook github-box github google-drive google-earth google-glass google-maps google-pages google-play google-plus-box google-plus google instagram language-css3 language-html5 language-javascript language-python-alt language-python lastfm linkedin-box paypal pinterest-box pocket polymer rss share stackoverflow steam-square steam twitter-box twitter vk wikipedia windows 500px 8tracks amazon blogger delicious disqus flattr flickr github-alt google-old linkedin odnoklassniki outlook paypal-alt pinterest playstation reddit skype slideshare soundcloud tumblr twitch vimeo whatsapp xbox yahoo youtube-play youtube aspect-ratio-alt aspect-ratio blur-circular blur-linear blur-off blur brightness-2 brightness-3 brightness-4 brightness-5 brightness-6 brightness-7 brightness-auto brightness-setting broken-image center-focus-strong center-focus-weak compare crop-16-9 crop-3-2 crop-5-4 crop-7-5 crop-din crop-free crop-landscape crop-portrait crop-square exposure-alt exposure filter-b-and-w filter-center-focus filter-frames filter-tilt-shift gradient grain graphic-eq hdr-off hdr-strong hdr-weak hdr iridescent leak-off leak looks loupe panorama-horizontal panorama-vertical panorama-wide-angle photo-size-select-large photo-size-select-small picture-in-picture slideshow texture tonality vignette wb-auto eject-alt eject equalizer fast-forward fast-rewind forward-10 forward-30 forward-5 hearing pause-circle-outline pause-circle pause play-circle-outline play-circle play playlist-audio playlist-plus repeat-one repeat replay-10 replay-30 replay-5 replay shuffle skip-next skip-previous stop surround-sound tune volume-down volume-mute volume-off volume-up n-1-square n-2-square n-3-square n-4-square n-5-square n-6-square neg-1 neg-2 plus-1 plus-2 sec-10 sec-3 zero airline-seat-flat-angled airline-seat-flat airline-seat-individual-suite airline-seat-legroom-extra airline-seat-legroom-normal airline-seat-legroom-reduced airline-seat-recline-extra airline-seat-recline-normal airplay closed-caption confirmation-number developer-board disc-full explicit flight-land flight-takeoff flip-to-back flip-to-front group-work hd hq markunread-mailbox memory nfc play-for-work power-input present-to-all satellite tap-and-play vibration voicemail `,content:`Here is a list of the available icons and their corresponding codes for the app:
Icon Code 3d-rotation airplane-off airplane album archive assignment-account assignment-alert assignment-check assignment-o assignment-return assignment-returned assignment attachment-alt attachment audio badge-check balance-wallet balance-wallet balance battery-alert battery-flash battery-unknown battery bike block-alt block boat book-image book bookmark-outline bookmark brush bug bus cake car-taxi car-wash car card-giftcard card-membership card-travel card case-check case-download case-play case cast-connected cast chart-donut chart city-alt city close-circle-o close-circle close cocktail code-setting code-smartphone code coffee collection-bookmark collection-case-play collection-folder-image collection-image-o collection-image collection-item-1 collection-item-2 collection-item-3 collection-item-4 collection-item-5 collection-item-6 collection-item-7 zmdi-collection-item-8 collection-item-9-plus collection-item-9 collection-item collection-music collection-pdf collection-plus collection-speaker collection-text collection-video compass cutlery delete dialpad dns drink edit email-open email eye-off eye eyedropper favorite-outline favorite filter-list fire flag flare flash-auto flash-off flash flip flower-alt flower font fullscreen-alt fullscreen-exit fullscreen functions gas-station gesture globe-alt fullscreen globe-lock globe graduation-cap group home hospital-alt hospital hotel hourglass-alt hourglass-outline hourglass http image-alt image-o image inbox invert-colors-off invert-colors key label-alt-outline label-alt label-heart label labels lamp landscape layers-off layers library link lock-open lock-outline lock mail-reply-all mail-reply mail-send mall map menu money-box money-off money more-vert more movie-alt movie open-in-browser open-in-new palette parking pin-account pin-assistant pin-drop pin-help pin-off pin pizza plaster power-setting power print puzzle-piece quote railway receipt refresh-alt refresh-sync-alert refresh-sync-off refresh-sync refresh roller ruler scissors screen-rotation-lock screen-rotation search-for search-in-file search-in-page search-replace search seat settings-square settings shape shield-check shield-security shopping-basket shopping-cart-plus shopping-cart sign-in sort-amount-asc sort-amount-desc sort-asc sort-desc spellcheck spinner storage store-24 store subway sun tab-unselected tab tag-close tag-more tag thumb-down thumb-up-down thumb-up ticket-star toll toys traffic translate triangle-down triangle-up truck turning-sign ungroup wallpaper washing-machine window-maximize window-minimize window-restore wrench zoom-in zoom-out alert-circle-o alert-circle alert-octagon alert-polygon alert-triangle help-outline help info-outline info notifications-active notifications-add notifications-none notifications-off notifications-paused notifications account-add account-box-mail account-box-o account-box-phone account-box account-calendar account-circle account-o account accounts-add accounts-alt accounts-list-alt accounts-list accounts-outline accounts face female male-alt male-female male mood-bad mood run walk cloud-box cloud-circle cloud-done cloud-download cloud-off cloud-outline-alt cloud-outline cloud-upload cloud download file-plus file-text file folder-outline folder-person folder-star-alt folder-star folder gif upload border-all border-bottom border-clear border-color border-horizontal border-inner border-left border-outer border-right border-style border-top border-vertical copy crop format-align-center format-align-justify format-align-left format-align-right format-bold format-clear-all format-clear format-color-fill format-color-reset format-color-text format-indent-decrease format-indent-increase format-italic format-line-spacing format-list-bulleted format-list-numbered format-ltr format-rtl format-size format-strikethrough-s format-strikethrough format-subject format-underlined format-valign-bottom format-valign-center format-valign-top redo select-all space-bar text-format transform undo wrap-text comment-alert comment-alt-text comment-alt comment-edit comment-image comment-list comment-more comment-outline comment-text-alt comment-text comment-video comment comments check-all check-circle-u check-circle check-square check circle-o circle dot-circle-alt dot-circle minus-circle-outline minus-circle minus-square minus plus-circle-o-duplicate plus-circle-o plus-circle plus-square plus square-o star-circle star-half star-outline star bluetooth-connected bluetooth-off bluetooth-search bluetooth-setting bluetooth camera-add camera-alt camera-bw camera-front camera-mic camera-party-mode camera-rear camera-roll camera-switch camera card-alert card-off card-sd card-sim desktop-mac desktop-windows device-hub devices-off devices dock floppy gamepad gps-dot gps-off gps headset-mic headset input-antenna input-composite input-hdmi input-power input-svideo keyboard-hide keyboard laptop-chromebook laptop-mac laptop mic-off mic-outline mic-setting mic mouse network-alert network-locked network-off network-outline network-setting network phone-bluetooth phone-end phone-forwarded phone-in-talk phone-locked phone-missed phone-msg phone-paused phone-ring phone-setting phone-sip phone portable-wifi-changes portable-wifi-off portable-wifi radio reader remote-control-alt remote-control router scanner smartphone-android smartphone-download smartphone-erase smartphone-info smartphone-iphone smartphone-landscape-lock smartphone-landscape smartphone-lock smartphone-portrait-lock smartphone-ring smartphone-setting smartphone-setup smartphone speaker tablet-android tablet-mac tablet tv-alt-play tv-list tv-play tv usb videocam-off videocam-switch videocam watch wifi-alt-2 wifi-alt wifi-info wifi-lock wifi-off wifi-outline wifi arrow-left-bottom arrow-left arrow-merge arrow-missed arrow-right-top arrow-right arrow-split arrows caret-down-circle caret-down caret-left-circle chevron-down chevron-left chevron-right chevron-up forward long-arrow-down long-arrow-left long-arrow-return long-arrow-right long-arrow-tab long-arrow-up rotate-ccw rotate-cw rotate-left rotate-right square-down square-right swap-alt swap-vertical-circle swap-vertical swap trending-down trending-flat trending-up unfold-less unfold-more directions-bike directions-boat directions-bus directions-car directions-railway directions-run directions-subway directions-walk directions layers-off layers local-activity local-airport local-atm local-bar local-cafe local-car-wash local-convenience-store local-dining local-drink local-florist local-gas-station local-grocery-store local-hospital local-hotel local-laundry-service local-library local-mall local-movies local-offer local-parking local-pharmacy local-phone local-pizza local-activity local-post-office local-printshop local-see local-shipping local-store local-taxi local-wc map my-location nature-people nature navigation pin-account pin-assistant pin-drop pin-help pin-off pin traffic apps grid-off grid view-agenda view-array view-carousel view-column view-comfy view-compact view-dashboard view-day view-headline view-list-alt view-list view-module view-quilt view-stream view-subtitles view-toc view-web view-week widgets alarm-check alarm-off alarm-plus alarm-snooze alarm calendar-alt calendar-check calendar-close calendar-note calendar time-countdown time-interval time-restore-setting time-restore time timer-off timer android-alt android apple behance codepen dribbble dropbox evernote facebook-box facebook github-box github google-drive google-earth google-glass google-maps google-pages google-play google-plus-box google-plus google instagram language-css3 language-html5 language-javascript language-python-alt language-python lastfm linkedin-box paypal pinterest-box pocket polymer rss share stackoverflow steam-square steam twitter-box twitter vk wikipedia windows 500px 8tracks amazon blogger delicious disqus flattr flickr github-alt google-old linkedin odnoklassniki outlook paypal-alt pinterest playstation reddit skype slideshare soundcloud tumblr twitch vimeo whatsapp xbox yahoo youtube-play youtube aspect-ratio-alt aspect-ratio blur-circular blur-linear blur-off blur brightness-2 brightness-3 brightness-4 brightness-5 brightness-6 brightness-7 brightness-auto brightness-setting broken-image center-focus-strong center-focus-weak compare crop-16-9 crop-3-2 crop-5-4 crop-7-5 crop-din crop-free crop-landscape crop-portrait crop-square exposure-alt exposure filter-b-and-w filter-center-focus filter-frames filter-tilt-shift gradient grain graphic-eq hdr-off hdr-strong hdr-weak hdr iridescent leak-off leak looks loupe panorama-horizontal panorama-vertical panorama-wide-angle photo-size-select-large photo-size-select-small picture-in-picture slideshow texture tonality vignette wb-auto eject-alt eject equalizer fast-forward fast-rewind forward-10 forward-30 forward-5 hearing pause-circle-outline pause-circle pause play-circle-outline play-circle play playlist-audio playlist-plus repeat-one repeat replay-10 replay-30 replay-5 replay shuffle skip-next skip-previous stop surround-sound tune volume-down volume-mute volume-off volume-up n-1-square n-2-square n-3-square n-4-square n-5-square n-6-square neg-1 neg-2 plus-1 plus-2 sec-10 sec-3 zero airline-seat-flat-angled airline-seat-flat airline-seat-individual-suite airline-seat-legroom-extra airline-seat-legroom-normal airline-seat-legroom-reduced airline-seat-recline-extra airline-seat-recline-normal airplay closed-caption confirmation-number developer-board disc-full explicit flight-land flight-takeoff flip-to-back flip-to-front group-work hd hq markunread-mailbox memory nfc play-for-work power-input present-to-all satellite tap-and-play vibration voicemail `}),e.add({id:171,href:"/dev-reference/miscellaneous/code-editor/",title:"Code editor",description:`The code editor component is a specialized text editor designed for editing code. It provides several features, including:
Syntax highlighting Autocompletion Find Variable refactoring Displaying documentation Jumping to definitions Features # Autocompletion # To enable the autocompletion feature, press Ctrl-Space (or Ctrl + Shift + Space for Mac users). Once enabled, you can autocomplete:
Namespaces and methods belonging to the JavaScript API. Please refer to the JavaScript API documentation for available services.`,content:`The code editor component is a specialized text editor designed for editing code. It provides several features, including:
Syntax highlighting Autocompletion Find Variable refactoring Displaying documentation Jumping to definitions Features # Autocompletion # To enable the autocompletion feature, press Ctrl-Space (or Ctrl + Shift + Space for Mac users). Once enabled, you can autocomplete:
Namespaces and methods belonging to the JavaScript API. Please refer to the JavaScript API documentation for available services. Namespaces, methods, and constants exposed in Libraries. Namespaces and methods exposed in legacy service components. Navigation # To navigate through app library symbols, move the cursor over the desired method or constant and press Ctrl-J. This action will take you to the definition of the method or constant in the app library. To open a symbol in a new tab, press Ctrl-L. If you press Ctrl-J or Ctrl-L while positioned over a JavaScript API symbol, it will open a new tab with related documentation.
Displaying docs # To display summary documentation for a specific symbol, move the cursor over it and press Ctrl-I. To access detailed documentation for a symbol belonging to the JavaScript API, press Ctrl-J or Ctrl-L. This action will open a new tab in your browser.
Shortcuts summary # Ctrl-Space: Enable the autocompletion feature. Ctrl-J: Jump to a specific library or go to JavaScript API documentation. Ctrl-L: Jump to a specific library in a new browser tab or go to JavaScript API documentation. Ctrl-I: Display summary documentation for a specific symbol. Ctrl-Q: Rename a specific symbol. Ctrl-.: Select a specific symbol. Ctrl-/: Attempt to uncomment the current selection, and if that fails, line-comment it. Ctrl-Alt-F: Toggle full-screen mode. Esc: Clear the selection. Disable full-screen mode. Ctrl-Z: Undo the last change. `}),e.add({id:172,href:"/getting-started/getting/first-steps/task-mananger/monitor/",title:"The app monitor",description:`We have completed the development of our app, but it&rsquo;s important to mention that you can monitor its activity using the app monitor.
Discover app monitor tool # To access the monitor, click on the Monitor button (the one with an eye) on the developer portal.
See the logs # On the app monitor, you can view information about your running apps. For example, you can see the logs of your app in the Logs section:`,content:`We have completed the development of our app, but it&rsquo;s important to mention that you can monitor its activity using the app monitor.
Discover app monitor tool # To access the monitor, click on the Monitor button (the one with an eye) on the developer portal.
See the logs # On the app monitor, you can view information about your running apps. For example, you can see the logs of your app in the Logs section:
Manage users # You can also manage the users of your app from the Users section:
The app monitor is a valuable tool, and we encourage you to explore its different features.
🥳
Conclusion # Congratulations! You&rsquo;ve reached the end of this tutorial, and we hope you&rsquo;ve gained valuable insights into working with Slingr.
Now, it&rsquo;s your turn to build something great!
Happy coding!
`}),e.add({id:173,href:"/getting-started/getting/first-steps/",title:"First Steps",description:"",content:""}),e.add({id:174,href:"/dev-reference/field-types/number/auto-increment/",title:"Auto-increment type",description:`Overview # This type generates auto-incremental unique numbers as new records are created within the entity.
Fields of this type cannot be edited and are consistently managed by the app. As of now, there is no method to reset the counter or set it to a starting position other than zero.
When a field of this type is added to an entity with existing records, it will be initialized by assigning values based on the creation order of the records.`,content:`Overview # This type generates auto-incremental unique numbers as new records are created within the entity.
Fields of this type cannot be edited and are consistently managed by the app. As of now, there is no method to reset the counter or set it to a starting position other than zero.
When a field of this type is added to an entity with existing records, it will be initialized by assigning values based on the creation order of the records.
Available features # Name Supported Many multiplicity no Default values no Unique flag no Required flag no Indexable flag yes Sensitive flag yes Calculated value no Automatic initialization yes Calculated initial value yes Aggregation no Default type rules yes Default display options no Type rules # Minimum value # This defines the minimum value to be assigned to the next record. For instance, if you set it to 10,000, the subsequent value will be 10,000. This setting proves useful when you want numbers to initiate from a specific value.
It&rsquo;s important to note that this setting doesn&rsquo;t affect pre-existing records. Moreover, if you modify the value to a number lower than the current auto-increment value, it will not have any impact. For example, if the last created record was assigned the number 3,000 and you alter the minimum value to 1,000, this change will not influence the next value, which will still be 3,001.
REST API # Read format # The format is a number:
&quot;number&quot;: 8 Write format # There is no method for writing to an auto-increment field.
JavaScript API # Read format # The val() method within the wrapper will return a number.
// this will print something like &quot;number: 23&quot; log('number: '+record.field('number').val()); Write format # There is no method for writing to an auto-increment field.
Wrapper method: toHex() # The toHex() method returns string of hexadecimal representation of the value or empty ('') if null.
Returns # string - Hex value of number.
Samples # // prints the hex value of a integer field var record = sys.data.findOne('projects', {name: 'Point-to-point link'}); sys.logs.debug('project number of people hex:'+record.field('numberOfPeople').toHex()); Wrapper method: format(options) # Returns a string representing the formatted number value or an unformatted string.
Parameters # Name Type Required Description options object no These parameters are used to format the value. If left empty, the default display options will be used for formatting.
- thousandsSeparator: Indicates whether to show a thousands separator. Options are &ldquo;true&rdquo; or &ldquo;false.&rdquo; Returns # string - String of formatted value of number.
Samples # // prints the formated value of a integer field var record = sys.data.findOne('projects', {name: 'Point-to-point link'}); sys.logs.debug('project number of people:'+record.field('numberOfPeople').format({thousandsSeparator: true})); Export/Import # Export format # The export format is a simple number.
&quot;id&quot;,&quot;tittle&quot; &quot;1&quot;,&quot;task A&quot; &quot;2&quot;,&quot;task B&quot; Import format # Auto-increment fields cannot be imported because they are generated.
Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should provide the number. For instance:
JS Query MapJS Query BuilderREST API // finds tickets with field number higjer than 10 var records_sample = sys.data.find('tickets', {&#39;number&#39;: &#39;greater(10)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds tickets with field number higjer than 10 var query_sample = sys.data.createQuery('tickets') .field(&#39;tickets&#39;).greater(10) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds tickets with field number higjer than 10 GET /data/contacts?tickets=greater(10) Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum yes avg yes first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between yes `}),e.add({id:175,href:"/dev-reference/field-types/number/big-number/",title:"Big Number type",description:`Overview # This type is designed to store large numbers and can accommodate up to 34 significant digits.
The big number type utilizes bignumber.js within the JavaScript API. For performing operations using this data type, you can refer to bignumber.js&rsquo;s documentation.
To set the value, you can use a string, number, or a big number object. The BigNumber class is accessible through sys.utils.numbers.
For instance:
// retrieve the big number instance var bigNumber = record.`,content:`Overview # This type is designed to store large numbers and can accommodate up to 34 significant digits.
The big number type utilizes bignumber.js within the JavaScript API. For performing operations using this data type, you can refer to bignumber.js&rsquo;s documentation.
To set the value, you can use a string, number, or a big number object. The BigNumber class is accessible through sys.utils.numbers.
For instance:
// retrieve the big number instance var bigNumber = record.field('raiting').val(); // perform some operation. Check documentation http://mikemcl.github.io/bignumber.js bigNumber = bigNumber.plus(3); // objects are immutable // set value before save it record.field('raiting').val(bigNumber); // or var bigNumber = new sys.utils.numbers.BigNumber(1011, 2); bigNumber = bigNumber.plus(5); record.field('raiting').val(bigNumber); Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation yes Default type rules yes Default display options yes Type rules # Minimum value # The minimum value (inclusive).
Maximum value # The maximum value (inclusive).
Limit decimals # This feature enables the limitation of the number of decimals. This limitation will be applied at the data level, meaning numbers will be stored in the database with the specified number of decimals, and any additional decimals will be discarded. If you wish to retain the additional decimals for display purposes while limiting their storage, you should configure these settings within the display options.
When you opt to limit the number of decimals, the following choices will be presented:
Number of Decimals: This indicates the number of decimals to be stored. It can range from 0 to 4.
Extra Decimals Action: This specifies the action to take when there are more decimals than the limit permits. The available options include:
Round: Rounding will be used to limit the decimals. Truncate: Truncation will be applied to the trailing decimals. Throw Error: An error will be triggered if an attempt is made to set more decimals than the allowable limit. Display options # Show Thousands Separator: If this flag is enabled, the thousands separator will be displayed in read-only mode. Please note that this flag does not impact edit mode.
Limit Number of Decimals: This feature permits the restriction of the displayed decimals. It operates at the UI level and does not affect validation rules or the storage of numbers in the database. Consequently, these options only apply to read-only mode.
When you choose to limit the number of decimals, the following choices will be available:
Number of Decimals: This denotes the count of decimals to be shown. It can range from 0 to 4.
Extra Decimals Action: This specifies the action to be taken when there are more decimals than the set limit. The available options include:
Round: Rounding will be employed to limit the decimals. Truncate: Truncation will be applied to the trailing decimals. REST API # Read format # The format is an string with big number:
&quot;amount&quot;: &quot;8.997738199773819977381&quot; Write format # To set the value, provide a string with the big number:
&quot;amount&quot;: &quot;8.997738199773819977381&quot; JavaScript API # Read format # The val() method within the wrapper will return an instance of a big number:
// this will print something like &quot;energy: 0.123465789&quot; log('energy: '+record.field('energy').val()); var value = record.field('energy').val(); log('energy: '+ value.toFormat(2)); // toFormat is a BigNumber function and limit to two decimals Write format # To set the value, provide a number, string, or big number:
var number = new sys.utils.numbers.BigNumber('zz.9', 36); // Number base 36 -&gt; &quot;1295.25&quot; var n1 = new sys.utils.numbers.BigNumber(1011, 2); // Number base 2 -&gt; &quot;11&quot; number = number.plus(n1); log(number); // print -&gt; 1306.25 record.field('energy').val(number); // set before seved it Wrapper method: toHex() # The toHex() method returns string of hexadecimal representation of the value or empty ('') if null.
Returns # string - Hex value of number.
Samples # // prints the hex value of a big number field var record = sys.data.findOne('contacts', {email: 'william.brown@acme.com'}); sys.logs.debug('contact token hex: '+record.field('token').toHex()); Wrapper method: format(options) # Returns a string representing the formatted number value or an unformatted string.
Parameters # Name Type Required Description options object no These parameters are used to format the value. If left empty, the default display options will be used for formatting.
- thousandsSeparator: If set to &ldquo;true,&rdquo; a thousands separator will be displayed; if set to &ldquo;false,&rdquo; it won&rsquo;t.
- limitNumberOfDecimals: If set to &ldquo;true,&rdquo; the number of decimals will be limited; if set to &ldquo;false,&rdquo; it won&rsquo;t.
- numberOfDecimals: The count of decimals to be displayed. Default is 2.
- limitRuleType: The rule to use when limiting decimals, either &ldquo;TRUNCATE&rdquo; or &ldquo;ROUND.&rdquo; Default is &ldquo;TRUNCATE.&rdquo; Returns # string - String of formatted value of number.
Samples # // prints the formated value of a big number field var inv = sys.data.findById('invoices', '579f5929e4b043b8ce4519b6'); sys.logs.debug('total: ' + inv.field('total').format({ 'thousandsSeparator': true, 'limitNumberOfDecimals': true, 'numberOfDecimals': 2 }) ); Export/Import # Export format # The export format is a big number:
&quot;bigNumberField1&quot;,&quot;bigNumberField2&quot; &quot;0.872&quot;,&quot;27810.0028&quot; Import format # The import format is a string with a big number:
&quot;bigNumberField1&quot;,&quot;bigNumberField2&quot; &quot;0.872&quot;,&quot;27810.0028&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should provide the number. For instance:
JS Query MapJS Query BuilderREST API // finds companies with rating grater or equals than 3.0 var records_sample = sys.data.find('companies', {&#39;rating&#39;: &#39;greaterOrEquals(3.0)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with rating grater or equals than 3.0 var query_sample = sys.data.createQuery('companies') .field(&#39;rating&#39;).greaterOrEquals(&#39;3.0&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with rating grater or equals than 3.0 GET /data/contacts?rating=greaterOrEquals(3.0) Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum yes avg yes first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between yes `}),e.add({id:176,href:"/dev-reference/field-types/multiple_choice/boolean/",title:"Boolean type",description:`Overview # This data type can store a boolean value. Fields of this type cannot be null; their value is strictly either false or true.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag no Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization yes Calculated initial value yes Aggregation no Default type rules no Default display options yes Display Options # Representation # This determines how the field should appear.`,content:`Overview # This data type can store a boolean value. Fields of this type cannot be null; their value is strictly either false or true.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag no Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization yes Calculated initial value yes Aggregation no Default type rules no Default display options yes Display Options # Representation # This determines how the field should appear. The available options are:
Switcher: In edit mode, a switch will be shown, and in read-only mode, a box with the label will be displayed. When this option is selected, you can specify the labels to be either &ldquo;Yes/No&rdquo; or &ldquo;On/Off&rdquo;. Check Box: In edit mode, a check box will be displayed, while in read-only mode, a check mark or a cross will appear based on the value. REST API # Read format # The format is a boolean value:
&quot;isCustomer&quot;: false Write format # You should provide a boolean:
&quot;isCustomer&quot;: true JavaScript API # Read format # When using the val() method in the wrapper will return a boolean value:
// this will print something like &quot;customer: true&quot; log('customer: '+record.field('isCustomer').val()); Write format # You should provide a boolean to set the value:
record.field('isCustomer').val(true); If you pass null, it will be coerced to false.
Export/Import # Export format # The export format is a string where the value could be either &quot;true&quot; or &quot;false&quot;:
&quot;booleanField1&quot;,&quot;booleanField2&quot; &quot;true&quot;,&quot;false&quot; Import format # The import format supports various representations for true and false:
True values: &quot;true,&quot; &quot;1,&quot; &quot;yes&quot; (case-insensitive) False values: **&quot;false,&quot; &quot;0,&quot; &quot;no&quot; (case-insensitive) &quot;booleanField1&quot;,&quot;booleanField2&quot; &quot;true&quot;,&quot;false&quot; &quot;1&quot;,&quot;0&quot; &quot;yes&quot;,&quot;no&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty no notEmpty no like no greater no greaterOrEquals no less no lessOrEquals no between no currentUserField no Query formats # You should provide the boolean value. For instance:
JS Query MapJS Query BuilderREST API // finds a task with rank &#39;iiiii00000&#39; var records_sample = sys.data.find('companies', {&#39;isCustomer&#39;: true}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds a task with rank &#39;iiiii00000&#39; var query_sample = sys.data.createQuery('companies') .field(&#39;isCustomer&#39;).equals(true) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds a task with rank &#39;iiiii00000&#39; GET /data/contacts?name=true Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals
Strings &quot;true,&quot; &quot;yes,&quot; and &quot;1&quot; are interpreted as the value true, while strings &quot;false,&quot; &quot;no,&quot; and &quot;0&quot; are understood as false. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less no Less or equals no Between no `}),e.add({id:177,href:"/dev-reference/field-types/multiple_choice/choice/",title:"Choice type",description:`Overview # This feature enables you to define a predefined set of values that the field can contain. Within the user interface (UI), the user can select a value from the provided options using a dropdown, list, or switcher, depending on the chosen representation.
Each of the potential values comprises a label and a name, with only the name being stored in the database.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules yes Default display options yes Type rules # Values # These represent the potential values that can be assigned to the field.`,content:`Overview # This feature enables you to define a predefined set of values that the field can contain. Within the user interface (UI), the user can select a value from the provided options using a dropdown, list, or switcher, depending on the chosen representation.
Each of the potential values comprises a label and a name, with only the name being stored in the database.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules yes Default display options yes Type rules # Values # These represent the potential values that can be assigned to the field. For each of these possible values, the following properties are available:
Label: This is the string displayed to the user.
Code: This is the value stored in the database and utilized by the REST and JavaScript APIs.
Color: This denotes the color assigned to the choice. The color chosen is sensitive to the current theme.
Condition: This allows you to define a conditional expression to determine the availability of this option. The available options include:
None: The option will always be available. Expression: The option will be accessible only if the expression evaluates to true. For more information, consult the Expressions documentation. Script: The option will be accessible only when the script evaluates to true. The script&rsquo;s context is as follows: Parameters # Name Type Description record sys.data.Record This refers to the record associated with the operation. If the field is within an entity field, this record will be the one containing the field.
In the case of the field being an action parameter, this record will correspond to the record where the action is being executed. parentField sys.data.Record This variable is only accessible when the field is situated within a nested field, and it is contingent on the source variable being either a record or an action (the same principles apply when it is an action parameter or an entity field).
It is a sys.data.Record object with the distinction that the root of the record is established as the nested fields containing it. This configuration enables you to access fields within the nested group using the syntax parentField.field('fieldA') instead of record.field('nested.fieldA') or action.field('nested.fieldA'). This distinction is particularly valuable when nested fields are multi-valued, as you are not required to ascertain the index. action sys.data.Action This variable will be accessible solely when the field functions as an action parameter. It grants access to other parameters. Returns # boolean - You should return true if the option is available, and false otherwise.
Samples # // option will be available only if 'name' starts with 'test' return !record.field('name').isEmpty() &amp;&amp;record.field('name').val().indexOf('test') == 0; Display options # Representation # This determines how the field should be presented. The available options are:
Dropdown: A dropdown containing the possible values will be displayed. List: A list showing all values will be displayed. Switcher: A switcher displaying all values will be shown. However, if there are numerous possible values, this might not be the optimal representation. REST API # Read format # The format is a string containing the name of the value:
&quot;state&quot;: &quot;active&quot; Write format # To set the value, provide a string containing the name of the value:
&quot;state&quot;: &quot;inactive&quot; JavaScript API # Read format # The val() method within the wrapper will return a string containing the name of the value:
// this will print something like &quot;state: active&quot; log('state: '+record.field('state').val()); The label() method within the wrapper will return a string containing the label of the value:
// this will print something like &quot;state: Active&quot; log('state: ' + record.field('state').label()); Write format # You should provide a string with the name of the value:
record.field('state').val('active'); Wrapper method: label() # The label() method returns the label of the current value or null if no value is set.
Returns # string - The label of the current value.
Samples # // prints the label of the current value of the field var record = sys.data.findOne('tasks', {number: 1}); log('status label: '+record.field('status').label()); Export/Import # Export format # The export format is a string containing the name of the value:
&quot;choiceField1&quot;,&quot;choiceField2&quot; &quot;active&quot;,&quot;inProgress&quot; Import format # The import format is a string containing the name of the value:
&quot;choiceField1&quot;,&quot;choiceField2&quot; &quot;active&quot;,&quot;inProgress&quot; However, it will also accept the label of the value:
&quot;choiceField1&quot;,&quot;choiceField2&quot; &quot;Active&quot;,&quot;In Progress&quot; It will first attempt to match by name. If there is no match, it will then attempt to match using the label. In both cases, the matching process is case-insensitive.
Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater no greaterOrEquals no less no lessOrEquals no between no currentUserField no Query formats # You should provide the a string with the name of value. For instance:
JS Query MapJS Query BuilderREST API // finds active companies var records_sample = sys.data.find('companies', {&#39;state&#39;: &#39;active&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds active companies var query_sample = sys.data.createQuery('companies') .field(&#39;state&#39;).equals(&#39;active&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds active companies GET /data/contacts?state=active Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator like
UI queries will try to match either the label or the name. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less no Less or equals no Between no `}),e.add({id:178,href:"/dev-reference/field-types/miscellaneous_types/color/",title:"Color type",description:`Overview # This field type is designed to store color information. Colors are stored in hexadecimal format, and in the user interface, they are typically displayed as actual colors.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options no REST API # Read format # The format is a simple string with the hexadecimal code of the color:`,content:`Overview # This field type is designed to store color information. Colors are stored in hexadecimal format, and in the user interface, they are typically displayed as actual colors.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options no REST API # Read format # The format is a simple string with the hexadecimal code of the color:
&quot;tagColor&quot;: &quot;#f5a9a9&quot; Write format # When writing a value to a color type field, you should pass a string containing the hexadecimal code of the color. For example:
&quot;tagColor&quot;: &quot;#f5a9a9&quot; JavaScript API # Read format # When using the val() method in the wrapper for a color type field, it will return a string with the hexadecimal code of the color.
// this will print something like &quot;color: #f5a9a9&quot; log('color: '+record.field('tagColor').val()); Write format # When writing a value to a color type field, you should pass a string with the hexadecimal code of the color.
record.field('tagColor').val('#f5a9a9'); Export/Import # Export format # The export format is a simple string with the hex code:
&quot;tagColor&quot; &quot;#f5a9a9&quot; Import format # The import format is a simple string with the hex code:
&quot;tagColor&quot; &quot;#f5a9a9&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater no greaterOrEquals no less no lessOrEquals no between no currentUserField no Query formats # When using the query builder to filter records based on a color type field, you should pass the hexadecimal code of the color as a string. For example:
JS Query MapJS Query BuilderREST API // finds skills with tag color &#39;#f5a9a9&#39; var records_sample = sys.data.find('skills', {&#39;tagColor&#39;: &#39;like(#f5a9a9)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds skills with tag color &#39;#f5a9a9&#39; var query_sample = sys.data.createQuery('skills') .field(&#39;tagColor&#39;).like(&#39;#f5a9a9&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds skills with tag color &#39;#f5a9a9&#39; GET /data/contacts?tagColor=like(#f5a9a9) Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals Available operators # Operator Supported Many values yes Greater no Greater or equals no Less no Less or equals no Between no `}),e.add({id:179,href:"/dev-reference/field-types/date_and_time/",title:"Date and time types",description:"",content:""}),e.add({id:180,href:"/dev-reference/field-types/date_and_time/date-record-created/",title:"Date record created type",description:`Overview # This field type stores the timestamp indicating when the record was created. Once the record is created, this value remains constant and does not change.
The default format for this timestamp is yyyy-MM-dd HH:mm, but you have the flexibility to modify it to a different format.
Available features # Name Supported Many multiplicity no Default values no Unique flag no Required flag no Indexable flag yes Sensitive flag yes Calculated value no Automatic initialization no Calculated initial value yes Aggregation no Default type rules no Default display options yes Display options # Representation # This setting determines the format for displaying both the date and time.`,content:`Overview # This field type stores the timestamp indicating when the record was created. Once the record is created, this value remains constant and does not change.
The default format for this timestamp is yyyy-MM-dd HH:mm, but you have the flexibility to modify it to a different format.
Available features # Name Supported Many multiplicity no Default values no Unique flag no Required flag no Indexable flag yes Sensitive flag yes Calculated value no Automatic initialization no Calculated initial value yes Aggregation no Default type rules no Default display options yes Display options # Representation # This setting determines the format for displaying both the date and time. The default format is yyyy-MM-dd HH:mm, but you can tailor it to a different format.
While there are several common predefined formats available, you also have the flexibility to select &lsquo;Custom&rsquo; and create your own format adhering to the following guidelines:
Era Designator: G (AD) Year: yy (16), yyyy (2016) Month: MMMM (July), MMM (Jul), MM (07) Week in Year: w (27) Day in Year: D (189) Day in Month: d (9), dd (09) Day Name in Week: EEE (Tue), EEEE (Tuesday) AM/PM Marker: a (PM) Hour in 24-hour: H (0), HH (00) Hour in AM/PM: h (1), hh (01) Minute in Hour: m (5), mm (05) Second in Minute: s (9), ss(09) Millisecond: SSS (123) Time Zone: z (-0700), zzzz (-07:00) It is also possible to define a format for the date-time picker.
REST API # Read format # The format represents the number of milliseconds since the Unix Epoch:
&quot;lastUpdate&quot;: 1484578380000 Write format # Fields of this type cannot be manually edited or written to.
JavaScript API # Read format # When utilizing the val() method within the wrapper, it will yield a Date object.
// this will print something like &quot;date: Mon Jan 16 2017 14:53:00 GMT-0000 (UTC)&quot; log('date: '+record.field('lastUpdate').val()); Write format # Fields of this type cannot be manually edited or written to.
Wrapper method: toMillis() # This method returns the date-time in milliseconds since the Unix Epoch.
Returns # number - The time in milliseconds since the Unix Epoch
Samples # // prints the time in milliseconds since the Unix Epoch var company = sys.data.findOne('companies', {name: 'Blogpad'}); log('last update millis: '+company.field('lastUpdate').toMillis()); Wrapper method: format(pattern, timeZoneId) # This function is used to format the date-time into a string. If a format pattern and a time zone ID are provided, they will be applied. Alternatively, if no pattern or time zone ID is given, the default display options of the field will be utilized.
Parameters # Name Type Required Description pattern string no The pattern to format the date-time. Please check the docs for display options to know which are the options to set the format.
If no pattern is provided, the default display options of the field will be used. timeZoneId string no The ID for a time zone. Valid time zone codes are:
- US/Hawaii - US/Alaska - US/Pacific - US/Mountain - US/Central - US/Eastern - Canada/Atlantic - America/Buenos_Aires - See more available Timezones here Returns # string - The formatted date.
Exceptions # badRequest
If pattern or timeZoneId is invalid
Samples # // formats date using 'MM-dd-yyyy HH:mm' pattern var company = sys.data.findOne('companies', {name: 'Blogpad'}); log('last update millis: '+company.field('lastUpdate').format('MM-dd-yyyy HH:mm')); // formats date-time using default display options var company = sys.data.findOne('companies', {name: 'Blogpad'}); log('last update millis: '+company.field('lastUpdate').format()); Export/Import # Export format # The export format is yyyy-MM-dd'T'HH:mm:ss.SSS'Z', with the value being converted to UTC time. This format remains consistent regardless of the display options set for that field.
&quot;recordCreatedField1&quot; &quot;2017-05-14T13:20:05.145Z&quot; The timezone for the export format will always be UTC.
Import Format # Importing record created fields is not supported.
Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # When working with queries, it&rsquo;s essential to provide the time in milliseconds since the Unix Epoch.
JS Query MapJS Query BuilderREST API // finds companies where last meeting is after &#39;1458443760000&#39; which is Sun Mar 20 2016 03:16:00 GMT-0000 (UTC) var records_sample = sys.data.find('companies', {&#39;lastMeeting&#39;:&#39;greater(1458443760000)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies where last meeting is after &#39;1458443760000&#39; which is Sun Mar 20 2016 03:16:00 GMT-0000 (UTC) var query_sample = sys.data.createQuery('companies') .field(&#39;lastMeeting&#39;).greater(1458443760000) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies where last meeting is after &#39;1458443760000&#39; which is Sun Mar 20 2016 03:16:00 GMT-0000 (UTC) GET /data/contacts?lastMeeting=greater(1458443760000) When utilizing the query builder, you have the option to use either a Date object or a string in the format ‘yyyy-MM-dd HH:mm’.
query.field('lastMeeting').less(new Date()); query.field('lastMeeting').less('2016-03-20 03:16'); Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals
UI queries will try to match using the format defined in the default display options of the field. Special values There are some special values you can use:
- now: This translates to the current date and time, effectively representing the current moment.
- today: This denotes a range that encompasses the entirety of the present day.
- yesterday: This signifies a range that covers the entirety of the preceding day.
- tomorrow: This indicates a range that includes the entirety of the following day.
- last hour/day/week/month/year:These ranges include all instances from the last hour, day, week, month, or year, respectively.
- this hour/day/week/month/year:These ranges include all instances from the current hour, day, week, month, or year, respectively.
- last X hours/days/weeks/months/years:These ranges encompass all instances from the last X number of hours, days, weeks, months, or years.
- next X hours/days/weeks/months/years: These ranges encompass all instances from the next X number of hours, days, weeks, months, or years. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between yes `}),e.add({id:181,href:"/dev-reference/field-types/date_and_time/date-record-modified/",title:"Date record modified type",description:`Overview # This field type stores the timestamp indicating the most recent modification of the record. Upon creating the record, this value is initialized.
Manual modification of this field type&rsquo;s value is not permissible. Instead, it is automatically updated whenever the record undergoes modification.
The default timestamp format is yyyy-MM-dd HH:mm, although it is adjustable to an alternative format.
Available features # Name Supported Many multiplicity no Default values no Unique flag no Required flag no Indexable flag yes Sensitive flag yes Calculated value no Automatic initialization no Calculated initial value yes Aggregation no Default type rules no Default display options yes Display options # Representation # This setting determines the format for displaying both the date and time.`,content:`Overview # This field type stores the timestamp indicating the most recent modification of the record. Upon creating the record, this value is initialized.
Manual modification of this field type&rsquo;s value is not permissible. Instead, it is automatically updated whenever the record undergoes modification.
The default timestamp format is yyyy-MM-dd HH:mm, although it is adjustable to an alternative format.
Available features # Name Supported Many multiplicity no Default values no Unique flag no Required flag no Indexable flag yes Sensitive flag yes Calculated value no Automatic initialization no Calculated initial value yes Aggregation no Default type rules no Default display options yes Display options # Representation # This setting determines the format for displaying both the date and time. The default format is yyyy-MM-dd HH:mm, but it can be customized to an alternative format.
While several common predefined formats are available, you also have the option to choose &lsquo;Custom&rsquo; and define your own format following these rules:
Era Designator: G (AD) Year: yy (16), yyyy (2016) Month: MMMM (July), MMM (Jul), MM (07) Week in Year: w (27) Day in Year: D (189) Day in Month: d (9), dd (09) Day Name in Week: EEE (Tue), EEEE (Tuesday) AM/PM Marker: a (PM) Hour in 24-hour: H (0), HH (00) Hour in AM/PM: h (1), hh (01) Minute in Hour: m (5), mm (05) Second in Minute: s (9), ss(09) Millisecond: SSS (123) Time Zone: z (-0700), zzzz (-07:00) It&rsquo;s also possible to define a format for the date-time picker.
REST API # Read format # The format represents the number of milliseconds since the Unix Epoch:
&quot;lastUpdate&quot;: 1484578380000 Write format # Fields of this type cannot be manually edited or written to.
JavaScript API # Read format # When utilizing the val() method within the wrapper, it will yield a Date object.
// this will print something like &quot;date: Mon Jan 16 2017 14:53:00 GMT-0000 (UTC)&quot; log('date: '+record.field('lastUpdate').val()); Write format # Fields of this type cannot be manually edited or written to.
Wrapper Method: toMillis() # This method returns the date-time in milliseconds since the Unix Epoch.
Returns # number - The time in milliseconds since the Unix Epoch
Samples # // prints the time in milliseconds since the Unix Epoch var company = sys.data.findOne('companies', {name: 'Blogpad'}); log('last update millis: '+company.field('lastUpdate').toMillis()); Wrapper method: format(pattern, timeZoneId) # This function is used to format the date-time into a string. If a format pattern and a time zone ID are provided, they will be applied. Alternatively, if no pattern or time zone ID is given, the default display options of the field will be utilized.
Parameters # Name Type Required Description pattern string no The pattern to format the date-time. Please check the docs for display options to know which are the options to set the format.
If no pattern is provided, the default display options of the field will be used. timeZoneId string no The ID for a time zone. Valid time zone codes are:
- US/Hawaii - US/Alaska - US/Pacific - US/Mountain - US/Central - US/Eastern - Canada/Atlantic - America/Buenos_Aires - See more available Timezones here Returns # string - The formatted date.
Exceptions # badRequest
If pattern or timeZoneId is invalid
Samples # // formats date using 'MM-dd-yyyy HH:mm' pattern var company = sys.data.findOne('companies', {name: 'Blogpad'}); log('last update millis: '+company.field('lastUpdate').format('MM-dd-yyyy HH:mm')); // formats date-time using default display options var company = sys.data.findOne('companies', {name: 'Blogpad'}); log('last update millis: '+company.field('lastUpdate').format()); Export/Import # Export format # The export format is yyyy-MM-dd'T'HH:mm:ss.SSS'Z', with the value being converted to UTC time. This format remains consistent regardless of the display options set for that field.
&quot;recordModifiedField&quot; &quot;2017-05-14T13:20:05.145Z&quot; The timezone for the export format will always be UTC.
Import format # Importing record created fields is not supported.
Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # When working with queries, it&rsquo;s essential to provide the time in milliseconds since the Unix Epoch.
JS Query MapJS Query BuilderREST API // finds companies where last meeting is after &#39;1458443760000&#39; which is Sun Mar 20 2016 03:16:00 GMT-0000 (UTC) var records_sample = sys.data.find('companies', {&#39;lastMeeting&#39;:&#39;greater(1458443760000)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies where last meeting is after &#39;1458443760000&#39; which is Sun Mar 20 2016 03:16:00 GMT-0000 (UTC) var query_sample = sys.data.createQuery('companies') .field(&#39;lastMeeting&#39;).greater(1458443760000) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies where last meeting is after &#39;1458443760000&#39; which is Sun Mar 20 2016 03:16:00 GMT-0000 (UTC) GET /data/contacts?lastMeeting=greater(1458443760000) When utilizing the query builder, you have the option to use either a Date object or a string in the format ‘yyyy-MM-dd HH:mm’.
query.field('lastMeeting').less(new Date()); query.field('lastMeeting').less('2016-03-20 03:16'); Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals
UI queries will attempt to match using the format specified in the default display options of the field. Special values There are some special values you can use:
- now: This translates to the current date and time, effectively representing the current moment.
- today: This denotes a range that encompasses the entirety of the present day.
- yesterday: This signifies a range that covers the entirety of the preceding day.
- tomorrow: This indicates a range that includes the entirety of the following day.
- last hour/day/week/month/year:These ranges include all instances from the last hour, day, week, month, or year, respectively.
- this hour/day/week/month/year:These ranges include all instances from the current hour, day, week, month, or year, respectively.
- last X hours/days/weeks/months/years:These ranges encompass all instances from the last X number of hours, days, weeks, months, or years.
- next X hours/days/weeks/months/years: These ranges encompass all instances from the next X number of hours, days, weeks, months, or years. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between yes `}),e.add({id:182,href:"/dev-reference/field-types/date_and_time/date/",title:"Date type",description:`Overview # This type can store a date without including the time; only the date is stored.
The default format is yyyy-MM-dd, but you have the option to customize it as needed.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # Representation # The format used to display the date is customizable.`,content:`Overview # This type can store a date without including the time; only the date is stored.
The default format is yyyy-MM-dd, but you have the option to customize it as needed.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # Representation # The format used to display the date is customizable. The default format is yyyy-MM-dd, but you have the flexibility to modify it to your preferences.
You can choose from predefined formats that are commonly used, or you have the option to define a Custom format based on the following rules:
Era designator: G (AD) Year: yy (16), yyyy (2016) Month: MMMM (July), MMM (Jul), MM (07) Week in year: w (27) Day in year: D (189) Day in month: d (9), dd (09) Day name in week: EEE (Tue), EEEE (Tuesday) REST API # Read format # The format for the date is a string using the yyyy-MM-dd format.
&quot;startDate&quot;: &quot;2016-07-12&quot; Write format # To specify the date, you need to provide a string in the yyyy-MM-dd format.
&quot;startDate&quot;: &quot;2016-07-12&quot; JavaScript API # Read format # When utilizing the val() method within the wrapper, it will yield a Date object.
// this will print something like &quot;date: Sat Jun 15 2013 00:00:00 GMT-0000 (UTC)&quot; log('date: '+record.field('startDate').val()); Since the Date object includes time, it will be set to 00:00 of the time zone of the server. This approach ensures that the date in the field remains unchanged, while the time is uniformly set to 00:00.
Write format # When writing the value, you have the option to either use a Date object or provide a string in the yyyy-MM-dd format.
record.field('startDate').val(new Date()); record.field('startDate').val('2016-07-09'); If the provided value is not valid, the field will be silently set to null.
Wrapper method: addDays(numberOfDays) # This function adds days to the value stored in the field.
Parameters # Name Type Required Description numberOfDays number yes The number of days to add. This value can be either positive or negative. Returns # sys.data.Wrapper - Returns itself.
Exceptions # badRequest
If numberOfDays is not a number.
Samples # // adds 2 days to the start date var company = sys.data.findOne('companies', {name:'Oodoo'}); log('start date: '+company.field('startDate').format()); company.field('startDate').addDays(2); log('start date: '+company.field('startDate').format()); Wrapper method: format(pattern) # This method formats the date into a string. If a format pattern is provided, it will be utilized. Otherwise, the format set in the default display options of the field will be used.
Parameters # Name Type Required Description pattern string no The pattern to format the date. Please refer to the documentation for display options to understand the available format choices.
If no pattern is supplied, the default display options of the field will be utilized. Returns # string - The formatted date.
Exceptions # badRequest
If pattern is invalid
Samples # // formats date using 'MM-dd-yyyy' pattern var company = sys.data.findOne('companies', {name:'Oodoo'}); log('start date: '+company.field('startDate').format('MM-dd-yyyy')); // formats date using default display options var company = sys.data.findOne('companies', {name:'Oodoo'}); log('start date: '+company.field('startDate').format()); Export/Import # Export format # The export format is yyyy-MM-dd, regardless of the display options configured for that field.
&quot;dateField1&quot;,&quot;dateField2&quot; &quot;2017-02-10&quot;,&quot;2017-05-24&quot; Import format # The import format is yyyy-MM-dd, regardless of the display options configured for that field.
&quot;dateField1&quot;,&quot;dateField2&quot; &quot;2017-02-10&quot;,&quot;2017-05-24&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should pass a string with the format yyyy-MM-dd. For example:
JS Query MapJS Query BuilderREST API // finds companies with start date 2016-07-12 var records_sample = sys.data.find('companies', {&#39;startDate&#39;:&#39;2016-07-12&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with start date 2016-07-12 var query_sample = sys.data.createQuery('companies') .field(&#39;startDate&#39;).equals(&#39;2016-07-12&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with start date 2016-07-12 GET /data/contacts?startDate=2016-07-12 When utilizing the query builder, you have can use a Date object.
query.field('startDate').equals(new Date()); Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals
UI queries will attempt to match using the format specified in the default display options of the field. Special values There are some special values you can use:
- now: This translates to the current date and time, effectively representing the current moment.
- today: This denotes a range that encompasses the entirety of the present day.
- yesterday: This signifies a range that covers the entirety of the preceding day.
- tomorrow: This indicates a range that includes the entirety of the following day.
- last hour/day/week/month/year:These ranges include all instances from the last hour, day, week, month, or year, respectively.
- this hour/day/week/month/year:These ranges include all instances from the current hour, day, week, month, or year, respectively.
- last X hours/days/weeks/months/years:These ranges encompass all instances from the last X number of hours, days, weeks, months, or years.
- next X hours/days/weeks/months/years: These ranges encompass all instances from the next X number of hours, days, weeks, months, or years. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between yes `}),e.add({id:183,href:"/dev-reference/field-types/date_and_time/date-time-no-timezone/",title:"Date-Time no timezone type",description:`Overview # This type is capable of storing both date and time, but it doesn&rsquo;t retain any timezone information. As a result, the date and time will appear identical regardless of the user&rsquo;s viewing timezone. For instance, consider an events entity where you desire all users to view event date and time using the event&rsquo;s local timezone; this type would ensure a consistent view for everyone.
The default format is yyyy-MM-dd HH:mm, yet you have the flexibility to customize it as needed.`,content:`Overview # This type is capable of storing both date and time, but it doesn&rsquo;t retain any timezone information. As a result, the date and time will appear identical regardless of the user&rsquo;s viewing timezone. For instance, consider an events entity where you desire all users to view event date and time using the event&rsquo;s local timezone; this type would ensure a consistent view for everyone.
The default format is yyyy-MM-dd HH:mm, yet you have the flexibility to customize it as needed.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # Representation # This defines the format for displaying the date and time. The default format is yyyy-MM-dd HH:mm, but you have the flexibility to customize it to suit your needs.
There exist several predefined formats that are commonly used. Additionally, you have the option to choose &ldquo;Custom&rdquo; and define a format according to the following rules:
Era designator: G (AD) Year: yy (16), yyyy (2016) Month: MMMM (July), MMM (Jul), MM (07) Week in year: w (27) Day in year: D (189) Day in month: d (9), dd (09) Day name in week: EEE (Tue), EEEE (Tuesday) Am/pm marker: a (PM) Hour in 24h: H (0), HH (00) Hour in am/pm: h (1), hh (01) Minute in hour: m (5), mm (05) Second in minute: s (9), ss(09) Millisecond: SSS (123) Furthermore, you can also define a format for the date-time picker as needed.
REST API # Read format # The format is a string with the format yyyy-MM-dd HH:mm:
&quot;eventDateTime&quot;: &quot;2016-11-05 19:00&quot; Write format # You should pass a string in the format yyyy-MM-dd HH:mm:
&quot;eventDateTime&quot;: &quot;2016-11-05 19:00&quot; JavaScript API # Read format # The val() method in the wrapper will return a Date object.
// this will print something like &quot;date: Mon Jan 16 2017 14:53:00 GMT-0000 (UTC)&quot; log('date: '+record.field('eventDateTime').val()); Keep in mind that the Date object does have a timezone. The date and time will be set according to what&rsquo;s stored in the field&rsquo;s default timezone.
Write format # When writing the value, you can use either a Date object, a string with the format yyyy-MM-dd HH:mm, or milliseconds since the Epoch:
record.field('eventDateTime').val(new Date()); record.field('eventDateTime').val('2016-07-09 11:00'); If the value is not valid, the field will be set to null silently.
Additionally, please keep in mind that when you use a Date object, the timezone information will be lost.
Wrapper Method: format(pattern) # Formats the date-time to a string. If a format pattern is given, it will be used. Otherwise, the format set in the default display options of the field will be used.
Parameters # Name Type Required Description pattern string no The pattern to format the date-time. Please check the documentation for display options to know which options are available for setting the format.
If no pattern is provided, the default display options of the field will be used. Returns # string - The formatted date.
Exceptions # badRequest
If pattern is invalid
Samples # // formats date using 'MM-dd-yyyy HH:mm' pattern var company = sys.data.findOne('companies', {name: 'Blogpad'}); log('last update millis: '+company.field('lastUpdate').format('MM-dd-yyyy HH:mm')); // formats date-time using default display options var company = sys.data.findOne('companies', {name: 'Blogpad'}); log('last update millis: '+company.field('lastUpdate').format()); Export/Import # Export format # The export format is yyyy-MM-dd HH:mm, regardless of the display options configured for that field.
&quot;dateField1&quot;,&quot;dateField2&quot; &quot;2017-05-14 13:20&quot;,&quot;2015-07-14 08:20&quot; Import format # The import format is yyyy-MM-dd HH:mm, regardless of the display options configured for that field.
&quot;dateField1&quot;,&quot;dateField2&quot; &quot;2017-05-14 13:20&quot;,&quot;2015-07-14 08:20&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should pass a string with the format yyyy-MM-dd HH:mm. For example:
JS Query MapJS Query BuilderREST API // finds companies with start date 2016-07-12 var records_sample = sys.data.find('companies', {&#39;eventDateTime&#39;: &#39;greater(2016-11-05 11:00)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with start date 2016-07-12 var query_sample = sys.data.createQuery('companies') .field(&#39;eventDateTime&#39;).greater(&#39;2016-11-05 11:00&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with start date 2016-07-12 GET /data/contacts?eventDateTime=greater(2016-11-05 11:00) When using the query builder, you can use a Date object or a string in the format 'yyyy-MM-dd HH:mm':
query.field('eventDateTime').less(new Date()); query.field('eventDateTime').less('2016-03-20 03:16'); Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals
UI queries will attempt to match using the format specified in the default display options of the field. Special values There are some special values you can use:
- now: This translates to the current date and time, effectively representing the current moment.
- today: This denotes a range that encompasses the entirety of the present day.
- yesterday: This signifies a range that covers the entirety of the preceding day.
- tomorrow: This indicates a range that includes the entirety of the following day.
- last hour/day/week/month/year:These ranges include all instances from the last hour, day, week, month, or year, respectively.
- this hour/day/week/month/year:These ranges include all instances from the current hour, day, week, month, or year, respectively.
- last X hours/days/weeks/months/years:These ranges encompass all instances from the last X number of hours, days, weeks, months, or years.
- next X hours/days/weeks/months/years: These ranges encompass all instances from the next X number of hours, days, weeks, months, or years. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between yes `}),e.add({id:184,href:"/dev-reference/field-types/date_and_time/date-time/",title:"Date-Time type",description:`Overview # This type can store both date and time information.
The default format is yyyy-MM-dd HH:mm, but you can customize it to another format.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # Representation # This determines the format for displaying the date and time.`,content:`Overview # This type can store both date and time information.
The default format is yyyy-MM-dd HH:mm, but you can customize it to another format.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # Representation # This determines the format for displaying the date and time. The default format is yyyy-MM-dd HH:mm, but you can modify it according to your preferences.
You have the option to choose from several predefined formats that are commonly used. However, you can also opt for a Custom format and create your own pattern based on the following guidelines:
Era designator: G (AD) Year: yy (16), yyyy (2016) Month: MMMM (July), MMM (Jul), MM (07) Week in year: w (27) Day in year: D (189) Day in month: d (9), dd (09) Day name in week: EEE (Tue), EEEE (Tuesday) Am/pm marker: a (PM) Hour in 24h: H (0), HH (00) Hour in am/pm: h (1), hh (01) Minute in hour: m (5), mm (05) Second in minute: s (9), ss(09) Millisecond: SSS (123) Time zone: z (-0700), zzzz (-07:00) You also have the flexibility to define a format for the date-time picker to suit your needs.
REST API # Read format # The value of this type is represented as the number of milliseconds since the Epoch.
&quot;lastUpdate&quot;: 1484578380000 Write format # When writing the value for this type, you should provide the number of milliseconds since the Epoch.
&quot;lastUpdate&quot;: 1484578380000 JavaScript API # Read format # When utilizing the val() method within the wrapper, it will yield a Date object.
// this will print something like &quot;date: Mon Jan 16 2017 14:53:00 GMT-0000 (UTC)&quot; log('date: '+record.field('lastUpdate').val()); Write format # When writing the value for this type, you have multiple options:
You can use a Date object. You can use a string with the format yyyy-MM-dd HH:mm. You can provide the number of milliseconds since the Epoch. record.field('startDate').val(new Date()); record.field('startDate').val('2016-07-09'); If the value provided is not valid, the field will be set to null silently.
Wrapper ethod: toMillis() # This method returns the date-time in milliseconds since the Unix Epoch.
Returns # number - The time in milliseconds since the Unix Epoch
Samples # // prints the time in milliseconds since the Unix Epoch var company = sys.data.findOne('companies', {name: 'Blogpad'}); log('last update millis: '+company.field('lastUpdate').toMillis()); Wrapper method: format(pattern, timeZoneId) # This function is used to format the date-time into a string. If a format pattern and a time zone ID are provided, they will be applied. Alternatively, if no pattern or time zone ID is given, the default display options of the field will be utilized.
Parameters # Name Type Required Description pattern string no The pattern to format the date-time. Please check the docs for display options to know which are the options to set the format.
If no pattern is provided, the default display options of the field will be used. timeZoneId string no The ID for a time zone. Valid time zone codes are:
- US/Hawaii - US/Alaska - US/Pacific - US/Mountain - US/Central - US/Eastern - Canada/Atlantic - America/Buenos_Aires - See more available Timezones here Returns # string - The formatted date.
Exceptions # badRequest
If pattern or timeZoneId is invalid
Samples # // formats date using 'MM-dd-yyyy HH:mm' pattern var company = sys.data.findOne('companies', {name: 'Blogpad'}); log('last update millis: '+company.field('lastUpdate').format('MM-dd-yyyy HH:mm')); // formats date-time using default display options var company = sys.data.findOne('companies', {name: 'Blogpad'}); log('last update millis: '+company.field('lastUpdate').format()); Export/Import # Export format # The export format for this field is yyyy-MM-dd'T'HH:mm:ss.SSS'Z'. The value is converted to UTC time for export, regardless of the display options set for that field.
&quot;dateTimeField1&quot;,&quot;dateTimeField2&quot; &quot;2017-05-14T13:20:01.014Z&quot;,&quot;2015-07-14T08:20:00.000Z&quot; The timezone for this field will always be UTC. Regardless of the display options or input values, the field will store and handle the date and time in Coordinated Universal Time (UTC).
Import format # When importing data into this field, the expected format is yyyy-MM-dd'T'HH:mm:ss.SSS'Z'. This format represents the date and time in Coordinated Universal Time (UTC), regardless of the display options set for the field. The imported value will be converted to UTC time.
&quot;dateTimeField1&quot;,&quot;dateTimeField2&quot; &quot;2017-05-14T13:20:01.014Z&quot;,&quot;2015-07-14T08:20:00.000Z&quot; The timezone for this field will always be UTC. Regardless of the display options or input values, the field will store and handle the date and time in Coordinated Universal Time (UTC).
Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # When working with queries, it&rsquo;s essential to provide the time in milliseconds since the Unix Epoch.
JS Query MapJS Query BuilderREST API // finds companies where last meeting is after &#39;1458443760000&#39; which is Sun Mar 20 2016 03:16:00 GMT-0000 (UTC) var records_sample = sys.data.find('companies', {&#39;lastMeeting&#39;:&#39;greater(1458443760000)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies where last meeting is after &#39;1458443760000&#39; which is Sun Mar 20 2016 03:16:00 GMT-0000 (UTC) var query_sample = sys.data.createQuery('companies') .field(&#39;lastMeeting&#39;).greater(1458443760000) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies where last meeting is after &#39;1458443760000&#39; which is Sun Mar 20 2016 03:16:00 GMT-0000 (UTC) GET /data/contacts?lastMeeting=greater(1458443760000) When utilizing the query builder, you have the option to use either a Date object or a string in the format ‘yyyy-MM-dd HH:mm’.
query.field('lastMeeting').less(new Date()); query.field('lastMeeting').less('2016-03-20 03:16'); Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals
UI queries will attempt to match using the format specified in the default display options of the field. Special values There are some special values you can use:
- now: This translates to the current date and time, effectively representing the current moment.
- today: This denotes a range that encompasses the entirety of the present day.
- yesterday: This signifies a range that covers the entirety of the preceding day.
- tomorrow: This indicates a range that includes the entirety of the following day.
- last hour/day/week/month/year:These ranges include all instances from the last hour, day, week, month, or year, respectively.
- this hour/day/week/month/year:These ranges include all instances from the current hour, day, week, month, or year, respectively.
- last X hours/days/weeks/months/years:These ranges encompass all instances from the last X number of hours, days, weeks, months, or years.
- next X hours/days/weeks/months/years: These ranges encompass all instances from the next X number of hours, days, weeks, months, or years. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between yes `}),e.add({id:185,href:"/dev-reference/field-types/number/decimal/",title:"Decimal type",description:`Overview # This type is designed to store decimal numbers and offers options for rounding and specifying the number of decimals.
As of now, this type does not support more than 4 decimals. However, this limitation is expected to be addressed in the near future.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation yes Default type rules yes Default display options yes Type rules # Minimum value # The minimum value (inclusive).`,content:`Overview # This type is designed to store decimal numbers and offers options for rounding and specifying the number of decimals.
As of now, this type does not support more than 4 decimals. However, this limitation is expected to be addressed in the near future.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation yes Default type rules yes Default display options yes Type rules # Minimum value # The minimum value (inclusive).
Maximum value # The maximum value (inclusive).
Limit decimals # This feature enables the limitation of the number of decimals. This limitation will be applied at the data level, meaning numbers will be stored in the database with the specified number of decimals, and any additional decimals will be discarded. If you wish to retain the additional decimals for display purposes while limiting their storage, you should configure these settings within the display options.
When you opt to limit the number of decimals, the following choices will be presented:
Number of Decimals: This indicates the number of decimals to be stored. It can range from 0 to 4.
Extra Decimals Action: This specifies the action to take when there are more decimals than the limit permits. The available options include:
Round: Rounding will be used to limit the decimals. Truncate: Truncation will be applied to the trailing decimals. Throw Error: An error will be triggered if an attempt is made to set more decimals than the allowable limit. Display options # Show Thousands Separator: If this flag is enabled, the thousands separator will be displayed in read-only mode. Please note that this flag does not impact edit mode.
Limit Number of Decimals: This feature permits the restriction of the displayed decimals. It operates at the UI level and does not affect validation rules or the storage of numbers in the database. Consequently, these options only apply to read-only mode.
When you choose to limit the number of decimals, the following choices will be available:
Number of Decimals: This denotes the count of decimals to be shown. It can range from 0 to 4.
Extra Decimals Action: This specifies the action to be taken when there are more decimals than the set limit. The available options include:
Round: Rounding will be employed to limit the decimals. Truncate: Truncation will be applied to the trailing decimals. REST API # Read format # The format is a decimal number:
&quot;rating&quot;: 3.2 Write format # To set the value, provide the decimal number:
&quot;rating&quot;: 4.5 JavaScript API # Read format # The val() method within the wrapper will return an instance of a decimal number:
// this will print something like &quot;rating: 2.5&quot; log('rating: '+record.field('rating').val()); Write format # To set the value, provide a decimal number:
record.field('raiting').val(4.5); If you provide something that isn’t a number, the field will be set to null.
Wrapper method: toHex() # The toHex() method returns string of hexadecimal representation of the value or empty ('') if null.
Returns # string - Hex value of number.
Samples # // prints the hex value of a decimal field var record = sys.data.findOne('companies', {name: 'ABC'}); sys.logs.debug('company rating hex: '+record.field('rating').toHex()); Wrapper method: format(options) # Returns a string representing the formatted number value or an unformatted string.
Parameters # Name Type Required Description options object no These parameters are used to format the value. If left empty, the default display options will be used for formatting.
- thousandsSeparator: If set to &ldquo;true,&rdquo; a thousands separator will be displayed; if set to &ldquo;false,&rdquo; it won&rsquo;t.
- limitNumberOfDecimals: If set to &ldquo;true,&rdquo; the number of decimals will be limited; if set to &ldquo;false,&rdquo; it won&rsquo;t.
- numberOfDecimals: The count of decimals to be displayed. Default is 2.
- limitRuleType: The rule to use when limiting decimals, either &ldquo;TRUNCATE&rdquo; or &ldquo;ROUND.&rdquo; Default is &ldquo;TRUNCATE.&rdquo; Returns # string - String of formatted value of number.
Samples # // prints the formated value of a decimal field var inv = sys.data.findById('invoices', '579f5929e4b043b8ce4519b6'); sys.logs.debug('total: ' + inv.field('total').format({ 'thousandsSeparator': true, 'limitNumberOfDecimals': true, 'numberOfDecimals': 2 }) ); Export/Import # Export format # The export format is a decimal number:
&quot;decimalField1&quot;,&quot;decimalField2&quot; &quot;0.872&quot;,&quot;27810.0028&quot; Import format # The import format is a string with a decimal number:
&quot;decimalField1&quot;,&quot;decimalField2&quot; &quot;0.872&quot;,&quot;27810.0028&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should provide the number. For instance:
JS Query MapJS Query BuilderREST API // finds companies with rating grater or equals than 3.0 var records_sample = sys.data.find('companies', {&#39;rating&#39;: &#39;greaterOrEquals(3.0)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with rating grater or equals than 3.0 var query_sample = sys.data.createQuery('companies') .field(&#39;rating&#39;).greaterOrEquals(&#39;3.0&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with rating grater or equals than 3.0 GET /data/contacts?rating=greaterOrEquals(3.0) Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum yes avg yes first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between yes `}),e.add({id:186,href:"/dev-reference/field-types/multiple_choice/dynamic-choice/",title:"Dynamic choice type",description:"Overview # This feature enables the specification of a set of potential dynamic values that the field can accommodate. Within the user interface (UI), users can select a value from these options using a dropdown, list, box, or switcher, depending on the chosen representation. The key distinction from standard choices lies in the inability to configure the potential values during the app builder&rsquo;s field configuration process. Instead, the potential values can be defined using the JavaScript API, typically in events like &quot;before show&quot; or &quot;on record change.",content:`Overview # This feature enables the specification of a set of potential dynamic values that the field can accommodate. Within the user interface (UI), users can select a value from these options using a dropdown, list, box, or switcher, depending on the chosen representation. The key distinction from standard choices lies in the inability to configure the potential values during the app builder&rsquo;s field configuration process. Instead, the potential values can be defined using the JavaScript API, typically in events like &quot;before show&quot; or &quot;on record change.&quot; Consequently, this field can possess varying potential values (and a distinct selected value) based on the current status of the record, the user, or any other condition.
It&rsquo;s important to note that the raw value of the field will store all potential values along with the currently selected value.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag no Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # Representation # This determines how the field should be presented. The available options are:
Dropdown: A dropdown containing the potential values will be displayed. List: A list showcasing all values will be displayed. Switcher: A switcher displaying all values will be shown. However, if there are numerous potential values, this might not be the optimal representation. Boxes: All records that can be chosen as the field&rsquo;s value will be exhibited in boxes, simplifying user selection. This representation should only be used when the number of potential options is limited. Note that this representation supports a maximum of 100 records. REST API # Read format # The format is a JSON containing the name of the value and the possible options for the selected value:
{ &quot;options&quot;: [{ &quot;label&quot;: &quot;Alabama&quot;, &quot;name&quot;: &quot;AL&quot; }, { &quot;label&quot;: &quot;Alaska&quot;, &quot;name&quot;: &quot;AK&quot; }, { &quot;label&quot;: &quot;Arizona&quot;, &quot;name&quot;: &quot;AZ&quot; }], &quot;selectedValue&quot;: &quot;AZ&quot; } Write format # To set the value, provide a JSON with the selected value&rsquo;s name and the possible values as options:
record.field('dynamicChoice').val({ &quot;options&quot;: [{ &quot;label&quot;: &quot;Alabama&quot;, &quot;name&quot;: &quot;AL&quot; }, { &quot;label&quot;: &quot;Alaska&quot;, &quot;name&quot;: &quot;AK&quot; }, { &quot;label&quot;: &quot;Arizona&quot;, &quot;name&quot;: &quot;AZ&quot; }], &quot;selectedValue&quot;: &quot;AZ&quot; }); If you provide only a string, it will be considered as the selected value, and the possible values will be automatically generated with a single option using the provided string as both the name and label:
record.field('dynamicChoice').val('AZ'); { &quot;options&quot;: [{ &quot;label&quot;: &quot;AZ&quot;, &quot;name&quot;: &quot;AZ&quot; }], &quot;selectedValue&quot;: &quot;AZ&quot; } JavaScript API # Read format # The val() method within the wrapper will return a JSON containing the selected value&rsquo;s name as well as the possible values as options:
// this will print something like // &quot;state: {options: [{label: Alabama, name: AL}, {label: Alaska, name: AK},{label: Arizona, name: AZ}], selectedValue: AZ}&quot; log('state: ' + JSON.stringify(record.field('state').val())); The selectedValue() method within the wrapper will return a string containing the name of the value or null if no value is set.
// this will print something like &quot;state: AZ&quot; log('state: ' + record.field('state').selectedValue()); The selectedLabel() method within the wrapper will return a string with the label of the selected value or null if no value is set.
// this will print something like &quot;state: Arizona&quot; log('state: ' + record.field('state').selectedLabel()); The options() method within the wrapper will return an array with the potential options for the value.
// this will print something like // &quot;state options: [{&quot;label&quot;: &quot;Alabama&quot;, &quot;name&quot;: &quot;AL&quot;},{&quot;label&quot;: &quot;Alaska&quot;, &quot;name&quot;: &quot;AK&quot;},{&quot;label&quot;: &quot;Arizona&quot;, &quot;name&quot;: &quot;AZ&quot;}]&quot; log('state options: ' + JSON.stringify(record.field('state').options())); Write format # For val(), you can provide a JSON with the selected value&rsquo;s name and an array containing the potential values as options:
record.field('state').val( { &quot;options&quot;: [{ &quot;label&quot;: &quot;Alabama&quot;, &quot;name&quot;: &quot;AL&quot; }, { &quot;label&quot;: &quot;Alaska&quot;, &quot;name&quot;: &quot;AK&quot; }, { &quot;label&quot;: &quot;Arizona&quot;, &quot;name&quot;: &quot;AZ&quot; }], &quot;selectedValue&quot;: &quot;AZ&quot; } ); You can also pass a string, and it will be interpreted as the selectedValue:
record.field('state').val(&quot;AZ&quot;); //this value will be converted to {&quot;options&quot;: [{&quot;label&quot;: &quot;AZ&quot;, &quot;name&quot;: &quot;AZ&quot;}], &quot;selectedValue&quot;: &quot;AZ&quot;} The selectedValue() method within the wrapper will save a selected value and return a string containing the name of the value:
// this will save the name option &quot;AZ&quot; as selected value record.field('state').selectedValue('AZ'); The options() method within the wrapper will store the potential options for the value:
// this will save the options to be used as possible values: record.field('state').options([{ &quot;label&quot;: &quot;Alabama&quot;, &quot;name&quot;: &quot;AL&quot; },{ &quot;label&quot;: &quot;Alaska&quot;, &quot;name&quot;: &quot;AK&quot; },{ &quot;label&quot;: &quot;Arizona&quot;, &quot;name&quot;: &quot;AZ&quot; }] ); Wrapper method: selectedLabel() # Returns the label of the current value or null if no value is set.
Returns # string - The label of the current value.
Samples # // prints the label of the current value of the field // this will print something like &quot;state: Arizona&quot; log('state: ' + record.field('state').selectedLabel()); Wrapper method: selectedValue(newValue) # Returns the name of the current value or null if no value is set.
Parameters # Name Type Required Description newValue string no The new value to be selected. Returns # string - The name of the current value.
Samples # // prints the name of the current value of the field // this will print something like &quot;state: AZ&quot; log('state: ' + record.field('state').selectedValue()); // this will set &quot;AL&quot; as selected value and it will print something like &quot;state: AL&quot; log('state: ' + record.field('state').selectedValue('AL')); Wrapper method: options(newOptions) # Returns an array with the possible options for the value.
Parameters # Name Type Required Description newOptions object[] no The new possible options for the value. Returns # object[] - The possible options for the value.
Samples # // prints the possible options // this will print something like // &quot;state options: [{&quot;label&quot;: &quot;Alabama&quot;, &quot;name&quot;: &quot;AL&quot;},{&quot;label&quot;: &quot;Alaska&quot;, &quot;name&quot;: &quot;AK&quot;},{&quot;label&quot;: &quot;Arizona&quot;, &quot;name&quot;: &quot;AZ&quot;}]&quot; log('state options: ' + JSON.stringify(record.field('state').options())); // this will save the options to be used as possible values: record.field('state').options([{ &quot;label&quot;: &quot;Alabama&quot;, &quot;name&quot;: &quot;AL&quot; },{ &quot;label&quot;: &quot;Alaska&quot;, &quot;name&quot;: &quot;AK&quot; },{ &quot;label&quot;: &quot;Arizona&quot;, &quot;name&quot;: &quot;AZ&quot; } ]); Export/Import # Export format # The export format is a string representation of a JSON with the name of the selected value and its possible values as options:
&quot;{options: [{label: Alabama, name: AL}, {label: Alaska, name: AK},{label: Arizona, name: AZ}], selectedValue: AZ}&quot; Import format # The import format is a string representation of a JSON with the name of the selected value and its possible values as options:
&quot;{options: [{label: Alabama, name: AL}, {label: Alaska, name: AK},{label: Arizona, name: AZ}], selectedValue: AZ}&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like yes greater no greaterOrEquals no less no lessOrEquals no between no currentUserField no Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first no last no min no max no UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator like
UI queries will try to match either the label or the name. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less no Less or equals no Between no `}),e.add({id:187,href:"/dev-reference/field-types/text/email/",title:"Email type",description:`Overview # This field type is designed to store email addresses, such as &quot;user@test.com.&quot; The field will be displayed as a mailto link.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options no REST API # Read format # The format is a straightforward string containing the email:`,content:`Overview # This field type is designed to store email addresses, such as &quot;user@test.com.&quot; The field will be displayed as a mailto link.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options no REST API # Read format # The format is a straightforward string containing the email:
&quot;contactInformation&quot;: { &quot;email&quot;: &quot;user@test.com&quot; } Write format # You should provide a string containing the email:
&quot;contactInformation&quot;: { &quot;email&quot;: &quot;user@test.com&quot; } JavaScript API # Read format # The val() method within the wrapper will return a plain string with the email address:
// this will print something like &quot;email: user@test.com&quot; log('email: '+record.field('contactInformation.email').val()); Write format # To set the value, you should provide a plain string containing the email:
record.field('contactInformation.email').val('user@test.com'); Export/Import # Export format # The export format is a simple string with the email:
&quot;emailField1&quot;,&quot;emailField2&quot; &quot;user1@test.com&quot;,&quot;user2@test.com&quot; Import format # The import format is a simple string with the email:
&quot;emailField1&quot;,&quot;emailField2&quot; &quot;user1@test.com&quot;,&quot;user2@test.com&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like yes greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should provide the email as a plain string. For example:
JS Query MapJS Query BuilderREST API // finds companies with contact email like &#39;test&#39; var records_sample = sys.data.find('companies', {&#39;contactInformation.email&#39;: &#39;like(test)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with contact email like &#39;test&#39; var query_sample = sys.data.createQuery('companies') .field(&#39;contactInformation.email&#39;).like(&#39;test&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with contact email like &#39;test&#39; GET /data/contacts?contactInformation.email=like(test) Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator like Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between no `}),e.add({id:188,href:"/dev-reference/field-types/references/file/",title:"File type",description:`Overview # This type enables the storage of references to files. The UI and APIs also facilitate file uploads using this field.
Available features # Name Supported Many multiplicity yes Default values no Unique flag no Required flag yes Indexable flag no Sensitive flag yes Calculated value no Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # Enable preview # If this flag is enabled, a button to preview the file will be displayed in the UI.`,content:`Overview # This type enables the storage of references to files. The UI and APIs also facilitate file uploads using this field.
Available features # Name Supported Many multiplicity yes Default values no Unique flag no Required flag yes Indexable flag no Sensitive flag yes Calculated value no Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # Enable preview # If this flag is enabled, a button to preview the file will be displayed in the UI. Otherwise, the only available option will be to download the file.
REST API # Read format # It&rsquo;s a JSON with the following fields:
id: This is the ID of the referenced file. name: This is the name of the referenced file. It might include the size as well. Sample user field in JSON format:
&quot;file&quot;: { &quot;id&quot;: &quot;58866b5d3b063a0007604eab&quot;, &quot;name&quot;: &quot;logo.png (41.5kB)&quot; } Write format # You can provide only the ID and avoid the name field:
&quot;file&quot;: {&quot;id&quot;: &quot;57fe52ade4b0ce322b0cea32&quot;} You can also provide the ID directly as a string:
&quot;file&quot;: &quot;57fe52ade4b0ce322b0cea32&quot; Finally you can provide the file encoded in Base 64 and it will be uploaded:
&quot;file&quot;: { &quot;name&quot;: &quot;test1.txt&quot;, &quot;contentType&quot;: &quot;text/plain&quot;, &quot;content&quot;: &quot;dGVzdCBmaWxlIQ==&quot; } Where:
name: This is the name of the file. contentType: This is the content type of the file. content: This is the content of the file encoded in Base 64. JavaScript API # Read format # The val() method within the wrapper will return an object:
{ &quot;id&quot;: &quot;58866b5d3b063a0007604eab&quot;, &quot;name&quot;: &quot;logo.png (41.5kB)&quot; } Where:
id: This is the ID of the referenced file. name: This is the name of the referenced file. It might include the size of the file. However, in most cases, instead of obtaining the raw value of the relationship, you will use the methods available in the wrapper to directly access the ID or the full name.
Write format # There are several ways to pass the value of a user in the JavaScript API.
You can pass only the ID:
record.field(&quot;file&quot;).val({id: &quot;58866b5d3b063a0007604eab&quot;}); You can also pass the ID directly as a string:
record.field(&quot;file&quot;).val(&quot;58866b5d3b063a0007604eab&quot;); The Javascript API also allows to set a user wrapper like this:
file1.field('file').val(file2.field('file')); Or you can pass a new file that will be created:
var file = sys.data.createRecord('files'); file.field('code').val('test-b'); file.field('file').val({ name: 'test1.txt', contentType: 'text/plain', content: 'dGVzdCBmaWxlIQ==' }); sys.data.save(file); Wrapper method: id() # The id() method returns the ID of the referenced file or null if the field is empty.
Returns # string - The ID of the referenced file.
Samples # // prints the ID of attachements of a task var record = sys.data.findOne('tasks', {number: 1}); record.field('attachments').each(function(attachment) { log('file id: '+attachment.id()); }); Wrapper method: name() # The name() method returns the name of the referenced file or null if the field is empty.
Returns # string - The name of the referenced file.
Samples # // prints the name of attachments of a task var record = sys.data.findOne('tasks', {number: 1}); record.field('attachments').each(function(attachment) { log('file name: '+attachment.name()); }); Wrapper method: name(name) # Sets the name of the file. This only works if you are uploading a new file, otherwise an exception will be thrown.
Parameters # Name Type Required Description name string yes The name of the file. Exceptions # badRequests If the file already exists
Samples # // adds a new attachment to a task var record = sys.data.findOne('tasks', {number: 1}); record.field('attachments[1]').name('test1.txt'); record.field('attachments[1]').contentType('text/plain'); record.field('attachments[1]').content('dGVzdCBmaWxlIQ=='); record = sys.data.save(record); log('file id: '+record.field('attachments').last().id()); Wrapper method: hash() # Returns the hash code of the referenced file.
Returns # string - The hash code of the referenced file.
Samples # // prints the hash of attachements of a task var record = sys.data.findOne('tasks', {number: 1}); record.field('attachments').each(function(attachment) { log('file hash: '+attachment.hash()); }); Wrapper method: contentType() # Returns the content type of the referenced file or null if the field is empty.
Returns # string - The content type of the referenced file.
Samples # // prints the content type of attachments of a task var record = sys.data.findOne('tasks', {number: 1}); record.field('attachments').each(function(attachment) { log('content type: '+attachment.contentType()); }); Wrapper method: contentType(contentType) # Sets the content type of the file. This only works if you are uploading a new file, otherwise an exception will be thrown.
Parameters # Name Type Required Description contentType string yes The content type of the file. Exceptions # badRequest If the file already exists.
Samples # // adds a new attachment to a task var record = sys.data.findOne('tasks', {number: 1}); record.field('attachments[1]').name('test1.txt'); record.field('attachments[1]').contentType('text/plain'); record.field('attachments[1]').content('dGVzdCBmaWxlIQ=='); record = sys.data.save(record); log('file id: '+record.field('attachments').last().id()); Wrapper method: content() # Returns the content of the file encoded in Base 64. If the file is bigger than 10MB this method will throw an exception.
Returns # string - The content of the referenced file encoded in Base 64.
Exceptions # badRequest If the content of the file is bigger than 10MB.
Samples # // prints the content of attachments of a task var record = sys.data.findOne('tasks', {number: 1}); record.field('attachments').each(function(attachment) { log('content in base 64: '+attachment.content()); }); Wrapper method: content(content) # Sets the content type of the file (it should be encoded in Base 64). This only works if you are uploading a new file, otherwise an exception will be thrown.
Parameters # Name Type Required Description content string yes The content of the file in Base 64. Exceptions # badRequest If the file already exists.
Samples # // adds a new attachment to a task var record = sys.data.findOne('tasks', {number: 1}); record.field('attachments[1]').name('test1.txt'); record.field('attachments[1]').contentType('text/plain'); record.field('attachments[1]').content('dGVzdCBmaWxlIQ=='); record = sys.data.save(record); log('file id: '+record.field('attachments').last().id()); Wrapper method: size() # Returns the size of the file in bytes.
Returns # number - The size of the referenced file.
Samples # // prints the size of attachments of a task var record = sys.data.findOne('tasks', {number: 1}); record.field('attachments').each(function(attachment) { log('file size: '+attachment.size()); }); Wrapper method: link() # Returns an absolute URL of the file.
Returns # string - The URL of the referenced file.
Samples # // prints the url of attachments of a task var record = sys.data.findOne('tasks', {number: 1}); record.field('attachments').each(function(attachment) { log('file url: ' + attachment.link()); }); Export/Import # Export format # The export format is the name of the file:
&quot;fileField1&quot;,&quot;fileField2&quot; &quot;logo.png (4kB)&quot;,&quot;data.zip (41.5kB)&quot; Import format # It is not possible to import file fields.
Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like yes greater no greaterOrEquals no less no lessOrEquals no between no currentUserField no Query formats # By default, the file name will be used for the various query operators.
For example, to query tasks with an attachment where the name is similar to 'logo.png'. We use 'like' because the name can include the file size, so using 'equals' might not yield the expected results:
JS Query MapJS Query BuilderREST API // finds a task with attachment &#39;logo.png&#39; var records_sample = sys.data.find('tasks', {attachments: &#39;like(logo.png)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds a task with attachment &#39;logo.png&#39; var query_sample = sys.data.createQuery('tasks') .field(&#39;attachments&#39;).like(&#39;logo.png&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds a task with attachment &#39;logo.png&#39; GET /data/contacts?attachments=like(logo.png) You could also query by the ID:
JS Query MapJS Query BuilderREST API // finds a task by attachment&#39;s ID var records_sample2 = sys.data.find('tasks', {&#39;attachments.id&#39;: &#39;58866b5d3b063a0007604eab&#39;}); log('total: '+records_sample2.count()); while (records_sample2.hasNext()) { log(records_sample2.next().label()); } // finds a task by attachment&#39;s ID var query_sample2 = sys.data.createQuery('tasks') .field(&#39;attachments&#39;).equals(&#39;58866b5d3b063a0007604eab&#39;) var records_sample2 = sys.data.find(query_sample2); log('total: '+records_sample2.count()); while (records_sample2.hasNext()) { log(records_sample2.next().label()); } // finds a task by attachment&#39;s ID GET /data/contacts?attachments.id=58866b5d3b063a0007604eab Notice again that the query builder will automatically detect the ID, so you don&rsquo;t need to use the 'id' suffix there.
Remember that when using the query builder, you can utilize any of the formats available in the JavaScript API.
Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min no max no UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator like
The name of the referenced file will be used for matching. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less no Less or equals no Between no `}),e.add({id:189,href:"/dev-reference/field-types/references/group/",title:"Group type",description:`Overview # This field type enables the referencing of a group within the application.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules yes Default display options no Type rules # Filtering # This feature allows you to specify which groups can be assigned in this field.`,content:`Overview # This field type enables the referencing of a group within the application.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules yes Default display options no Type rules # Filtering # This feature allows you to specify which groups can be assigned in this field. The available options include:
None: All groups will be listed. By Groups: You can specify which groups will be available for selection in this field. REST API # Read format # The read format is represented in JSON and comprises the following fields:
id: This corresponds to the ID of the referenced group. label: This represents the label associated with the referenced group. Sample group field in JSON format:
&quot;group&quot;: { &quot;id&quot;: &quot;57fe5269e4b0f6600fdfbdba&quot;, &quot;label&quot;: &quot;Read-only user&quot; } Write format # You have several options for the write format:
You can provide only the ID and omit the label field.
&quot;group&quot;: {&quot;id&quot;: &quot;57fe5269e4b0f6600fdfbdba&quot;} Alternatively, you can directly pass the ID as a string.
&quot;group&quot;: &quot;57fe5269e4b0f6600fdfbdba&quot; Lastly, you can supply the label of the group.
&quot;group&quot;: &quot;Read-only user&quot; JavaScript API # Read format # The val() method within the wrapper will return an object:
{ &quot;id&quot;: &quot;57fe5269e4b0f6600fdfbdba&quot;, &quot;label&quot;: &quot;Read-only user&quot; } Where:
id: This refers to the ID of the referenced group. label: This corresponds to the label of the referenced group. However, in most cases, rather than obtaining the raw value of the relationship, you will likely utilize the methods provided within the wrapper to directly access the ID or the label.
Write format # There are multiple ways to provide the value of a group in the JavaScript API.
You can provide only the ID.
record.field(&quot;group&quot;).val({id: &quot;57fe5269e4b0f6600fdfbdba&quot;}); Alternatively, you can directly pass the ID as a string.
record.field(&quot;group&quot;).val(&quot;57fe5269e4b0f6600fdfbdba&quot;); Another option is to pass the label of the group.
record.field(&quot;group&quot;).val(&quot;Read-only user&quot;); The JavaScript API also offers the ability to set a group wrapper as shown below:
task1.field('group').val(task2.field('group')); Wrapper method: id() # Returns the ID of the referenced group or null if the field is empty.
Returns # string - The ID of the referenced group.
Samples # // prints the ID of the referenced group in the field var record = sys.data.findOne('tasks', {number: 1}); log('group id: '+record.field('group').id()); Wrapper method: label() # Returns the label of the referenced group or null if the field is empty.
Returns # string - The label of the referenced group.
Samples # // prints the label of the referenced group in the field var record = sys.data.findOne('tasks', {number: 1}); log('group label: '+record.field('group').label()); Wrapper method: name() # Returns the name of the referenced group or null if the field is empty.
Returns # string - The name of the referenced group.
Samples # // prints the name of the referenced group in the field var record = sys.data.findOne('tasks', {number: 1}); log('group name: '+record.field('group').name()); Export/Import # Export format # The export format is the label of the group:
&quot;groupField1&quot;,&quot;groupField2&quot; &quot;Group A&quot;,&quot;Group B&quot; Import format # The import format can be either the name or the label of the group:
&quot;groupField1&quot;,&quot;groupField2&quot; &quot;Group A&quot;,&quot;groupB&quot; If there is ambiguity, the name takes precedence over the label.
Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported Notes equals yes Matching will be done based on the group&rsquo;s ID, followed by the name, and then the label, in that order of precedence. notEquals yes Matching will be performed using the group&rsquo;s ID, name, or label, in that order of precedence. empty yes - notEmpty yes - like yes Matching will be carried out using the group&rsquo;s label. greater no - greaterOrEquals no - less no - lessOrEquals no - between no - currentUserField no - Query formats # By default, the label will be utilized for various query operators.
For instance, the following query will retrieve tasks where the assignee&rsquo;s label is set to 'Read-only user':
JS Query MapJS Query BuilderREST API // finds a task by group&#39;s label var records_sample = sys.data.find('tasks', {group: &#39;Read-only user&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds a task by group&#39;s label var query_sample = sys.data.createQuery('tasks') .field(&#39;group&#39;).equals(&#39;Read-only user&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds a task by group&#39;s label GET /data/contacts?tasks?group=Read-only user You can also provide the ID:
JS Query MapJS Query BuilderREST API // finds a task by group&#39;s ID var records_sample2 = sys.data.find('tasks', {&#39;group.id&#39;: &#39;57fe5269e4b0f6600fdfbdba&#39;}); log('total: '+records_sample2.count()); while (records_sample2.hasNext()) { log(records_sample2.next().label()); } // finds a task by group&#39;s ID var query_sample2 = sys.data.createQuery('tasks') .field(&#39;group&#39;).equals(&#39;57fe5269e4b0f6600fdfbdba&#39;) var records_sample2 = sys.data.find(query_sample2); log('total: '+records_sample2.count()); while (records_sample2.hasNext()) { log(records_sample2.next().label()); } // finds a task by group&#39;s ID GET /data/contacts?group.id=57fe5269e4b0f6600fdfbdba Please note once more that the query builder will automatically recognize the ID, and you don’t need to append the &ldquo;id&rdquo; suffix.
Remember that when employing the query builder, you have the flexibility to utilize any of the formats accessible in the JavaScript API.
Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min no max no UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator like The label of the referenced group will be used for matching. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less no Less or equals no Between no `}),e.add({id:190,href:"/dev-reference/field-types/text/html/",title:"HTML type",description:`Overview # This field type is designed to store HTML code. It will display a user-friendly text editor in edit mode and render as HTML in read-only mode.
However, it&rsquo;s essential to note that, for security reasons, HTML code will undergo stripping. Only the following tags are allowed:
&lt;a href=&quot;ftp|http|https|mailto&quot; title=&quot;&quot;&gt; &lt;b&gt; &lt;blockquote cite=&quot;http|https&quot;&gt; &lt;br&gt; &lt;caption&gt; &lt;cite&gt; &lt;code&gt; &lt;col span=&quot;&quot; width=&quot;&quot;&gt; &lt;colgroup span=&quot;&quot; width=&quot;&quot;&gt; &lt;dd&gt; &lt;div&gt; &lt;dl&gt; &lt;dt&gt; &lt;em&gt; &lt;h1&gt; &lt;h2&gt; &lt;h3&gt; &lt;h4&gt; &lt;h5&gt; &lt;h6&gt; &lt;i&gt; &lt;img align=&quot;&quot; alt=&quot;&quot; height=&quot;&quot; src=&quot;http|https&quot; title=&quot;&quot; width=&quot;&quot;&gt; &lt;li&gt; &lt;ol start=&quot;&quot; type=&quot;&quot;&gt; &lt;p&gt; &lt;pre&gt; &lt;q cite=&quot;http|https&quot;&gt; &lt;small&gt; &lt;strike&gt; &lt;strong &lt;sub&gt; &lt;sup&gt; &lt;table summary=&quot;&quot; width=&quot;&quot;&gt; &lt;tbody&gt; &lt;td abbr=&quot;&quot; axis=&quot;&quot; colspan=&quot;&quot; rowspan=&quot;&quot; width=&quot;&quot;&gt; &lt;tfoot&gt; &lt;th abbr=&quot;&quot; axis=&quot;&quot; colspan=&quot;&quot; rowspan=&quot;&quot; scope=&quot;&quot; width=&quot;&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;u&gt; &lt;ul type=&quot;&quot;&gt; &lt;span&gt; &lt;div&gt; &lt;hr&gt; Apart from those specific attributes, the &quot;class&quot; attribute is allowed for all tags.`,content:`Overview # This field type is designed to store HTML code. It will display a user-friendly text editor in edit mode and render as HTML in read-only mode.
However, it&rsquo;s essential to note that, for security reasons, HTML code will undergo stripping. Only the following tags are allowed:
&lt;a href=&quot;ftp|http|https|mailto&quot; title=&quot;&quot;&gt; &lt;b&gt; &lt;blockquote cite=&quot;http|https&quot;&gt; &lt;br&gt; &lt;caption&gt; &lt;cite&gt; &lt;code&gt; &lt;col span=&quot;&quot; width=&quot;&quot;&gt; &lt;colgroup span=&quot;&quot; width=&quot;&quot;&gt; &lt;dd&gt; &lt;div&gt; &lt;dl&gt; &lt;dt&gt; &lt;em&gt; &lt;h1&gt; &lt;h2&gt; &lt;h3&gt; &lt;h4&gt; &lt;h5&gt; &lt;h6&gt; &lt;i&gt; &lt;img align=&quot;&quot; alt=&quot;&quot; height=&quot;&quot; src=&quot;http|https&quot; title=&quot;&quot; width=&quot;&quot;&gt; &lt;li&gt; &lt;ol start=&quot;&quot; type=&quot;&quot;&gt; &lt;p&gt; &lt;pre&gt; &lt;q cite=&quot;http|https&quot;&gt; &lt;small&gt; &lt;strike&gt; &lt;strong &lt;sub&gt; &lt;sup&gt; &lt;table summary=&quot;&quot; width=&quot;&quot;&gt; &lt;tbody&gt; &lt;td abbr=&quot;&quot; axis=&quot;&quot; colspan=&quot;&quot; rowspan=&quot;&quot; width=&quot;&quot;&gt; &lt;tfoot&gt; &lt;th abbr=&quot;&quot; axis=&quot;&quot; colspan=&quot;&quot; rowspan=&quot;&quot; scope=&quot;&quot; width=&quot;&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;u&gt; &lt;ul type=&quot;&quot;&gt; &lt;span&gt; &lt;div&gt; &lt;hr&gt; Apart from those specific attributes, the &quot;class&quot; attribute is allowed for all tags.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # Limit number of characters # Enabling this option will restrict the number of characters displayed, accompanied by a &quot;More&quot; button to expand the content.
Please note that this option only takes effect when the field is in read-only mode.
REST API # Read format # The format is the plain HTML code:
&quot;notes&quot;: &quot;&lt;p&gt;test &lt;span style=\\&quot;background-color: yellow; font-weight: bold;\\&quot;&gt;html&lt;/span&gt; text&lt;/p&gt;&quot; Write format # You should provide a HTML code:
&quot;notes&quot;: &quot;&lt;p&gt;test &lt;span style=\\&quot;background-color: yellow; font-weight: bold;\\&quot;&gt;html&lt;/span&gt; text&lt;/p&gt;&quot; Keep in mind that HTML code sent will be stripped out as explained above in the overview.
JavaScript API # Read format # The val() method within the wrapper will return a plain HTML code:
// this will print something like &quot;&lt;p&gt;test&lt;/p&gt;&quot; log('notes: '+record.field('notes').val()); Write format # To set the value, you should provide a plain string:
record.field('notes').val('&lt;p&gt;test &lt;span style=&quot;background-color: yellow; font-weight: bold;&quot;&gt;html&lt;/span&gt; text&lt;/p&gt;'); Export/Import # Export format # The export format is a simple string with the HTML code:
&quot;htmlField&quot; &quot;&lt;strong&gt;title&lt;/strong&gt;&lt;p&gt;blah blah&lt;/p&gt;&quot; Import format # The import format is a simple string with the HTML code:
&quot;htmlField&quot; &quot;&lt;strong&gt;title&lt;/strong&gt;&lt;p&gt;blah blah&lt;/p&gt;&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like yes greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should provide the email as a plain HTML. For example:
JS Query MapJS Query BuilderREST API // Finds companies where notes have the word &#39;test&#39; var records_sample = sys.data.find('companies', {&#39;notes&#39;: &#39;like(test)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // Finds companies where notes have the word &#39;test&#39; var query_sample = sys.data.createQuery('companies') .field(&#39;notes&#39;).like(&#39;test&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // Finds companies where notes have the word &#39;test&#39; GET /data/contacts?notes=like(test) Please be aware that searches will be conducted against the plain text version of the field. For instance, if you have a tag with a class name &ldquo;test,&rdquo; the query mentioned above will not match it because it is not part of the visible text content of the HTML.
Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator like Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between no `}),e.add({id:191,href:"/dev-reference/field-types/number/integer/",title:"Integer type",description:`Overview # This type is designed to store integer numbers.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation yes Default type rules yes Default display options yes Type rules # Minimum value # The minimum value (inclusive).
Maximum value # The maximum value (inclusive).`,content:`Overview # This type is designed to store integer numbers.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation yes Default type rules yes Default display options yes Type rules # Minimum value # The minimum value (inclusive).
Maximum value # The maximum value (inclusive).
Display options # Show Thousands Separator: If this flag is enabled, the thousands separator will be displayed in read-only mode. Please note that this flag does not impact edit mode. REST API # Read format # The format is an integer number:
&quot;numberOfEmployees&quot;: 8 Write format # To set the value, provide the integer number:
&quot;numberOfEmployees&quot;: 10 JavaScript API # Read format # The val() method within the wrapper will return an instance of an integer number:
// this will print something like &quot;numberOfEmployees: 8&quot; log('numberOfEmployees: '+record.field('numberOfEmployees').val()); Write format # To set the value, provide an integer number:
record.field('numberOfEmployees').val(10); If you provide something that isn’t a number, the field will be set to null.
Wrapper method: toHex() # The toHex() method returns string of hexadecimal representation of the value or empty ('') if null.
Returns # string - Hex value of number.
Samples # // prints the hex value of a integer field var record = sys.data.findOne('projects', {name: 'Point-to-point link'}); sys.logs.debug('project number of people hex: '+record.field('numberOfPeople').toHex()); Wrapper method: format(options) # Returns a string representing the formatted number value or an unformatted string.
Parameters # Name Type Required Description options object no These parameters are used to format the value. If left empty, the default display options will be used for formatting.
- thousandsSeparator: If set to &ldquo;true,&rdquo; a thousands separator will be displayed; if set to &ldquo;false,&rdquo; it won&rsquo;t. Returns # string - String of formatted value of number.
Samples # // prints the formated value of a integer field var record = sys.data.findOne('projects', {name: 'Point-to-point link'}); sys.logs.debug('project number of people: '+record.field('numberOfPeople').format({thousandsSeparator: true})); Export/Import # Export format # The export format is an integer number:
&quot;integerField1&quot;,&quot;integerField2&quot; &quot;1383&quot;,&quot;-37&quot; Import format # The import format is a string with an integer number:
&quot;integerField1&quot;,&quot;integerField2&quot; &quot;1383&quot;,&quot;-37&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should provide the number. For instance:
JS Query MapJS Query BuilderREST API // finds companies with more than 10 employees var records_sample = sys.data.find('companies', {&#39;numberOfEmployees&#39;: &#39;greater(10)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with more than 10 employees var query_sample = sys.data.createQuery('companies') .field(&#39;numberOfEmployees&#39;).greater(10) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with more than 10 employees GET /data/contacts?numberOfEmployees=greater(10) Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum yes avg yes first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between yes `}),e.add({id:192,href:"/dev-reference/flows/flow-designer/keyboard-shortcuts/",title:"Keyboard shortcuts",description:`Shortcuts available in the flow designer:
Ctrl+Alt+F: Toggle fullscreen mode. Shift+ Click, Hold &amp; Drag: Draw a multi-selection area. Escape: Remove any active multi-selection. Also, removes the selection of the selected step and collapses the properties panel. Steps multi-selection # It is possible to select several steps or an entire flow at once by using the above shortcut. This is useful for quickly relocating the flow or a portion of it, as demonstrated in the image below:`,content:`Shortcuts available in the flow designer:
Ctrl+Alt+F: Toggle fullscreen mode. Shift+ Click, Hold &amp; Drag: Draw a multi-selection area. Escape: Remove any active multi-selection. Also, removes the selection of the selected step and collapses the properties panel. Steps multi-selection # It is possible to select several steps or an entire flow at once by using the above shortcut. This is useful for quickly relocating the flow or a portion of it, as demonstrated in the image below:
✅ To exit multi-selection mode, press the Escape key. `}),e.add({id:193,href:"/dev-reference/field-types/text/long_text/",title:"Long Text type",description:`Overview # This field type is designed to store free text. Fields of this type are particularly useful for storing long-form text strings.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules yes Default display options yes Type rules # Minimum Length: Specifies the minimum number of characters that values can have.`,content:`Overview # This field type is designed to store free text. Fields of this type are particularly useful for storing long-form text strings.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules yes Default display options yes Type rules # Minimum Length: Specifies the minimum number of characters that values can have.
Maximum Length: Specifies the maximum number of characters that values can have.
Exact Length: Requires the value to have an exact number of characters as specified.
Display options # Representation # Specifies how this field should be displayed. The available options are:
Text Area: Displays a text area. You can specify the number of rows the text area should have. Code Editor: Displays a CodeMirror code editor for editing and displaying text with formatting in read-only mode. Number of rows # Specifies the number of rows in the text area used for this field. The minimum is 1, and the maximum is 100.
Limit number of characters # Enabling this option will restrict the number of characters displayed, along with a &ldquo;More&rdquo; button to expand the content.
Please note that this option only takes effect when the field is in read-only mode.
Language # Allows you to select the programming language for styling when using the code editor representation. Available languages are:
Java Javascript HTML CSS Shell Markdown SQL YAML Size # Allows you to choose a size when opting for the code editor representation. Predefined options include: small, medium, large, extra large (x), auto, and custom.
If you choose &ldquo;custom,&rdquo; you need to set the width and height in pixels.
REST API # Read format # The format is a simple string:
&quot;notes&quot;: &quot;test notes&quot; Write format # You should provide a string:
&quot;notes&quot;: &quot;new notes&quot; JavaScript API # Read format # The val() method within the wrapper will return a plain string:
// this will print something like &quot;notes: test notes&quot; log('notes: '+record.field('notes').val()); Write format # To set the value, you should provide a plain string:
record.field('notes').val('new notes'); Export/Import # Export format # The export format is a simple string:
&quot;longTextField1&quot;,&quot;longTextField2&quot; &quot;line1\\nline2&quot;,&quot;this is a long text&quot; Import format # The import format is a simple string:
&quot;longTextField1&quot;,&quot;longTextField2&quot; &quot;line1\\nline2&quot;,&quot;this is a long text&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like yes greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should provide the text as a plain string. For example:
JS Query MapJS Query BuilderREST API // finds companies with notes like &#39;ae&#39; var records_sample = sys.data.find('companies', {&#39;notes&#39;: &#39;like(ae)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with notes like &#39;ae&#39; var query_sample = sys.data.createQuery('companies') .field(&#39;notes&#39;).like(&#39;ae&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with notes like &#39;ae&#39; GET /data/contacts?notes=like(ae) Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator like Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between no `}),e.add({id:194,href:"/dev-reference/field-types/text/masked_text/",title:"Masked text type",description:`Overview # A mask can be specified to enforce a specific pattern for the text stored in this field.
It&rsquo;s important to note that only the text entered by the user will be stored. This means that if there are characters coming from the mask, they won&rsquo;t be saved in the database. For example, if the mask is &ldquo;999-aaa&rdquo; and the value entered is &ldquo;123-ABC,&rdquo; the value stored in the database will be &ldquo;123ABC.`,content:`Overview # A mask can be specified to enforce a specific pattern for the text stored in this field.
It&rsquo;s important to note that only the text entered by the user will be stored. This means that if there are characters coming from the mask, they won&rsquo;t be saved in the database. For example, if the mask is &ldquo;999-aaa&rdquo; and the value entered is &ldquo;123-ABC,&rdquo; the value stored in the database will be &ldquo;123ABC.&rdquo;
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules yes Default display options no Type rules # Mask # Specifies the mask used to validate values. Special characters in the mask include:
9: Must be a number. a: Must be a letter. w: Must be a number or a letter. You can also include other characters in the mask that will remain fixed. For example, the mask &ldquo;999-aaa&rdquo; will accept values like &ldquo;123-ABC&rdquo; or &ldquo;123ABC.&rdquo; In this case, you can omit the dash because it&rsquo;s part of the mask.
In the UI, special characters like 9, a, and w will be displayed as empty spaces where you can enter values. Other characters will be displayed as they are and will be read-only.
REST API # Read format # The format is a simple string that is already formatted according to the mask:
&quot;taxId&quot;: &quot;862-SKB&quot; Write format # To set the value, you should provide a string with the appropriate value:
&quot;taxId&quot;: &quot;123-ABC&quot; You can omit fixed characters in the mask:
&quot;taxId&quot;: &quot;123ABC&quot; JavaScript API # Read format # The val() method within the wrapper will return an already formatted string:
// this will print something like &quot;taxId: 123-ABC&quot; log('taxId: '+record.field('taxId').val()); Write format # You can pass the value with or without the mask format:
// all these lines are equivalent record.field('taxId').val('123-ABC'); record.field('taxId').val('123ABC'); Export/Import # Export format # The export format is a simple string:
&quot;maskedTextField1&quot;,&quot;maskedTextField2&quot; &quot;abc-123&quot;,&quot;udl-860&quot; Import format # The import format is a simple string:
&quot;maskedTextField1&quot;,&quot;maskedTextField2&quot; &quot;abc-123&quot;,&quot;udl-860&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported Notes equals yes notEquals yes empty yes notEmpty yes like yes It&rsquo;s important to note that in this case, the matching will be done with the value stored in the database. This means that fixed characters in the mask won&rsquo;t be considered for the matching process. For instance, if the mask is &ldquo;999-aaa&rdquo; and the value is &ldquo;123-ABC,&rdquo; querying with like(3-A) won&rsquo;t result in a match. However, querying with like(3A) will match. greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # For equality queries, you can provide the value with or without the mask format. For example:
JS Query MapJS Query BuilderREST API // finds companies with tax ID &#39;123-ABC&#39; var records_sample = sys.data.find('companies', {&#39;taxId&#39;: &#39;123-ABC&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with tax ID &#39;123-ABC&#39; var query_sample = sys.data.createQuery('companies') .field(&#39;taxId&#39;).equals(&#39;123-ABC&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with tax ID &#39;123-ABC&#39; GET /data/contacts?taxId=123-ABC You could skip the fixed characters in the mask as well:
JS Query MapJS Query BuilderREST API // finds companies with tax ID &#39;123ABC&#39; var records_sample2 = sys.data.find('companies', {&#39;taxId&#39;: &#39;123ABC&#39;}); log('total: '+records_sample2.count()); while (records_sample2.hasNext()) { log(records_sample2.next().label()); } // finds companies with tax ID &#39;123ABC&#39; var query_sample2 = sys.data.createQuery('companies') .field(&#39;taxId&#39;).equals(&#39;123ABC&#39;) var records_sample2 = sys.data.find(query_sample2); log('total: '+records_sample2.count()); while (records_sample2.hasNext()) { log(records_sample2.next().label()); } // finds companies with tax ID &#39;123ABC&#39; GET /data/contacts?taxId=123ABC Keep in mind that you cannot use the formatted form when using the like operator, as the matching will be done with the value stored in the database.
Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator like
Keep in mind that you cannot use the formatted value. See the notes in the like query operator. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between no `}),e.add({id:195,href:"/dev-reference/field-types/miscellaneous_types/",title:"Miscellaneous types",description:"",content:""}),e.add({id:196,href:"/dev-reference/field-types/number/money/",title:"Money type",description:`Overview # This type is designed to store decimal money amounts and offers options for rounding, specifying the number of decimals, displaying thousands separators, and indicating currency symbols.
As of now, this type does not support more than 4 decimals. However, this limitation is expected to be resolved in the near future.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation yes Default type rules yes Default display options yes Type rules # Minimum value # The minimum value (inclusive).`,content:`Overview # This type is designed to store decimal money amounts and offers options for rounding, specifying the number of decimals, displaying thousands separators, and indicating currency symbols.
As of now, this type does not support more than 4 decimals. However, this limitation is expected to be resolved in the near future.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation yes Default type rules yes Default display options yes Type rules # Minimum value # The minimum value (inclusive).
Maximum value # The maximum value (inclusive).
Limit decimals # This feature enables the limitation of the number of decimals. This limitation will be applied at the data level, meaning numbers will be stored in the database with the specified number of decimals, and any additional decimals will be discarded. If you wish to retain the additional decimals for display purposes while limiting their storage, you should configure these settings within the display options.
When you opt to limit the number of decimals, the following choices will be presented:
Number of Decimals: This indicates the number of decimals to be stored. It can range from 0 to 4.
Extra Decimals Action: This specifies the action to take when there are more decimals than the limit permits. The available options include:
Round: Rounding will be used to limit the decimals. Truncate: Truncation will be applied to the trailing decimals. Throw Error: An error will be triggered if an attempt is made to set more decimals than the allowable limit. Display options # Symbol: This represents the currency symbol that will be displayed in read-only mode.
Show Thousands Separator: If this flag is enabled, the thousands separator will be displayed in read-only mode. Please note that this flag does not affect edit mode.
Limit Number of Decimals: This feature allows the limitation of displayed decimals. It operates at the UI level and does not impact validation rules or database storage. Consequently, these options only apply to read-only mode.
When you choose to limit the number of decimals, the following choices will be presented:
Number of Decimals: This denotes the count of decimals to be displayed. It can range from 0 to 4. Extra Decimals Action: This specifies the action to take when there are more decimals than the set limit. The available options include: Round: Rounding will be used to limit the decimals. Truncate: Truncation will be applied to the trailing decimals. REST API # Read format # The format is a number:
&quot;averageSalary&quot;: 80000.00 Write format # To set the value, provide a number:
&quot;averageSalary&quot;: 100000.00 JavaScript API # Read format # The val() method within the wrapper will return a number:
// this will print something like &quot;salary: 80000.000000&quot; log('salary: '+record.field('averageSalary').val()); Write format # To set the value, provide a number:
record.field('averageSalary').val(100000.00); If you provide something that isn’t a number, the field will be set to null.
Wrapper method: toHex() # The toHex() method returns string of hexadecimal representation of the value or empty ('') if null.
Returns # string - Hex value of number.
Samples # // prints the hex value of a money field var record = sys.data.findOne('projects', {name: 'Point-to-point link'}); sys.logs.debug('project budget hex: '+record.field('budget').toHex()); Wrapper method: format(options) # Returns a string representing the formatted number value or an unformatted string.
Parameters # Name Type Required Description options object no These parameters are used to format the value. If left empty, the default display options will be used for formatting.
- thousandsSeparator: If set to &ldquo;true,&rdquo; a thousands separator will be displayed; if set to &ldquo;false,&rdquo; it won&rsquo;t.
- limitNumberOfDecimals: If set to &ldquo;true,&rdquo; the number of decimals will be limited; if set to &ldquo;false,&rdquo; it won&rsquo;t.
- numberOfDecimals: The count of decimals to be displayed. Default is 2.
- limitRuleType: The rule to use when limiting decimals, either &ldquo;TRUNCATE&rdquo; or &ldquo;ROUND.&rdquo; Default is &ldquo;TRUNCATE.&rdquo; Returns # string - String of formatted value of number.
Samples # // prints the formated value of a money field var inv = sys.data.findById('invoices', '579f5929e4b043b8ce4519b6'); sys.logs.debug('total: ' + inv.field('total').format({ 'thousandsSeparator': true, 'limitNumberOfDecimals': true, 'numberOfDecimals': 2 }) ); Export/Import # Export format # The export format is an decimal number:
&quot;moneyField1&quot;,&quot;moneyField2&quot; &quot;0.872&quot;,&quot;27810.0028&quot; Import format # The import format is a string with an decimal number:
&quot;moneyField1&quot;,&quot;moneyField2&quot; &quot;0.872&quot;,&quot;27810.0028&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should provide the number. For instance:
JS Query MapJS Query BuilderREST API // finds skills with an average salary greater or equals to 80000.00 var records_sample = sys.data.find('skills', {&#39;averageSalary&#39;: &#39;greaterOrEquals(80000.00)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds skills with an average salary greater or equals to 80000.00 var query_sample = sys.data.createQuery('skills') .field(&#39;averageSalary&#39;).greaterOrEquals(80000.00) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds skills with an average salary greater or equals to 80000.00 GET /data/contacts?averageSalary=greaterOrEquals(80000.00) Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum yes avg yes first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between yes `}),e.add({id:197,href:"/dev-reference/field-types/date_and_time/month-day/",title:"Month-day type",description:`Overview # This type can store a day of the year. It doesn’t store the year or time, just the month and day.
Default format: The default format is MM-dd but you can change it to something else.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # Representation # This defines the format for displaying the day.`,content:`Overview # This type can store a day of the year. It doesn’t store the year or time, just the month and day.
Default format: The default format is MM-dd but you can change it to something else.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # Representation # This defines the format for displaying the day. The default format is MM-dd, but you have the option to customize it to your preference.
There are several predefined formats available, which are commonly used. Additionally, you can choose the &quot;Custom&quot; option to define your own format based on the following guidelines:
Era designator: G (AD) Year: yy (16), yyyy (2016) Month: MMMM (July), MMM (Jul), MM (07) Day in month: d (9), dd (09) REST API # Read format # The format for the date is a string using the MM-dd format.
&quot;birthday&quot;: &quot;04-16&quot; Write format # To specify the date, you need to provide a string in the MM-dd format.
&quot;birthday&quot;: &quot;04-16&quot; JavaScript API # Read format # When utilizing the val() method within the wrapper, it will yield a Date object.
// this will print something like &quot;birthday: Wed Jan 11 2017 00:00:00 GMT-0000 (UTC)&quot; log('birthday: '+record.field('birthday').val()); Since the Date object includes the year and time components, it will be set to the current year and 00:00 using the time zone of the server.
Write format # When writing the value, you have the option to either use a Date object or provide a string in the MM-dd format.
record.field('birthday').val(new Date()); record.field('birthday').val('04-26'); If the provided value is not valid, the field will be silently set to null.
Wrapper method: addDays(numberOfDays) # This function adds days to the value stored in the field.
Parameters # Name Type Required Description numberOfDays number yes The number of days to add. This value can be either positive or negative. Returns # sys.data.Wrapper - Returns itself.
Exceptions # badRequest
If numberOfDays is not a number.
Samples # // adds 2 days to the start date var contact = sys.data.findOne('contacts', {email:'apetersonay@guardian.co.uk'}); log('birthday: '+contact.field('birthday').format()); contact.field('birthday').addDays(2); log('birthday: '+contact.field('birthday').format()); Wrapper method: format(pattern) # The format(pattern) method is used to format the day to a string. If a format pattern is provided, it will be used for formatting. If no pattern is provided, the format set in the default display options of the field will be used.
Parameters # Name Type Required Description pattern string no The pattern to format the date. Please refer to the documentation for display options to understand the available format choices.
If no pattern is supplied, the default display options of the field will be utilized. Returns # string - The formatted date.
Exceptions # badRequest
If pattern is invalid
Samples # // formats day using 'dd-MM' pattern var contact = sys.data.findOne('contacts', {email:'apetersonay@guardian.co.uk'}); log('birthday: '+contact.field('birthday').format('dd-MM')); // formats day using default display options var contact = sys.data.findOne('contacts', {email:'apetersonay@guardian.co.uk'}); log('birthday: '+contact.field('birthday').format()); Export/Import # Export format # The export format is MM-dd, regardless of the display options configured for that field.
&quot;monthDayField1&quot;,&quot;monthDayField2&quot; &quot;02-10&quot;,&quot;05-24&quot; Import format # The import format is MM-dd, regardless of the display options configured for that field.
&quot;monthDayField1&quot;,&quot;monthDayField2&quot; &quot;02-10&quot;,&quot;05-24&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should pass a string with the format MM-dd. For example:
JS Query MapJS Query BuilderREST API // finds companies with start date 07-12 var records_sample = sys.data.find('companies', {&#39;birthday&#39;:&#39;07-12&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with start date 07-12 var query_sample = sys.data.createQuery('companies') .field(&#39;birthday&#39;).equals(&#39;07-12&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with start date 07-12 GET /data/contacts?birthday=07-12 When utilizing the query builder, you have can use a Date object.
query.field('birthday').equals(new Date()); Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals
UI queries will attempt to match using the format specified in the default display options of the field. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between yes `}),e.add({id:198,href:"/dev-reference/field-types/multiple_choice/",title:"Multiple choice types",description:"",content:""}),e.add({id:199,href:"/dev-reference/field-types/special/special/",title:"Nested Fields",description:`Overview # This field type allows for the inclusion of other fields within it, facilitating nested structures. This capability permits the creation of multiple levels of nesting, thereby supporting complex data structures within entities.
For instance, you can create a structure like the following:
name email address addressLine zipCode state In this scenario, &ldquo;address&rdquo; is a field of type nested fields and contains the fields &ldquo;addressLine,&rdquo; &ldquo;zipCode,&rdquo; and &ldquo;state.&rdquo;
Furthermore, these nested structures can also be multi-valued, as demonstrated in the following example:`,content:`Overview # This field type allows for the inclusion of other fields within it, facilitating nested structures. This capability permits the creation of multiple levels of nesting, thereby supporting complex data structures within entities.
For instance, you can create a structure like the following:
name email address addressLine zipCode state In this scenario, &ldquo;address&rdquo; is a field of type nested fields and contains the fields &ldquo;addressLine,&rdquo; &ldquo;zipCode,&rdquo; and &ldquo;state.&rdquo;
Furthermore, these nested structures can also be multi-valued, as demonstrated in the following example:
name email addresses addressLine zipCode state primary In this instance, you can store multiple addresses within the &ldquo;addresses&rdquo; field. Feel free to use the corrected version above to update your documentation.
Available features # Name Supported Many multiplicity yes Default values no Unique flag no Required flag yes Indexable flag no Sensitive flag no Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options no Type rules # Label # This option allows you to assign a label to the group of fields. This label can be employed throughout the application to display a preview of the nested fields or to facilitate searches across records.
There are three available options:
None: No label will be generated. In the user interface, an auto-generated label might appear based on the field&rsquo;s name and the index if it&rsquo;s a multi-valued field.
Field: A nested field can be chosen, and its value will be used as the label.
Script: A script can be utilized to generate the label:
Parameters # Name Type Description record sys.data.Record The record the field belongs to. nested sys.data.Record This is a sys.data.Record object, with the distinction that the root of the record is designated to the nested fields. To illustrate, consider the subsequent structure:
- name
- email
- addresses
- addressLine
- zipCode
- state
Suppose the field &ldquo;addresses&rdquo; is multi-valued, and you desire the label to be the &ldquo;state.&rdquo; In this situation, you cannot utilize the record variable since you aren&rsquo;t aware of which address you are generating the label for. The solution entails employing the nested variable, which inherently points to the address you are calculating the label for. This could be achieved as follows:
return nested.field(&lsquo;state&rsquo;).name(); Returns # string: You should return the label
Samples # // uses the state and zip code as the label return nested.field('state').val()+'-'+nested.field('zipCode').val(); Display options # Show as accordion # Enabling this option allows the group of fields to be collapsible and expandable, with the label serving as the title of the accordion.
Indent fields # Enabling this option causes the inner fields to be indented in the UI, aligning them to the right of the parent field&rsquo;s label.
If this option isn&rsquo;t enabled, the label of the parent field will be displayed at the top, and the inner fields will be rendered below without indentation.
Inner fields layout # This setting controls the layout of inner fields, which proves especially useful when space is limited. The available options are:
Automatic: Based on the view&rsquo;s context, either a fixed or dynamic layout will be selected. For example, the dynamic layout will be used in the grid view, while the fixed layout will be chosen in read-only views. Fixed: Labels are allocated a predetermined amount of space, with the remaining space reserved for the values of the inner fields. Dynamic: The space allotted for inner field labels and values adjusts based on the content in each column. Custom: In this scenario, you can specify the width assigned to inner field labels, while the remaining space is designated for the values. REST API # Read format # The data is represented in JSON format and comprises the following fields:
id: This serves as the identifier for the nested group, primarily intended for internal use. label: The label associated with the nested group. Inner fields: Each inner field is contained within the map structure. In the example provided below, the fields addressLine, zipCode, city, and state are considered inner fields. Here is a sample representation of a nested field in JSON format:
&quot;address&quot;: { &quot;id&quot;: &quot;5877e2bd41058800079d11cc&quot;, &quot;label&quot;: &quot;WV - 25335&quot;, &quot;addressLine&quot;: &quot;3351 Harper Center&quot;, &quot;zipCode&quot;: &quot;25335&quot;, &quot;city&quot;: &quot;Charleston&quot;, &quot;state&quot;: &quot;WV&quot; } Write format # You can set a nested field by providing it’s inner fields:
&quot;address&quot;: { &quot;addressLine&quot;: &quot;3351 Harper Center&quot;, &quot;zipCode&quot;: &quot;25335&quot;, &quot;city&quot;: &quot;Charleston&quot;, &quot;state&quot;: &quot;WV&quot; } When updating a multi-valued nested field, it is crucial to include the corresponding id:
&quot;addresses&quot;: [ { &quot;id&quot;: &quot;57fd45aee4b0ce322b0c86ac&quot;, &quot;addressLine&quot;: &quot;4 Crownhardt Plaza&quot;, &quot;zipCode&quot;: &quot;73157&quot;, &quot;city&quot;: &quot;Oklahoma City&quot;, &quot;state&quot;: &quot;OK&quot; }, { &quot;id&quot;: &quot;57fd45aee4b0ce322b0c86aa&quot;, &quot;addressLine&quot;: &quot;4 Magdeline Place&quot;, &quot;zipCode&quot;: &quot;89145&quot;, &quot;city&quot;: &quot;Las Vegas&quot;, &quot;state&quot;: &quot;NV&quot; } ] If the id is not provided, the system will interpret the absence of the id as a request to delete the existing entry and add a new one, which will result in assigning a new ID to the entry.
Please note that you should refrain from sending the label, as it is automatically calculated and managed.
JavaScript API # Read format # The val() method within the wrapper will return an object:
{ &quot;addressLine&quot;: &quot;803 Anthes Pass&quot;, &quot;zipCode&quot;: &quot;08608&quot;, &quot;city&quot;: &quot;Trenton&quot;, &quot;state&quot;: &quot;NJ&quot; } In essence, this represents an object with inner fields contained within.
However, rather than directly retrieving the raw value of the relationship in most instances, you will typically utilize the methods provided within the wrapper to directly access the ID or label.
Write format # When configuring nested fields, you should adhere to the same format as used for reading:
{ &quot;addressLine&quot;: &quot;803 Anthes Pass&quot;, &quot;zipCode&quot;: &quot;08608&quot;, &quot;city&quot;: &quot;Trenton&quot;, &quot;state&quot;: &quot;NJ&quot; } For example:
contact.field('address').val({ &quot;addressLine&quot;: &quot;803 Anthes Pass&quot;, &quot;zipCode&quot;: &quot;08608&quot;, &quot;city&quot;: &quot;Trenton&quot;, &quot;state&quot;: &quot;NJ&quot; }); If the field is multi-valued, you have the option to specify the index:
company.field('addresses[1]').val({ &quot;addressLine&quot;: &quot;803 Anthes Pass&quot;, &quot;zipCode&quot;: &quot;08608&quot;, &quot;city&quot;: &quot;Trenton&quot;, &quot;state&quot;: &quot;NJ&quot; }); For multi-valued fields, you can also leverage the utilities provided by sys.data.ManyWrapper.
Wrapper method: field(path) # Returns the wrapper of an inner field.
Parameters # Name Type Required Description path string yes The path of the inner field to get the wrapper. Returns # sys.data.Wrapper or sys.data.ManyWrapper - The wrapper of the inner field.
Exceptions # badRequest
If path is invalid
Samples # // gets the wrapper of the inner field and prints its value var contact = sys.data.findOne('contacts', {email: 'djohnstonb0@behance.net'}); var stateWrapper = contact.field('address').field('state'); log('state: '+stateWrapper.val()); Wrapper method: id() # Returns a unique ID of the nested field instance.
Returns # string - The ID of the nested field instance.
Samples # // prints the ID of the nested field var record = sys.data.findOne('contacts', {email: 'djohnstonb0@behance.net'}); log('address id: '+record.field('address').id()); Wrapper method: label() # Returns the label of the nested field or null if the field is empty.
Returns # string - The label of the nested field as configured in type rules.
Samples # // gets the wrapper of a nested field and prints its label var contact = sys.data.findOne('contacts', {email: 'djohnstonb0@behance.net'}); var addressWrapper = contact.field('address'); log('state: '+addressWrapper.label()); Export/Import # Export format # Nested fields themselves cannot be directly exported. What is exported are the inner fields:
&quot;nested.innerField1&quot;,&quot;nested.innerField2&quot; &quot;value1&quot;,&quot;value2&quot; Import format # Nested fields themselves cannot be directly imported. What is imported are the inner fields:
&quot;nested.innerField1&quot;,&quot;nested.innerField2&quot; &quot;value1&quot;,&quot;value2&quot; If there is ambiguity, the name takes precedence over the label.
Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals no empty yes notEmpty yes like no greater no greaterOrEquals no less no lessOrEquals no between no currentUserField no Query formats # Queries on parent nested fields are not supported. However, you can perform queries using inner fields:
JS Query MapJS Query BuilderREST API // filters by state var records_sample = sys.data.find('contacts', {&#39;address.state&#39;: &#39;NY&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // filters by state var query_sample = sys.data.createQuery('contacts') .field(&#39;address.state&#39;).equals(&#39;NY&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // filters by state GET /data/contacts?address.state=NY In these cases, you should employ the format and operators corresponding to the type of inner fields.
Furthermore, querying is feasible even when dealing with multi-valued nested fields:
JS Query MapJS Query BuilderREST API // filters by state var records_sample2 = sys.data.find('companies', {&#39;addresses.state&#39;: &#39;NY&#39;}); log('total: '+records_sample2.count()); while (records_sample2.hasNext()) { log(records_sample2.next().label()); } // filters by state var query_sample2 = sys.data.createQuery('companies') .field(&#39;addresses.state&#39;).equals(&#39;NY&#39;) var records_sample2 = sys.data.find(query_sample2); log('total: '+records_sample2.count()); while (records_sample2.hasNext()) { log(records_sample2.next().label()); } // filters by state GET /data/contacts?addresses.state=NY In this scenario, since &ldquo;addresses&rdquo; is multi-valued, any company that possesses at least one address with &ldquo;NY&rdquo; in the &ldquo;state&rdquo; field will be encompassed in the results.
Finally, for querying nested record fields simultaneously:
JS Query MapJS Query BuilderREST API // filters by street and zip code var records_sample3 = sys.data.find('companies', {&#39;addresses&#39;: {&#39;street&#39;: &#39;Street 123&#39;, &#39;zipCode&#39;: &#39;1234&#39;}}); log('total: '+records_sample3.count()); while (records_sample3.hasNext()) { log(records_sample3.next().label()); } // filters by street and zip code var query_sample3 = sys.data.createQuery('companies') .field(&#39;addresses&#39;).equals({&#39;street&#39;: &#39;Street 123&#39;, &#39;zipCode&#39;: &#39;1234&#39;}) var records_sample3 = sys.data.find(query_sample3); log('total: '+records_sample3.count()); while (records_sample3.hasNext()) { log(records_sample3.next().label()); } // filters by street and zip code GET /data/contacts?addresses={same-as-query-builder} Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min no max no UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator none Nested fields do not support UI queries. Available operators # Operator Supported Many values no Greater no Greater or equals no Less no Less or equals no Between no `}),e.add({id:200,href:"/dev-reference/field-types/number/",title:"Number types",description:"",content:""}),e.add({id:201,href:"/dev-reference/security/oauth/",title:"OAuth Support",description:`External applications can access the Slingr App API through OAuth requests. We refer to these applications as OAuth Apps.
Follow the steps below to acquire and refresh the Access Token.
In the Slingr app # 1) Enabling OAuth support in builder and creating scopes # Navigate to Security -&gt; OAuth and enable OAuth support. This action will activate a form for OAuth Scopes. OAuth tokens security is now managed through OAuth scope groups, rather than user groups.`,content:`External applications can access the Slingr App API through OAuth requests. We refer to these applications as OAuth Apps.
Follow the steps below to acquire and refresh the Access Token.
In the Slingr app # 1) Enabling OAuth support in builder and creating scopes # Navigate to Security -&gt; OAuth and enable OAuth support. This action will activate a form for OAuth Scopes. OAuth tokens security is now managed through OAuth scope groups, rather than user groups.
Field Description Name This is the name of the OAuth Scope, which must be unique. Description Provide a human-readable description of the OAuth Scope. Ensure it is under 140 characters since OAuth app scopes are displayed on the authorization page. Groups Here, you can define the groups associated with the OAuth App. Security for OAuth tokens is regulated by these groups, instead of user groups. Before deleting a scope, verify if it&rsquo;s being used in any OAuth App. Remember to save your changes after making modifications.
2) Registering the OAuth app in the Slingr app # Once OAuth is enabled, head to the Runtime section. In the secondary menu, locate OAuth Apps.
Proceed to create an OAuth App with the following fields:
Field Description Label This is a user-friendly name for the OAuth App, displayed to users on the Authorization page. Name Enter the name of the OAuth App. Icon Upload an icon that will be presented to users on the authorization page. It should have dimensions of 64x64 px. If not provided, a default icon will be displayed. Description Include a description for the OAuth App. Authorization Callback URL After the authorization step, an authorization code will be appended to this URL and triggered. Scopes OAuth tokens security is regulated by groups defined in scopes. Client Id A randomly generated key assigned to identify the OAuth App in requests. In the OAuth app # 1) Prompt the user to log in and authorize the OAuth App. # Prompt the user to log in and authorize the OAuth App by opening the Authorize URL in a new window. The URL should include the response_type and client_id parameters.
https://&lt;appName&gt;.slingrs.io/&lt;env&gt;/runtime/authorize?response_type=code&amp;client_id=&lt;client_id&gt; In this URL:
appName refers to the app&rsquo;s name. env is the environment name (e.g., dev or prod). client_id should be the client id specified in the OAuth App. If an OAuth Authorization exists for the user and the OAuth App, a form requesting the user&rsquo;s authorization for the OAuth App will be displayed. If the OAuth authorization is revoked from the Slingr App, the authorization form will reappear.
After the user&rsquo;s authorization, a callback URL containing the authorization_code will be invoked from the Authorize page.
https://&lt;oAuthAppAuthorizationCallbackUrl&gt;?code=&lt;authorization_code&gt; In this URL:
oAuthAppAuthorizationCallbackUrl stands for the callback URL set in the OAuth App. authorization_code corresponds to the authorization code required for requesting the access token. It&rsquo;s expected that the endpoint executed by the callback URL will store the authorization code provided by the code parameter and subsequently close the authorization window.
2) Acquiring an Access Token with the Authorization Code # To obtain an access token, initiate a POST request to the slingr app&rsquo;s OAuth token endpoint.
POST https://&lt;appName&gt;.slingrs.io/&lt;env&gt;/runtime/api/oauth/token?grant_type=authorization_code&amp;client_id=&lt;client_id&gt;&amp;code=&lt;authorization_code&gt; In this URL:
appName is the app&rsquo;s name. env refers to the environment name (e.g., dev or prod). client_id corresponds to the client id established in the OAuth App. authorization_code should be replaced with the code obtained in step 1. If you encounter an expired authorization code while attempting to retrieve an access token, you will receive the following information:
{ &quot;access_token&quot;: &quot;5HMxY4eBEK2xvmkATMCzSdJ0wTxMlSlF&quot;, &quot;refresh_token&quot;: &quot;ZqUeuPwAezCZWpDQqjCW&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;expires_in&quot;: 28800, &quot;scope&quot;: &quot;scope1 scope2 scope3&quot; } Field Description Access Token The access token to be included in the Authorization header of your REST API requests. Refresh Token Use this token to refresh the Access Token in case a request to the REST API results in a 401 error. Token Type Indicates that the token type is bearer. Expires in Specifies the token&rsquo;s expiration time in seconds. Once expired, you can obtain a new token using the refresh token. Scope Provides information about the scopes defined for the OAuth App. 3) Put the access token in an authorization header in your requests # Example: To retrieve a list of companies, execute a GET request while including the Authorization header with the Bearer token, which is the access token you obtained. Below is a sample request:
GET https://&lt;appName&gt;.slingrs.io/&lt;env&gt;/runtime/api/data/companies &gt; Authorization: Bearer &lt;access_token&gt; In this request:
appName stands for the app&rsquo;s name. env represents the environment name, such as dev or prod. access_token should be replaced with the actual access token obtained in step 2. Upon successful authentication, this request will retrieve the desired list of companies from the API. More info about using the REST API
4) Refresh the token # Utilize the refresh token acquired in step 2 to initiate a request for a new access token. This enables you to obtain a new access token without requiring user involvement (as in step 1).
POST https://&lt;appName&gt;.slingrs.io/&lt;env&gt;/runtime/api/oauth/token?grant_type=refresh_token&amp;client_id=&lt;client_id&gt;&amp;code=&lt;refresh_token&gt; In this URL:
appName is the name of the app. env is the environment name (e.g., dev or prod). client_id corresponds to the client id established in the OAuth App. refresh_token is the refresh token obtained in step 2. This process will yield a new access token, allowing you to seamlessly continue API interactions.
{ &quot;access_token&quot;: &quot;oqChNyTJhKvTrHWawj61jTgsZTGrgVGT&quot;, &quot;refresh_token&quot;: &quot;gJYDedgagcZalmptnhBg&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;expires_in&quot;: 28800, &quot;scope&quot;: &quot;scope1 scope2 scope3&quot; } General Error Codes # Below are descriptions for various general errors. More specific error descriptions for each method can be found in their respective sections.
HTTP Status Code Description 200 Request successfully processed; no errors occurred. 400 Invalid client ID. Double-check the accuracy of the client ID. 400 OAuth is not enabled. Ensure that OAuth support is enabled for the Slingr app. 400 Invalid authorization code. The provided authorization code is invalid. Obtain a new one using the authorize URL. 400 Authorization code has expired. 400 App is not authorized by the user. 400 Invalid grant type. Only authorization_code and refresh_token are accepted values. 400 Refresh token has expired. 400 Token is not yet expired. While refreshing the token, verify if the Access Token is still valid. 401 Unauthorized. User login is required. 500 Unknown OAuth error. If you encounter this error unexpectedly, please contact support. 502 Token is missing. This error could occur when attempting to authorize the OAuth App without a logged-in user. `}),e.add({id:202,href:"/dev-reference/field-types/number/percentage/",title:"Percentage type",description:`Overview # This type is designed to store percentages and offers options for rounding and specifying the number of decimals.
In the UI, percentage values will be displayed multiplied by 100, which makes more sense for human interpretation. However, at the code level—when utilizing the REST or JavaScript API—the value will not be multiplied. For instance, if the value is 50%, then the stored value will be 0.5.
As of now, this type does not support more than 2 decimals.`,content:`Overview # This type is designed to store percentages and offers options for rounding and specifying the number of decimals.
In the UI, percentage values will be displayed multiplied by 100, which makes more sense for human interpretation. However, at the code level—when utilizing the REST or JavaScript API—the value will not be multiplied. For instance, if the value is 50%, then the stored value will be 0.5.
As of now, this type does not support more than 2 decimals. However, this limitation is expected to be addressed in the near future.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation yes Default type rules yes Default display options yes Type rules # Minimum value # The minimum value (inclusive).
Maximum value # The maximum value (inclusive).
Limit decimals # This feature enables the limitation of the number of decimals. This limitation will be applied at the data level, meaning numbers will be stored in the database with the specified number of decimals, and any additional decimals will be discarded. If you wish to retain the additional decimals for display purposes while limiting their storage, you should configure these settings within the display options.
When you opt to limit the number of decimals, the following choices will be presented:
Number of Decimals: This indicates the number of decimals to be stored. It can range from 0 to 4.
Extra Decimals Action: This specifies the action to take when there are more decimals than the limit permits. The available options include:
Round: Rounding will be used to limit the decimals. Truncate: Truncation will be applied to the trailing decimals. Throw Error: An error will be triggered if an attempt is made to set more decimals than the allowable limit. Display options # Show Thousands Separator: If this flag is enabled, the thousands separator will be displayed in read-only mode. Please note that this flag does not affect edit mode.
Limit Number of Decimals: This feature allows the limitation of displayed decimals. It operates at the UI level and does not impact validation rules or database storage. Consequently, these options only apply to read-only mode.
When you choose to limit the number of decimals, the following choices will be presented:
Number of Decimals: This denotes the count of decimals to be displayed. It can range from 0 to 4. Extra Decimals Action: This specifies the action to take when there are more decimals than the set limit. The available options include: Round: Rounding will be used to limit the decimals. Truncate: Truncation will be applied to the trailing decimals. REST API # Read format # The format is a number:
&quot;availabilityRate&quot;: 0.7 Write format # To set the value, provide a number:
&quot;availabilityRate&quot;: 80 JavaScript API # Read format # The val() method within the wrapper will return a number:
// this will print something like &quot;availabilityRate: 30.2&quot; log('availabilityRate: '+record.field('availabilityRate').val()); Write format # To set the value, provide a number:
record.field('availabilityRate').val(0.5); If you provide something that isn’t a number, the field will be set to null.
Wrapper method: toHex() # The toHex() method returns string of hexadecimal representation of the value or empty ('') if null.
Returns # string - Hex value of number.
Samples # // prints the hex value of a percentage field var record = sys.data.findOne('projects', {name: 'Point-to-point link'}); sys.logs.debug('project progress hex: '+record.field('progress').toHex()); Wrapper method: format(options) # Returns a string representing the formatted number value or an unformatted string.
Parameters # Name Type Required Description options object no These parameters are used to format the value. If left empty, the default display options will be used for formatting.
- thousandsSeparator: If set to &ldquo;true,&rdquo; a thousands separator will be displayed; if set to &ldquo;false,&rdquo; it won&rsquo;t.
- limitNumberOfDecimals: If set to &ldquo;true,&rdquo; the number of decimals will be limited; if set to &ldquo;false,&rdquo; it won&rsquo;t.
- numberOfDecimals: The count of decimals to be displayed. Default is 2.
- limitRuleType: The rule to use when limiting decimals, either &ldquo;TRUNCATE&rdquo; or &ldquo;ROUND.&rdquo; Default is &ldquo;TRUNCATE.&rdquo; Returns # string - String of formatted value of number.
Samples # // prints the formated value of a percentage field var inv = sys.data.findById('invoices', '579f5929e4b043b8ce4519b6'); sys.logs.debug('total: ' + inv.field('total').format({ 'thousandsSeparator': true, 'limitNumberOfDecimals': true, 'numberOfDecimals': 2 }) ); Export/Import # Export format # The export format is an decimal number:
&quot;percentageField1&quot;,&quot;percentageField2&quot; &quot;50&quot;,&quot;76.25&quot; No symbol or thousands separators are in the number.
Import format # The import format is a string with an decimal number:
&quot;percentageField1&quot;,&quot;percentageField2&quot; &quot;50&quot;,&quot;76.25&quot; No symbol or thousands separators should be in the number.
Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should provide the number. For instance:
JS Query MapJS Query BuilderREST API // finds contacts with availability rate grater or equals than 50 var records_sample = sys.data.find('companies', {&#39;availabilityRate&#39;: &#39;greaterOrEquals(50)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds contacts with availability rate grater or equals than 50 var query_sample = sys.data.createQuery('companies') .field(&#39;availabilityRate&#39;).greaterOrEquals(50) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds contacts with availability rate grater or equals than 50 GET /data/contacts?availabilityRate=greaterOrEquals(50) Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum yes avg yes first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between yes `}),e.add({id:203,href:"/dev-reference/field-types/text/phone/",title:"Phone type",description:`Overview # This type can store a phone number, such as &ldquo;111-222-3333.&rdquo; It&rsquo;s also possible to store an international phone number if desired. In both cases, characters other than numbers are removed, and the phone number is automatically formatted for reading and display in the UI.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules yes Default display options no Type rules # International # Indicates whether the field supports international phone numbers.`,content:`Overview # This type can store a phone number, such as &ldquo;111-222-3333.&rdquo; It&rsquo;s also possible to store an international phone number if desired. In both cases, characters other than numbers are removed, and the phone number is automatically formatted for reading and display in the UI.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules yes Default display options no Type rules # International # Indicates whether the field supports international phone numbers. When enabled, validation becomes more flexible, allowing the entry of international phone numbers.
Default international prefix # If the field is set as international and the &lsquo;+&rsquo; sign is not indicated at the beginning of the value, a default prefix will be automatically added.
REST API # Read format # The format is a simple string that is already formatted as a phone number:
&quot;contactInformation&quot;: { &quot;phoneNumber&quot;: &quot;1-702-845-9380&quot; } Write format # To set the value, you should provide a string with the appropriate value:
&quot;contactInformation&quot;: { &quot;phoneNumber&quot;: &quot;1-702-845-9380&quot; } You can omit fixed format:
&quot;contactInformation&quot;: { &quot;phoneNumber&quot;: &quot;17028459380&quot; } JavaScript API # Read format # The val() method within the wrapper will return a the formatted phone number (with dashes):
// this will print something like &quot;phone number: 1-405-298-5885&quot; log('phone: '+record.field('contactInformation.phoneNumber').val()); Write format # You can input the phone number in various formats. However, please note that only the numbers will be retained, and any other characters will be discarded. The phone number will then be automatically formatted for reading. Here are some sample formats:
// all this lines are equivalent record.field('contactInformation.phone').val('1-405-298-5885'); record.field('contactInformation.phone').val('+1-405-298-5885'); record.field('contactInformation.phone').val('14052985885'); Wrapper method: format() # Returns the phone number formatted with dashes.
Returns # string - The formatted phone number.
Samples # // logs the formatted phone number var record = sys.data.findOne('contacts', {number: 1}); sys.logs.info(record.field('phoneNumber').format()); Export/Import # Export format # The export format is a string representation of the phone number, including dashes:
&quot;phoneField1&quot;,&quot;phoneField2&quot; &quot;111-222-3333&quot;,&quot;549-261-654-9862&quot; Import format # The import format is a string representation of the phone number, where dashes are optional:
&quot;phoneField1&quot;,&quot;phoneField2&quot; &quot;111-222-3333&quot;,&quot;549-261-654-9862&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like yes greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # To perform queries, you should provide the phone number as a plain string. Please note that non-numerical characters will be removed before executing the query. For example:
JS Query MapJS Query BuilderREST API // finds companies with contact phone number like &#39;123&#39; var records_sample = sys.data.find('companies', {&#39;contactInformation.phoneNumber&#39;: &#39;like(123)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with contact phone number like &#39;123&#39; var query_sample = sys.data.createQuery('companies') .field(&#39;contactInformation.phoneNumber&#39;).like(&#39;123&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with contact phone number like &#39;123&#39; GET /data/contacts?contactInformation.phoneNumber=like(123) Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator like Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between no `}),e.add({id:204,href:"/dev-reference/user-interface/pie-chart-widget/",title:"Pie chart widget",description:`Pie and doughnut charts are among the most commonly used chart types. They are divided into segments, with each segment&rsquo;s arc representing the proportional value of a specific data point.
These charts excel at illustrating the relative proportions between data points.
Label # This is a human-readable name for the view. You can use spaces, special characters, and a mixture of upper and lower case letters.
This label will appear at the top of the widget view, so ensure you use language that users will understand.`,content:`Pie and doughnut charts are among the most commonly used chart types. They are divided into segments, with each segment&rsquo;s arc representing the proportional value of a specific data point.
These charts excel at illustrating the relative proportions between data points.
Label # This is a human-readable name for the view. You can use spaces, special characters, and a mixture of upper and lower case letters.
This label will appear at the top of the widget view, so ensure you use language that users will understand.
Name # This is the internal name of the view. It cannot contain special characters or spaces.
You will usually utilize the view&rsquo;s name in scripts and the REST API. Changing it may impact your app, necessitating manual adjustments.
Description # This is a human-readable description of the widget. You can use spaces, special characters, and a mixture of upper and lower case letters. Internationalization is possible.
This description will be visible at the top of the added widget in your dashboard.
Slices calculation # Define the type of slice calculation; it can be either Automatic or Manual. When set to Automatic, each slice is generated through aggregation based on the defined data grouping. In contrast, with the Manual option, developers manually define each individual slice.
Allow refresh # This option determines whether the refresh button is displayed or hidden. This button facilitates the update of widget information. It&rsquo;s enabled by default.
Filtering settings # These settings determine how the listing functions.
Sort field # This sets the default sorting field for the listing.
Users may be able to modify the default sorting if that feature is enabled in any of the columns.
Sort type # This indicates the sorting direction.
Users may be able to adjust the default sorting direction if it&rsquo;s enabled in any of the columns.
Filter type # It can be either an expression or a script. If &ldquo;expression&rdquo; is selected, record filters should be configured. Otherwise, a script should be provided.
Record filters # This specifies which records will be displayed in the list. Only records that match the given expression will appear in the table widget view.
Script # Returns a query parameter or queryMap. The query map object is used to filter records. For information on the query map version, refer to the Query Language documentation.
Size # This sets the maximum number of records to fetch when the view is initially loaded and when clicking &ldquo;More&rdquo; to retrieve additional records.
Chart settings # Show as doughnut # When selected, the pie chart is rendered as a doughnut.
Automatic slices configuration # In this type of pie chart, each slice is generated through aggregation based on the defined data grouping. The colors of the slices are calculated automatically.
Entity # This indicates the entity to which the automatic chart slice will refer. Only records from this entity will be listed in the pie chart view.
Slice group # This refers to the entity field used for data grouping. Each group formed through this field is subsequently utilized for aggregating the final values to form the slices.
Label # This represents the human-readable name of the field.
Name # This serves as the internal name of the field. The name cannot include special characters or spaces. Only letters and numbers are allowed.
Type # The field&rsquo;s type specifies what can be stored in the field and how the field will be displayed. Each type has its own rules and display options.
To discover available types and their features, please consult the Types documentation.
Multiplicity # This indicates whether the field can hold one or multiple values. For instance, you might have a field called emails that can accommodate multiple email addresses if the user has more than one.
Calculated # Define the method for calculating values. There are two approaches to value calculation:
Script: In this scenario, you can supply a script to perform the value calculation. The script operates within the following context:
Returns # string - you should return a string value as result
Samples # // displays a label based on the status of the contract var contract = sys.data.findOne('contracts', {number: '001'}); if (contract.field('status').val() === 'deployed') { return 'Active'; } return 'Inactive'; Aggregate: In this case, you can calculate a value based on an aggregate query involving other records. For instance, consider having an entity named departments and another named employees with a field named salary. To calculate the average salary for each department, you could add a field where the calculation involves aggregating data from the employees entity. This would be done for records with the department field pointing to the corresponding department record, and performing an average calculation on the salary field. This aggregation will be automatically updated whenever a salary changes or an employee is added or removed from the department. When the calculation is Aggregate, you can choose from the following options:
Aggregate entity: This refers to the entity containing the records that need to be aggregated. In the aforementioned example, it would be the employees entity. Expression: This expression defines the criteria that records in the Aggregate entity must meet to be included in the aggregation. In the above example, the expression was based on a field where the Current record was equal to the department field. This ensures that only employees from the current department are included in the aggregation. Aggregate operation: This operation specifies the calculation to be performed. It could be: Count: This counts the number of records matching the expression. Sum: This sums the values in the Aggregate field (see below) for the records matching the expression. Avg: This calculates the average of the values in the Aggregate field (see below) for the records matching the expression. Aggregate field: If the Aggregate operation is anything other than Count, a field must be selected for the operation to be applied. In the example above, the chosen field is salary. Manual chart configuration # In this type of chart, each slice must be added by the developer. For each slice, the following should be configured:
Entity # This specifies the entity to which the manual chart slice will refer. Only records from this entity will be listed in the pie slice chart view.
Label # This is the human-readable name of the field.
Name # This serves as the internal name of the field. The name cannot include special characters or spaces. Only letters and numbers are allowed.
Type # The field&rsquo;s type indicates what can be stored in the field and how the field will be displayed. Each type comes with its own rules and display options.
To explore the available types and their features, please refer to the Types documentation.
Multiplicity # This indicates whether the field can hold one or multiple values. For instance, you might have a field called emails that can accommodate multiple email addresses if the user has more than one.
Calculated # Define the method for calculating values. There are two approaches to value calculation:
Script: In this scenario, you can supply a script to perform the value calculation. The script operates within the following context:
Returns # string - you should return a string value as result
Samples # // displays a label based on the status of the contract var contract = sys.data.findOne('contracts', {number: '001'}); if (contract.field('status').val() === 'deployed') { return 'Active'; } return 'Inactive'; Aggregate: In this case, you can calculate a value based on an aggregate query involving other records. For instance, consider having an entity named departments and another named employees with a field named salary. To calculate the average salary for each department, you could add a field where the calculation involves aggregating data from the employees entity. This would be done for records with the department field pointing to the corresponding department record, and performing an average calculation on the salary field. This aggregation will be automatically updated whenever a salary changes or an employee is added or removed from the department. When the calculation is Aggregate, you can choose from the following options:
Aggregate entity: This refers to the entity containing the records that need to be aggregated. In the aforementioned example, it would be the employees entity. Expression: This expression defines the criteria that records in the Aggregate entity must meet to be included in the aggregation. In the above example, the expression was based on a field where the Current record was equal to the department field. This ensures that only employees from the current department are included in the aggregation. Aggregate operation: This operation specifies the calculation to be performed. It could be: Count: This counts the number of records matching the expression. Sum: This sums the values in the Aggregate field (see below) for the records matching the expression. Avg: This calculates the average of the values in the Aggregate field (see below) for the records matching the expression. Aggregate field: If the Aggregate operation is anything other than Count, a field must be selected for the operation to be applied. In the example above, the chosen field is salary. Slice styling settings # Settings mode # It can be simple or advanced. In case of simple mode just need set slice color and other settings are calculated or set by default. For advanced the developer should define each value.
Color # This is the slice color. It should be hexadecimal color code.
Border color # The border line fill color. It should be hexadecimal color code.
Hover background color # Background color when hovered.
Hover border color # Background color when hovered.
Border align # When center is set, the borders of arcs next to each other will overlap. When inner is set, it is guaranteed that all the borders are not overlap.
Border width # The line width (in pixels). From 0 to 5.
Hover border width # The border line width (in pixels) when hovered. From 0 to 5.
Example: automatic calculation of slices # Use case # This type of graph allows data representation in such a way that you immediately understand that you are seeing parts of a whole. As an example you may need to view the number of articles summarized by content type.
Precondition # You need to have an entity that contains articles. Each article can be of a single Type and have a name.
As an example, the types of articles are: Sports, Culture, Technology, Society, Others.
Creating a pie chart with automatic calculation of slices # The following steps outline how to create this type of chart:
Step 1: To create the widget within the root layout of the given dashboard, either in columns or rows, navigate to Assign Widget. Step 2: You can either assign an existing widget or create a new one. In this case, we&rsquo;re creating a new widget. Step 3: Provide a label and name for the new widget, then select Pie Chart as the widget type and choose Automatic for Slices Calculation. Step 4: Under Automatic Slices Configuration, select the entity that contains the relevant data. Next, choose the Slice Group which, in this case, is the field called Type. Complete the label and name for the slice. Step 5: The slice type will be an Integer, as we&rsquo;re summarizing the count of records. Step 6: For this use case, the necessary operation is Count. Step 7: Save the changes and push them. Example: manual calculation of slices # Use case # This graph type enables the representation of data in a manner that immediately conveys parts of a whole. As an example, you might need to compare the number of articles categorized as Technology versus articles in other categories (Sports, Culture, Society, Others).
Prerequisite # You need to have an entity containing articles. Each article should have a single Type and a Name.
For instance, the article types could include: Sports, Culture, Technology, Society, Others.
Creating a pie chart with manual calculation of slices # The following steps illustrate the process:
Step 1: To begin, navigate to the root layout of the dashboard (either in columns or rows) and select Assign Widget. Step 2: You can assign an existing widget or create a new one. In this case, we&rsquo;ll create a new widget. Step 3: Provide a label and name for the new widget. Choose Pie Chart as the widget type and set Manual for Slices Calculation, then save it. Step 4: Under the Slices menu option within the view, click on Create. Step 5: Fill in the model settings, using the entity Content. Set a Label and a Name. Choose the Type as Integer. Step 6: After selecting the Type, set the Calculation Type as Aggregate. Apply a filter to consider only the records with the type Technology. For Operation, select Count. Step 7: In Slice Styling Settings, pick a color for the slice, and save the configuration. Step 8: Create a new slice by clicking on Create. Step 9: Fill in the model settings, using the entity Content. Set a Label and a Name. Choose the Type as Integer. Step 10: After selecting the Type, set the Calculation Type as Aggregate. Apply a filter to exclude records where the type is not Technology. For Operation, select Count. Step 11: In Slice Styling Settings, select a color for the slice, and save the configuration. Step 12: Save the changes and push them. UI message # Widgets can respond to UI messages. A common use case is when data needs refreshing or filters need applying.
Refresh and filter # You can send a message to refresh the widget with default settings. These messages are sent to the dashboard container and propagated to each widget.
Additionally, you can send a filter parameter to apply it to the query used for data retrieval. The query can be a query object or a query map. If using a query object, the filter is applied only when the entity matches that set in the widget. Refer to the Query Language for more information.
To apply filters, set the widgetContainer with a list of objects, each describing the container name and the filter to be applied to each widget. The title can also be sent to update the widget title.
Example # In the following example, you refresh and apply a filter by sending the filter parameter to the given widget container. Note how each series defines its own query and applies it to a specific entity.
var query = sys.data.createQuery('content'); query.field('access').equals('PUBLIC'); sys.ui.sendMessage({ scope: 'view', name: 'refresh', views: ['dashboard'], widgetContainers: [ { name: 'col11', filter: [ { name: 'content', filter: query } ] } ] }); `}),e.add({id:205,href:"/dev-reference/field-types/text/qr/",title:"QR type",description:`Overview # This type stores text and displays it as a QR code in read-only view.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules yes Default display options yes Type rules # Minimum length # The minimum number of characters that values can have.`,content:`Overview # This type stores text and displays it as a QR code in read-only view.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules yes Default display options yes Type rules # Minimum length # The minimum number of characters that values can have.
Maximum length # The maximum number of characters that values can have.
Exact length # The value must have exactly this number of characters.
Regular expression # If set, you can provide a regular expression to validate the value of the field. The expression should follow Java regular expression syntax.
You will see the following options:
Expression: This is the regular expression used to validate values. Hint: In case of a validation error, you can provide a message to be displayed to the user to assist them. Case Insensitive: If enabled, matching will be case insensitive. Note that this applies only to simple characters in the expression. For example, [a-z] will require the letter to be in lowercase, even with this flag enabled. However, expressions like &ldquo;ab&rdquo; will work with variations in case when this flag is set. Display options # Representation # Determines how the field should be displayed in the edit view. This only affects the edit view. Options include:
Input Box: Displays a single-line input box. Text Area: Displays a text area. You can specify the number of rows for the text area. Limit number of characters # Limits the number of characters displayed, with a &quot;More&quot; button to expand the content. This option is effective only in read-only mode.
Error correction level # QR codes have four error correction levels that add varying amounts of &quot;backup&quot; data, based on expected damage:
Level L – Up to 7% damage Level M – Up to 15% damage Level Q – Up to 25% damage Level H – Up to 30% damage Color # Hex color code for the QR code. Default is #000000.
Background color # Hex background color code for the QR code. Default is #ffffff.
Width # Width of the generated image in pixels. Default is 128.
Height # Height of the generated image in pixels. Default is 250
REST API # Read format # The format is a simple string:
&quot;name&quot;: &quot;test1&quot; Write format # To set the value, you should provide a string:
&quot;name&quot;: &quot;new name&quot; JavaScript API # Read format # The val() method within the wrapper will return a plain string:
// this will print something like &quot;name: test1&quot; log('name: '+record.field('name').val()); Write format # You should provide a string to set the new value:
record.field('name').val('new name'); Export/Import # Export format # The export format is a simple string:
&quot;textField1&quot;,&quot;textField2&quot; &quot;value1&quot;,&quot;this is a long text&quot; Import format # The import format is a simple string:
&quot;textField1&quot;,&quot;textField2&quot; &quot;value1&quot;,&quot;this is a long text&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like yes greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # To perform queries, you should provide the text as a plain string. For example:
JS Query MapJS Query BuilderREST API // finds companies with name like &#39;ae&#39; var records_sample = sys.data.find('companies', {&#39;name&#39;: &#39;like(ae)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with name like &#39;ae&#39; var query_sample = sys.data.createQuery('companies') .field(&#39;name&#39;).like(&#39;ae&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with name like &#39;ae&#39; GET /data/contacts?name=like(ae) Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator like Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between no `}),e.add({id:206,href:"/dev-reference/field-types/miscellaneous_types/rank/",title:"Rank type",description:`Overview # The rank type is essentially a string with additional features designed for enabling users to rank records through drag and drop interactions in the user interface. This type is particularly useful when you want to allow users to rearrange records using fields of this type in grid views or workflow views.
Rank fields are auto-populated with a value. When users rank records, and if the view is configured to use the field as a rank, the value will be automatically updated so that the lexical order matches the user&rsquo;s desired arrangement in the UI.`,content:`Overview # The rank type is essentially a string with additional features designed for enabling users to rank records through drag and drop interactions in the user interface. This type is particularly useful when you want to allow users to rearrange records using fields of this type in grid views or workflow views.
Rank fields are auto-populated with a value. When users rank records, and if the view is configured to use the field as a rank, the value will be automatically updated so that the lexical order matches the user&rsquo;s desired arrangement in the UI. To facilitate this, the rank type provides three methods in the JavaScript API: rankBefore(), rankAfter(), and rankBetween(). These methods will automatically calculate the new rank value to ensure that the record maintains its intended position.
Available features # Name Supported Many multiplicity no Default values no Unique flag yes Required flag no Indexable flag yes Sensitive flag yes Calculated value no Automatic initialization yes Calculated initial value yes Aggregation no Default type rules yes Default display options no REST API # Read format # The format is a simple string with the rank value:
&quot;rank&quot;: &quot;iiiii00000&quot; Write format # You should provide a string with the rank value:
&quot;rank&quot;: &quot;iiiii00000&quot; JavaScript API # Read format # When using the val() method in the wrapper for a rank type field, it will return a string with the rank value.
// this will print something like &quot;rank: iiiii00000&quot; log('rank: '+record.field('rank').val()); Write format # You should provide a string with the rank value:
record.field('rank').val('iiiii00000'); Wrapper method: rankBefore(rank) # The rankBefore() method is used to update the rank value of a record so that it is positioned before the specified value in the ranking order.
Parameters # Name Type Required Description rank string yes This value will serve as the rank reference, and accordingly, the value needs to be updated to precede it. Returns # string - The new rank value.
Exceptions # badRequest
If rank is invalid
Samples # // moves a record to be before another one (when sorting by rank) var task1 = sys.data.findOne('tasks', {number: 1}); var task2 = sys.data.findOne('tasks', {number: 2}); var newRank = task1.field('rank').rankBefore(task2.field('rank').val()); sys.data.save(task1); log('new rank: '+newRank); Wrapper method: rankAfter(rank) # The rankAfter() method updates the rank value so that it comes after the provided value.
Parameters # Name Type Required Description rank string yes This value will serve as the reference rank, and the given value will be updated to follow it. Returns # string - The new rank value.
Exceptions # badRequest
If rank is invalid
Samples # // moves a record to be after another one (when sorting by rank) var task1 = sys.data.findOne('tasks', {number: 1}); var task2 = sys.data.findOne('tasks', {number: 2}); var newRank = task1.field('rank').rankAfter(task2.field('rank').val()); sys.data.save(task1); log('new rank: '+newRank); Wrapper method: rankBetween(before, after) # Updates the rank value to position it between the two specified values.
Parameters # Name Type Required Description before string yes This value will serve as the reference rank, and the current value will be adjusted to come after it. after string yes This value will serve as the reference rank, and the value will be updated to be positioned before it. Returns # string - The new rank value.
Exceptions # badRequest
If the before or after values are invalid
Samples # // puts a task in between other two tasks var task1 = sys.data.findOne('tasks', {number: 1}); var task2 = sys.data.findOne('tasks', {number: 2}); var task3 = sys.data.findOne('tasks', {number: 3}); var newRank = task1.field('rank').rankBetween(task2.field('rank').val(), task3.field('rank').val()); sys.data.save(task1); log('new rank: '+newRank); Export/Import # Export format # The export format is a simple string:
&quot;rankField1&quot;,&quot;rankField2&quot; &quot;iiiii0001s&quot;,&quot;iiiii00za8&quot; Import format # The import format is a simple string:
&quot;rankField1&quot;,&quot;rankField2&quot; &quot;iiiii0001s&quot;,&quot;iiiii00za8&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like yes greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should provide the rank value. For instance:
JS Query MapJS Query BuilderREST API // finds a task with rank &#39;iiiii00000&#39; var records_sample = sys.data.find('tasks', {&#39;rank&#39;: &#39;iiiii00000&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds a task with rank &#39;iiiii00000&#39; var query_sample = sys.data.createQuery('tasks') .field(&#39;rank&#39;).equals(&#39;iiiii00000&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds a task with rank &#39;iiiii00000&#39; GET /data/contacts?rank=iiiii00000 Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator like Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between no `}),e.add({id:207,href:"/dev-reference/field-types/references/",title:"Reference types",description:"",content:""}),e.add({id:208,href:"/dev-reference/field-types/special/relationship/",title:"Relationship type",description:`Overview # The relationship type enables the storage of references to other records within the app. It encompasses various features to manage which records can be referenced, along with how to display these references in the user interface.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options no Type rules # Related Entity # This indicates the entity of the records that can be referenced by this field.`,content:`Overview # The relationship type enables the storage of references to other records within the app. It encompasses various features to manage which records can be referenced, along with how to display these references in the user interface.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options no Type rules # Related Entity # This indicates the entity of the records that can be referenced by this field. It&rsquo;s possible to point to the same entity to which the field belongs.
Filtering # A filter is utilized to specify which records can be referenced by this field. If a record fails to meet the filter&rsquo;s criteria, a validation error will be triggered.
It&rsquo;s important to note that the user interface (UI) will automatically filter out records that don&rsquo;t fulfill the specified criteria.
If another record is specified within displayed options, the filters will be combined so that both criteria are met.
Copied Fields # Due to certain restrictions inherent to the database functionality, there might be instances where it&rsquo;s necessary to not only store a reference to a record but also specific information from that record. For instance, let&rsquo;s consider an entity named &ldquo;contacts&rdquo; which has a relationship field pointing to another entity named &ldquo;companies&rdquo;. Within the &ldquo;companies&rdquo; entity, there&rsquo;s a field named &ldquo;type&rdquo;. Suppose you wish to perform a query to retrieve all contacts where the &ldquo;type&rdquo; field of the company they reference is &ldquo;a&rdquo;. To facilitate this type of query, you should designate &ldquo;type&rdquo; as a copied field from the relationship field pointing to &ldquo;company&rdquo;. This arrangement would allow you to execute a query like the following (assuming &ldquo;company&rdquo; is the name of the relationship field):
JS Query MapJS Query BuilderREST API // filter contacts by company type var records_sample = sys.data.find('companies', {&#39;company.type&#39;: &#39;a&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // filter contacts by company type var query_sample = sys.data.createQuery('companies') .field(&#39;company.type&#39;).equals(&#39;a&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // filter contacts by company type GET /data/contacts?company.type=a Once a field is designated as a copied field, it becomes available for use in various contexts. For instance, when you&rsquo;re defining permissions for the &ldquo;contacts&rdquo; entity, you can utilize the &ldquo;company.type&rdquo; field to filter accessible records.
It&rsquo;s important to note that you don&rsquo;t always need to add copied fields when creating expressions based on fields in related records. For instance, if you&rsquo;re creating an expression to highlight records in a grid view, you don&rsquo;t necessarily need to copy fields. For instance, if you want to highlight all contacts where the &ldquo;type&rdquo; is &ldquo;b,&rdquo; you wouldn&rsquo;t need to make the &ldquo;type&rdquo; field a copied field.
The guiding principle is that copied fields are required when queries are involved, whether initiated by you or internally by the application. If a query isn&rsquo;t necessary, then copying the field is unnecessary. In the app builder, you&rsquo;ll notice that while in some cases you can select any field from related records, in other cases, you can only select copied fields.
Understanding the Overhead and Behavior of Copied Fields:
In the provided example, the &ldquo;type&rdquo; field will be copied from the &ldquo;company&rdquo; record to the &ldquo;contact&rdquo; record. Consequently, if you edit the &ldquo;company&rdquo; and update the &ldquo;type&rdquo; field, the new value will automatically propagate to contacts that were referencing this company. This cascade update takes place asynchronously in the background, which means that depending on the number of records that need updating, there could be a noticeable delay in this process.
It&rsquo;s worth noting that introducing numerous copied fields can potentially have adverse effects on an application&rsquo;s performance. Therefore, it&rsquo;s advisable to employ them only when no alternative solution exists for a given problem.
Lastly, you have the ability to modify the default propagation behavior through the &ldquo;Copied Fields Update Policy&rdquo; option.
It's advisable that copied fields do not undergo frequent value changes, as this can help prevent potential performance concerns. Moreover, if alterations to a copied field tend to trigger a substantial number of updates, it's worth exploring alternatives to utilizing copied fields. Delete policy # This indicates the action to take when the record referenced by the field is deleted. The available options are:
None: This is the default behavior. No action will be taken, and the field will continue to point to the deleted record, resulting in a broken relationship. An attempt to save the record will trigger a validation error. Remove Relationship: The field&rsquo;s value will be set to null, and if it&rsquo;s a multi-valued field, it will be removed from the list. Delete Record: The record that references the deleted record will also be deleted. This can be particularly useful for master-detail relationships, where associated records are meant to be deleted when the master record is deleted. Label update policy # By default, if the label of a record changes and there are other records referencing it, a job will be initiated to update the label on those records, similar to the behavior of copied fields.
It&rsquo;s crucial to ensure that labels are updated accurately for correct user display in the UI and for queries that filter by the relationship field using record labels.
However, updating the label in all fields that reference the modified record incurs a performance penalty. To manage this behavior, there are options:
Yes: The field&rsquo;s value will be automatically updated when the label of the record changes. No: The field&rsquo;s value won&rsquo;t be updated if the label of the record changes. In this scenario, there might be a discrepancy between the label displayed in the field and the actual label in the referenced record. To mitigate performance concerns, strive to keep labels as stable as possible to minimize frequent changes that trigger numerous cascade updates.
Copied fields update policy # This policy allows you to specify whether copied fields should be automatically updated when their values change. The available options are:
Yes: If the value of any copied field changes in the referenced record, the corresponding values in the relationship field will be updated. No: If the value of any copied field changes in the referenced record, the values in the relationship field won&rsquo;t be updated. This could lead to inconsistent query results when using those copied fields. Display options # Representation # Determines how the value will be displayed:
Drop down: A dropdown menu will be employed for selecting the field&rsquo;s value. Boxes: All records eligible as the field&rsquo;s value will be presented in individual boxes, enabling users to easily select one. It&rsquo;s advisable to use this representation when the number of available options is limited. Note that this representation supports a maximum of 100 records. In both cases, these representations are applicable only in edit mode.
Filtering # A filter is employed to specify which records can be referenced by this field. Unlike the filtering option available in type rules, this filter operates solely at the UI level and will not trigger validation errors.
This option proves beneficial when you intend to narrow down the records that can be selected for a specific view.
Enable Link # Enabling this flag results in the rendering of a link to the reference record in read-only mode.
Please note that you must select a view in which the referenced record can be displayed.
Allow creating new records # When enabled, this flag adds a button in edit mode that allows the creation of a new record. If the record is created using this button, it will be automatically selected as the value for the field.
Keep in mind that you need to select a view to use for creating the new record.
Allow editing records # Enabling this flag displays a button in edit mode that permits the editing of the referenced record.
Please note that you must select a view in which the referenced record can be edited.
Sort field # This allows the possible records to be sorted by a specific field.
Sort type # Specifies the sort direction, which can be ascending or descending.
Visible fields # If you require displaying more information from the referenced record beyond just the label, you can employ visible fields. These fields will be showcased in the read-only view of the field alongside the record&rsquo;s label.
It&rsquo;s important to understand that these visible fields are not stored in the database, which distinguishes them from copied fields. Instead, they are dynamically merged at the time of reading the record.
Visible fields layout # This option provides control over the layout of visible fields, particularly useful when space is limited. The available options are:
Automatic: The layout is chosen based on the view&rsquo;s context. For example, the dynamic layout is applied in grid views, while read-only views adopt the fixed layout. Fixed: Labels are allocated a predetermined space, with the remaining space designated for visible field values. Dynamic: Space allocated for both labels and values of visible fields adjusts according to the content in each column. Custom: In this scenario, you can specify the width allocated for visible field labels, while the remaining space is designated for values. Allow label wrapping # Set this to true when labels of relationship fields are notably lengthy, and you wish to wrap the context by adding ellipsis. This should be applied only when displaying the field using the label class, similar to visible fields. The default value is false.
REST API # Read format # The data is represented in JSON format and includes the following fields:
id: This signifies the ID of the referenced record. label: This represents the label of the referenced record. Copied fields: Any copied fields are contained within the map structure. In the example provided below, the fields type and isCustomer are copied fields. Here is a sample representation of a relationship field in JSON format:
&quot;company&quot;: { &quot;id&quot;: &quot;57fd2d61e4b0ce322b0c55af&quot;, &quot;label&quot;: &quot;Fivechat&quot;, &quot;type&quot;: &quot;c&quot;, &quot;isCustomer&quot;: false } Write format # You have several options for the write format:
You can provide only the ID:
&quot;company&quot;: {&quot;id&quot;: &quot;57fd2d61e4b0ce322b0c55af&quot;} Alternatively, you can directly pass the ID as a string:
&quot;company&quot;: &quot;57fd2d61e4b0ce322b0c55af&quot; You can supply the label of the record:
&quot;company&quot;: {&quot;label&quot;: &quot;Fivechat&quot;} Or provide the label as a string:
&quot;company&quot;: &quot;Fivechat&quot; When utilizing the label, it&rsquo;s imperative that each label is unique. If multiple records share the same label, attempting to save the records will result in a validation error.
Furthermore, it&rsquo;s possible to employ a lookup field. For instance, if the field &quot;code&quot; in the &quot;companies&quot; entity has been designated as a lookup field, you can utilize the following approach:
&quot;company&quot;: {&quot;code&quot;: &quot;fivechat-co&quot;} Or provide the code field value as a string:
&quot;company&quot;: &quot;fivechat-co&quot; JavaScript API # Read format # The val() method within the wrapper will return an object:
{ &quot;id&quot;: &quot;57fd2d61e4b0ce322b0c55af&quot;, &quot;label&quot;: &quot;Fivechat&quot;, &quot;link&quot;: &quot;/data/companies/57fd2d61e4b0ce322b0c55af&quot;, &quot;type&quot;: &quot;c&quot;, &quot;isCustomer&quot;: false } Where:
id: This is the ID of the referenced record. label: This represents the label of the referenced record. link: This is the URL in the REST API for the record. Copied fields: Any copied fields are included within the map structure. In the example provided below, the fields type and isCustomer are copied fields. However, in most cases, rather than retrieving the raw value of the relationship, you will use the methods available in the wrapper to directly access the ID or label.
Write format # You have several options for the write format of the Javascript API:
You can provide only the ID:
record.field(&quot;company&quot;).val({id: &quot;57fd2d61e4b0ce322b0c55af&quot;}); Alternatively, you can directly pass the ID as a string:
record.field(&quot;company&quot;).val(&quot;57fd2d61e4b0ce322b0c55af&quot;); You can supply the label of the record:
record.field(&quot;company&quot;).val({label: &quot;Fivechat&quot;}); Or provide the label as a string:
record.field(&quot;company&quot;).val(&quot;Fivechat&quot;); When utilizing the label, it&rsquo;s imperative that each label is unique. If multiple records share the same label, attempting to save the records will result in a validation error.
Furthermore, it&rsquo;s possible to employ a lookup field. For instance, if the field &quot;code&quot; in the &quot;companies&quot; entity has been designated as a lookup field, you can utilize the following approach:
record.field(&quot;company&quot;).val({code: &quot;fivechat-co&quot;}); Or provide the code field value as a string:
record.field(&quot;company&quot;).val(&quot;fivechat-co&quot;); If you include all the fields, the priority order for determining the value is as follows: id takes precedence, followed by label, and finally any configured lookup field.
The JavaScript API also provides the option to establish a relationship wrapper as demonstrated below:
contact1.field('company').val(contact2.field('company')); Or provide a record object:
var company = sys.data.findOne('companies', {name: 'Browsetype'}); contact.field('company').val(company); Wrapper method: id() # Returns the ID of the referenced record or null if the field is empty.
Returns # string - The ID of the referenced record.
Samples # // prints the ID of the referenced record in a relationship field var record = sys.data.findOne('contacts', {email: 'djohnstonb0@behance.net'}); log('company id: '+record.field('company').id()); Wrapper method: label() # Returns the label of the referenced record or null if the field is empty.
Returns # string - The label of the referenced record
Samples # // prints the label of the referenced record in a relationship field var record = sys.data.findOne('contacts', {email: 'djohnstonb0@behance.net'}); log('company label: '+record.field('company').label()); Wrapper method: fetch(fields) # Returns the referenced record. If the record cannot be found, it will return null. Optionally, you can specify the fields to be retrieved.
Parameters # Name Type Required Description fields string[] yes An array of fields to be retrieved Returns # sys.data.Record - The label of the referenced record.
Exceptions # badRequest
If the id isn&rsquo;t available, for instance, when you only set the field using the label and haven&rsquo;t saved it yet, the id won&rsquo;t be accessible. Consequently, you cannot fetch the referenced record using this method.
Samples # // fetches the referenced record var contact = sys.data.findOne('contacts', {email: 'djohnstonb0@behance.net'}); var company = contact.field('company').fetch(); log('company: '+company.label()); // return only some fields of the related record var contact = sys.data.findOne('contacts', {email: 'djohnstonb0@behance.net'}); var company = contact.field('company').fetch(['name', 'type']); log('company: '+company.field('name').val()); log('company: '+company.field('type').val()); Wrapper method: fetchAndLock(fields) # Returns and locks the referenced record. If the record cannot be found, it will return null. Optionally, you can specify the fields to be retrieved.
Parameters # Name Type Required Description fields string[] yes An array of fields to be retrieved Returns # sys.data.Record - The label of the referenced record.
Exceptions # badRequest
If the id isn&rsquo;t available, for instance, when you only set the field using the label and haven&rsquo;t saved it yet, the id won&rsquo;t be accessible. Consequently, you cannot fetch the referenced record using this method.
Samples # // fetches the referenced record var contact = sys.data.findOne('contacts', {email: 'djohnstonb0@behance.net'}); var company = contact.field('company').fetch(); log('company: '+company.label()); // return only some fields of the related record var contact = sys.data.findOne('contacts', {email: 'djohnstonb0@behance.net'}); var company = contact.field('company').fetch(['name', 'type']); log('company: '+company.field('name').val()); log('company: '+company.field('type').val()); Wrapper method: field(path) # Returns the wrapper of a copied field.
Parameters # Name Type Required Description path string yes The path of the copied field to get the wrapper. Returns # sys.data.Wrapper or sys.data.ManyWrapper - The wrapper of the copied field.
Exceptions # badRequest
If path is invalid
Samples # // gets the wrapper of the copied field and prints it's value var contact = sys.data.findOne('contacts', {email: 'djohnstonb0@behance.net'}); var companyTypeWrapper = contact.field('company').field('type'); log('company type: '+companyTypeWrapper.val()); Wrapper method: equals(value) # Determines whether the provided parameter references the same as the current value of the field.
This method overrides the default behavior of sys.data.Wrapper.equals().
Parameters # Name Type Required Description value any yes The value to compare against the field’s value can take different forms: - Record ID - Record label - Another relationship wrapper - A sys.data.Record object - An object with an id field - An object with a label field Returns # boolean - Returns true if the value is the same as the field’s value, and false otherwise.
Samples # // checks if the value is the same var contact = sys.data.findOne('contacts', {email: 'djohnstonb0@behance.net'}); var company = contact.field('company').fetch(); log('equals - id: '+contact.field('company').equals(company.id())); log('equals - object with id: '+contact.field('company').equals({id: company.id()})); log('equals - label: '+contact.field('company').equals(company.label())); log('equals - object with label: '+contact.field('company').equals({label: company.label()})); log('equals - wrapper: '+contact.field('company').equals(contact.field('company'))); log('equals - record: '+contact.field('company').equals(company)); Export/Import # Export format # The export format is the label of the related record:
&quot;relationshipField&quot;,&quot;relationshipField.type&quot; &quot;Record label&quot;,&quot;a&quot; Notice that it is possible to export fields from the related record.
Import format # There are different ways to import relationship fields. One of the simplest methods is to use the label:
&quot;relationshipField&quot; &quot;Record label&quot; Additionally, it is possible to indicate a lookup field:
&quot;relationshipField.lookupField&quot; &quot;abc-123&quot; In this case, the related record will be matched using the specified lookup field. An error will be thrown if more than one record is matched.
Lastly, please be aware that if you provide the related fields, the record could be automatically created or updated:
&quot;relationshipField.code&quot;,&quot;relationshipField.name&quot; &quot;abc-123&quot;,&quot;test&quot; For example, this will create a new record with fields &quot;code&quot; and &quot;name&quot; set to &quot;abc-123&quot; and &quot;test&quot; respectively. If one of those fields is marked as unique, the import process will first attempt to match an existing record. If a match is found, the record will be updated; if not, a new record will be created.
Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like yes greater no greaterOrEquals no less no lessOrEquals no between no currentUserField no Query formats # By default, the label will be used for the various query operators.
For instance, the following query will retrieve contacts where the label of the company is &lsquo;Blogpad&rsquo;:
JS Query MapJS Query BuilderREST API // finds a contact by company label var records_sample2 = sys.data.find('contacts', {company: &#39;Blogpad&#39;}); log('total: '+records_sample2.count()); while (records_sample2.hasNext()) { log(records_sample2.next().label()); } // finds a contact by company label var query_sample2 = sys.data.createQuery('contacts') .field(&#39;company&#39;).equals(&#39;Blogpad&#39;) var records_sample2 = sys.data.find(query_sample2); log('total: '+records_sample2.count()); while (records_sample2.hasNext()) { log(records_sample2.next().label()); } // finds a contact by company label GET /data/contacts?company=Blogpad However you can also use the label explicitly:
JS Query MapJS Query BuilderREST API // finds a contact by company label var records_sample3 = sys.data.find('contacts', {&#39;company.label&#39;: &#39;Blogpad&#39;}); log('total: '+records_sample3.count()); while (records_sample3.hasNext()) { log(records_sample3.next().label()); } // finds a contact by company label var query_sample3 = sys.data.createQuery('contacts') .field(&#39;company&#39;).equals(&#39;Blogpad&#39;) var records_sample3 = sys.data.find(query_sample3); log('total: '+records_sample3.count()); while (records_sample3.hasNext()) { log(records_sample3.next().label()); } // finds a contact by company label GET /data/contacts?company.label=Blogpad Note that you don&rsquo;t need to explicitly include &ldquo;label&rdquo; in the query builder path. It is automatically identified based on what you provide to the equals method.
You can also perform a query based on the ID:
JS Query MapJS Query BuilderREST API // finds a company by exact name var records_sample4 = sys.data.find('contacts', {&#39;company.id&#39;: &#39;57fd2d65e4b0ce322b0c8565&#39;}); log('total: '+records_sample4.count()); while (records_sample4.hasNext()) { log(records_sample4.next().label()); } // finds a company by exact name var query_sample4 = sys.data.createQuery('contacts') .field(&#39;company&#39;).equals(&#39;57fd2d65e4b0ce322b0c8565&#39;) var records_sample4 = sys.data.find(query_sample4); log('total: '+records_sample4.count()); while (records_sample4.hasNext()) { log(records_sample4.next().label()); } // finds a company by exact name GET /data/contacts?company.id=57fd2d65e4b0ce322b0c8565 Again, the query builder will automatically recognize the ID, so you don&rsquo;t need to use the &ldquo;id&rdquo; suffix in this case.
Remember that when utilizing the query builder, you have the flexibility to use any of the formats available in the JavaScript API.
Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min no max no UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator like The label of the referenced record will be used for matching. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less no Less or equals no Between no `}),e.add({id:209,href:"/dev-reference/field-types/special/",title:"Special types",description:"",content:""}),e.add({id:210,href:"/dev-reference/user-interface/table-widget/",title:"Table widget",description:`Table widget views enable the display of records from an entity in a tabular format.
Entity # This specifies the entity to which the view will refer. Only records of this entity will be listed in the table widget.
Label # This is a human-readable name for the view. You can use spaces, special characters, and a mix of upper case and lower case letters.
This label will appear at the top of the table widget view, so ensure that you choose something understandable for users.`,content:`Table widget views enable the display of records from an entity in a tabular format.
Entity # This specifies the entity to which the view will refer. Only records of this entity will be listed in the table widget.
Label # This is a human-readable name for the view. You can use spaces, special characters, and a mix of upper case and lower case letters.
This label will appear at the top of the table widget view, so ensure that you choose something understandable for users.
Name # This serves as the internal name of the view. It cannot contain special characters or spaces.
Usually, you will use the name of the view in scripts and the REST API. Changing it could potentially affect your app, necessitating manual adjustments.
Description # This provides a human-readable description for the widget. Special characters, spaces, and a mix of upper case and lower case letters can be used. This description can also be internationalized.
This description will be displayed at the top of the added widget in your dashboard.
Allow refresh # This option controls the display of a refresh button. Users can use this button to update the widget&rsquo;s information. It is set to true by default.
List settings # Dataset settings # These settings determine the behavior of the listing.
Sort field # This is the default sorting field for the listing.
Users might be able to change the default sorting if that functionality is enabled in any of the columns.
Sort type # This indicates the sorting direction.
Users might be able to change the default sorting if that functionality is enabled in any of the columns.
Filter type # This can be either an expression or a script. If &ldquo;expression&rdquo; is selected, record filters should be set. Otherwise, a script should be returned.
Record filters # This defines which records will appear in the list. Only records that match the given expression will be listed in the table widget view.
Script # This returns a query parameter or queryMap. The query map object is used to filter records. Refer to the Query Language documentation for the query map version.
Size # This specifies the maximum number of records to fetch when the view is loaded.
Pagination # Enable pagination # This option determines whether pagination is displayed on the widget.
Page size # This defines the number of rows that a page can contain. This option is only available when Enable Pagination is set to true.
Columns # Here, you can add or remove fields as columns in the table listing. These columns will use the default display options of fields, but you can override them. For more information, consult the General Display Options documentation.
Columns have additional options beyond those available for fields:
Automatic Width: Indicates whether the browser should automatically adjust the width of the column based on the available space and content or if it should have a fixed width, which can be specified in pixels or as a percentage. Allow to Wrap Title: By default, the title won&rsquo;t wrap unless this flag is enabled. This can be useful for fields with long labels (you can also override the label of the field in the display options). Allow Sorting: This flag indicates whether sorting arrows will be available on this column. This flag is set by default for fields with the indexable flag set. Available events # On row clicked # This event is fired every time you click on a table row. It is listened to by all the defined layout listeners that belong to the Dashboard. The event type name is TABLE_ROW_CLICKED, and the event payload contains the recordId.
UI message # Widgets can react to UI messages, commonly used for refreshing data or applying filters.
Refresh and filter # You can send a message to refresh the widget using its default settings. These messages are sent to the dashboard container and propagated to each widget.
Additionally, you can send a filter parameter to be applied to the query used to fetch the data. This query can be a query object or a query map. For query objects, the filter is only applied if the entity matches the entity set in the widget. Refer to the Query Language for more information.
To apply filters, set the widgetContainer with a list of objects, each describing the container&rsquo;s name and the filter to be applied on each widget. You can also include the title to update the widget title.
Example # Use case # Table widgets allow for a more condensed view of specific collection information. The configuration process is similar to grid views. Tables are useful for comparing pairs of related values, such as quarterly sales over multiple years. They are also suitable for situations where you have multiple sets of values with a direct relationship.
For instance, consider a scenario where you want to visualize the relationship between costs and generated income. A table could be ideal for presenting such information.
Precondition # For this example, we assume that there is an existing grid view containing a read-only view for the Companies entity. The grid view is named companies, and several records are present.
Creating a table widget # Step 1: You can create a widget from the root layout of a Dashboard, or from a column or row within a Dashboard view. Alternatively, you can create it from the Widget views menu and then associate it with a Dashboard view.
Step 2: On the widget view creation screen, load the required data and select Table as the Widget type. Choose the Companies entity. Once all fields are completed, click Create.
Step 3: In the table widget&rsquo;s column editing screen, create three columns referencing the name, costs, and revenue fields.
Step 4: Associate the new widget with an existing Dashboard.
Step 5: Add a listener to the Dashboard to react to the TABLE_ROW_CLICKED event type. Send a UI message to navigate to the corresponding read-only view.
Step 6: Provide the necessary context for the On event script and the script that responds to the event by sending a UI message.
Parameters # Name Type Description event object This event object contains information about where was the refresh fired, it can be when user click the refresh button of the UI or when send UI messages from other side. Samples # // React to a table widget row clicked event // event payload contains all the specific event information var eventPayload = event.payload; if (eventPayload) { // reacting to the event 'TABLE_ROW_CLICKED' if (eventPayload.eventName == 'TABLE_ROW_CLICKED') { sys.ui.sendMessage({ scope: 'global', name: 'navigate', view: 'projects', target: 'caller', recordId: eventPayload.recordId }); } } Step 6: Push changes, and when you click on a row inside the table widget, you will navigate to the corresponding read-only view.
Events and UI Messages # Here&rsquo;s an example that demonstrates how to react to a table widget row event. We will need to monitor events in a dashboard container.
Assuming you have a table widget hosted in the dashboard container salesCompaniesContainer, the following example checks if an event was fired from that specific table widget. This information is then used to create a new query to refresh a bar chart displaying sales per company.
Suppose you have a widget that displays sales per company, hosted in a dashboard container called salesPerCompaniesBar.
if(event.type == 'TABLE_ROW_CLICKED' &amp;&amp; event.containerName == 'salesCompaniesContainer') { var record = sys.data.findById('companies', event.recordId); var companyNameStr = record.field('name').val(); var query = sys.data.createQuery('salesPerCompany'); query.field('companyName').equals(companyNameStr); // query.field('period').greaterThan('...'); define some criteria for our query sys.ui.sendMessage({ scope: 'view', name: 'refresh', views: ['dashboardView'], widgetContainers: [ { name: 'salesPerCompaniesBar', title: 'Sales for - ' + companyNameStr, filter: query } ] }); } `}),e.add({id:211,href:"/dev-reference/field-types/text/text/",title:"Text type",description:`Overview # This type can store free text of up to 300 characters. If you require more space, consider using the Long Text type.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules yes Default display options yes Type rules # Minimum length # Specifies the minimum number of characters allowed for field values.`,content:`Overview # This type can store free text of up to 300 characters. If you require more space, consider using the Long Text type.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules yes Default display options yes Type rules # Minimum length # Specifies the minimum number of characters allowed for field values.
Maximum length # Specifies the maximum number of characters allowed for field values.
Exact length # Requires that the value consists of a specific number of characters.
Regular expression # If set, you can use a regular expression to validate the value of the field. The expression should adhere to Java&rsquo;s regular expression syntax.
The following options are available:
Expression: This field allows you to enter the regular expression for value validation. Hint: In the event of a validation error, you can provide a user-friendly message here to assist users. Case Insensitive: If enabled, matching will be case insensitive. It&rsquo;s important to note that this only applies to simple characters in the expression. For instance, [a-z] will still require the letter to be lowercase, even if this flag is set. However, if you use &ldquo;ab&rdquo; in the expression, variations like &ldquo;Ab&rdquo; or &ldquo;AB&rdquo; will work. Display options # Representation # Determines how the field should be displayed, primarily impacting the edit view. The available options are:
Input Box: Displays a single-line input box. Text Area: Displays a text area. An additional option lets you specify the number of rows for the text area. Limit number of characters # This restricts the number of characters displayed, accompanied by a &ldquo;More&rdquo; button to expand the content. This option exclusively affects read-only fields.
Background color # Defines whether the text value should appear as a label in the read-only view. By default, this value is null, resulting in the value being displayed without a label. You have the ability to establish multiple conditional background color rules. For each rule, you must select a color and define an expression. All fields matching the expression will adopt the chosen color. Alternatively, you can use a script in place of an expression. The script can make use of the following parameters:
record: Represents the current record that the field is a part of. parentField: Applicable when the field is an inner field of a nested field type. This parameter enables referencing sibling fields. action: Applicable when the field is a parameter of an action. It&rsquo;s important to note that this option comes into play only when the field is in read-only mode.
Password type # This denotes an editing control intended for entering passwords.
REST API # Read format # The format is a simple string:
&quot;notes&quot;: &quot;test1&quot; Write format # You should provide a string:
&quot;notes&quot;: &quot;new name&quot; JavaScript API # Read format # The val() method within the wrapper will return a plain string:
// this will print something like &quot;notes: test notes&quot; log('name: '+record.field('name').val()); Write format # To set the value, you should provide a plain string:
record.field('name').val('new name'); Export/Import # Export format # The export format is a simple string:
&quot;longTextField1&quot;,&quot;longTextField2&quot; &quot;line1\\nline2&quot;,&quot;this is a long text&quot; Import format # The import format is a simple string:
&quot;longTextField1&quot;,&quot;longTextField2&quot; &quot;line1\\nline2&quot;,&quot;this is a long text&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like yes greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should provide the text as a plain string. For example:
JS Query MapJS Query BuilderREST API // finds companies with notes like &#39;ae&#39; var records_sample = sys.data.find('companies', {&#39;notes&#39;: &#39;like(ae)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with notes like &#39;ae&#39; var query_sample = sys.data.createQuery('companies') .field(&#39;notes&#39;).like(&#39;ae&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with notes like &#39;ae&#39; GET /data/contacts?notes=like(ae) Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator like Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between no `}),e.add({id:212,href:"/dev-reference/field-types/text/",title:"Text types",description:"",content:""}),e.add({id:213,href:"/dev-reference/field-types/date_and_time/time-duration/",title:"Time duration type",description:`Overview # The duration type can store a time duration, such as &ldquo;3 hours&rdquo; or &ldquo;2 days and 2 hours&rdquo;. The duration is stored internally in milliseconds, while users can utilize a user-friendly language representation in the format Xd Xh Xm Xs. Here, 'd' represents days, 'h' for hours, 'm' for minutes, and 's' for seconds.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # When dealing with durations, you can customize how they are displayed using the following options:`,content:`Overview # The duration type can store a time duration, such as &ldquo;3 hours&rdquo; or &ldquo;2 days and 2 hours&rdquo;. The duration is stored internally in milliseconds, while users can utilize a user-friendly language representation in the format Xd Xh Xm Xs. Here, 'd' represents days, 'h' for hours, 'm' for minutes, and 's' for seconds.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # When dealing with durations, you can customize how they are displayed using the following options:
Format up to: This determines the larger unit of time to display. For instance, if the chosen unit is hours, you might see a duration as &ldquo;40h&rdquo;. However, if days are the chosen unit, the duration could be displayed as &ldquo;1d 16h&rdquo;.
Format down to: This specifies the smaller unit of time for display, truncating the rest. For example, if the value is &ldquo;2h 30m 15s&rdquo; and the smaller unit is minutes, the display will be &ldquo;2h 30m&rdquo;.
Default unit: When entering a value without a unit, this unit will be assumed. For instance, if &ldquo;3&rdquo; is entered without a unit and the default unit is hours, it will be interpreted as &ldquo;3d&rdquo;.
REST API # Read format # The value of this type is represented as the number of milliseconds.
&quot;hoursPerWeek&quot;: 10800000 Write format # When writing the value for this type, you should provide the number of milliseconds.
&quot;hoursPerWeek&quot;: 10800000 JavaScript API # Read format # The val() method in the wrapper will return the number of milliseconds.
// this will print something like &quot;hoursPerWeek: 10800000&quot; log('hoursPerWeek: '+record.field('hoursPerWeek').val()); Write format # You should provide the number of milliseconds.
record.field('hoursPerWeek').val(10800000); Export/Import # Export format # The export format uses the form explained in the overview of the duration type:
Xd Xh Xm Xs, where X represents the number of days, hours, minutes, and seconds respectively. &quot;durationField1&quot;,&quot;durationField2&quot; &quot;4h 30m&quot;,&quot;3d&quot; Import format # The import format uses the form explained in the overview of the duration type:
Xd Xh Xm Xs, where X represents the number of days, hours, minutes, and seconds respectively. &quot;durationField1&quot;,&quot;durationField2&quot; &quot;4h 30m&quot;,&quot;3d&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # When working with queries, it&rsquo;s essential to provide the time in milliseconds.
JS Query MapJS Query BuilderREST API // finds contacts that worked more than 40 hours per week var records_sample = sys.data.find('contacts', {&#39;hoursPerWeek&#39;: &#39;greater(144000000)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds contacts that worked more than 40 hours per week var query_sample = sys.data.createQuery('contacts') .field(&#39;hoursPerWeek&#39;).greater(144000000) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds contacts that worked more than 40 hours per week GET /data/contacts?hoursPerWeek=greater(144000000) Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum yes avg yes first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals
The format is Xd Xh Xm Xs, where X represents the number of days, hours, minutes, and seconds respectively. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between yes `}),e.add({id:214,href:"/dev-reference/field-types/date_and_time/time/",title:"Time type",description:`Overview # This field type is designed to store a specific time of the day.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options no REST API # Read format # The format is a string with the format HH:mm:`,content:`Overview # This field type is designed to store a specific time of the day.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options no REST API # Read format # The format is a string with the format HH:mm:
&quot;openingHours&quot;: &quot;08:00&quot; Write format # You should provide a string with the format HH:mm:
&quot;openingHours&quot;: &quot;08:00&quot; JavaScript API # Read format # The val() method in the wrapper will return a string in the format HH:mm.
// this will print something like &quot;time: 08:00&quot; log('time: '+record.field('openingHours').val()); Write format # You should provide a string with the format HH:mm:
record.field('openingHours').val('HH:mm'); Export/Import # Export format # The export format is HH:mm:
&quot;timeField1&quot;,&quot;timeField2&quot; &quot;20:30&quot;,&quot;10:15&quot; Import format # The import format is HH:mm:
&quot;timeField1&quot;,&quot;timeField2&quot; &quot;20:30&quot;,&quot;10:15&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should provide a string with the format HH:mm. For example:
JS Query MapJS Query BuilderREST API // finds companies opening after 10:00 var records_sample = sys.data.find('companies', {&#39;openingHours&#39;: &#39;greater(10:00)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies opening after 10:00 var query_sample = sys.data.createQuery('companies') .field(&#39;openingHours&#39;).greater(&#39;10:00&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies opening after 10:00 GET /data/contacts?openingHours=greater(10:00) Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals
The format is Xd Xh Xm Xs, where X represents the number of days, hours, minutes, and seconds respectively. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between yes `}),e.add({id:215,href:"/dev-reference/field-types/text/url/",title:"URL type",description:`Overview # This field type is designed for storing URLs, such as http://www.test.com/path. The field will be displayed as a clickable link.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # Open in current tab # Enabling this flag causes the link to open in the same tab.`,content:`Overview # This field type is designed for storing URLs, such as http://www.test.com/path. The field will be displayed as a clickable link.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag yes Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # Open in current tab # Enabling this flag causes the link to open in the same tab. If the flag is not set, the link will open in a new tab.
REST API # Read format # The format consists of a simple string representing the URL:
&quot;homepage&quot;: &quot;http://www.test.com&quot; Write format # To set the value, you should provide a string with the URL:
&quot;homepage&quot;: &quot;http://www.test.com&quot; The value of a URL can be a straightforward URL, but it&rsquo;s also possible to utilize Markdown to enhance its readability.
&quot;homepage&quot;: &quot;(http://www.test.com)&lt;Test&gt;&quot; JavaScript API # Read format # The val() method in the wrapper will return a plain string representing the URL:
// this will print something like &quot;url: http://www.test.com&quot; log('url: '+record.field('homepage').val()); Alternatively, it will return the Markdown value:
// this will print something like &quot;url+label: (http://www.test.com)&lt;Test&gt;&quot; log('url+label: '+record.field('homepage').val()); If you wish to retrieve only the URL:
// this will print something like &quot;url: http://www.test.com&quot; log('url: '+record.field('homepage').url()); If you&rsquo;re interested in retrieving only the label:
// this will print something like &quot;label: Test&quot; log('label: '+record.field('homepage').text()); Write format # To set the value, you should provide a plain string containing the URL:
record.field('homepage').val('http://www.test1.com'); You can also use Markdown to define both the URL and the label:
record.field('homepage').val('(http://www.test1.com)&lt;Test&gt;'); Export/Import # Export format # The export format is a simple string:
&quot;urlField1&quot;,&quot;urlField2&quot; &quot;http://www.google.com&quot;,&quot;www.google.com&quot; Import format # The import format is a simple string:
&quot;urlField1&quot;,&quot;urlField2&quot; &quot;http://www.google.com&quot;,&quot;www.google.com&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like yes greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # For equality queries, you can provide the value with or without the mask format. For example:
JS Query MapJS Query BuilderREST API // finds companies with homepage like &#39;test&#39; var records_sample = sys.data.find('companies', {&#39;homepage&#39;: &#39;like(test)&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with homepage like &#39;test&#39; var query_sample = sys.data.createQuery('companies') .field(&#39;homepage&#39;).like(&#39;test&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds companies with homepage like &#39;test&#39; GET /data/contacts?homepage=like(test) Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator like Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between no `}),e.add({id:216,href:"/dev-reference/field-types/date_and_time/year-month/",title:"Year-Month type",description:`Overview # This field type is capable of storing a specific year and month. It does not include the day or time information, focusing solely on the year and month.
Default format: The default format is yyyy-MM, although it can be customized to a different format.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # Representation # This defines the format for displaying the month and year.`,content:`Overview # This field type is capable of storing a specific year and month. It does not include the day or time information, focusing solely on the year and month.
Default format: The default format is yyyy-MM, although it can be customized to a different format.
Available features # Name Supported Many multiplicity yes Default values yes Unique flag no Required flag yes Indexable flag yes Sensitive flag yes Calculated value yes Automatic initialization no Calculated initial value no Aggregation no Default type rules no Default display options yes Display options # Representation # This defines the format for displaying the month and year. The default format is yyyy-MM, but you have the option to customize it to your preference.
There are several predefined formats available, which are commonly used. Additionally, you can choose the &quot;Custom&quot; option to define your own format based on the following guidelines:
Era designator: G (AD) Year: yy (16), yyyy (2016) Month: MMMM (July), MMM (Jul), MM (07) REST API # Read format # The format for the date is a string using the yyyy-MM format.
&quot;nextHolidays&quot;: &quot;2016-07&quot; Write format # To specify the date, you need to provide a string in the yyyy-MM format.
&quot;nextHolidays&quot;: &quot;2016-07&quot; JavaScript API # Read format # When utilizing the val() method within the wrapper, it will yield a Date object.
// this will print something like &quot;holidays: Thu Jun 01 2017 00:00:00 GMT-0000 (UTC)&quot; log('holidays: '+record.field('nextHolidays').val()); As the Date object contains day and time information, it will be set to 00:00 of the first day of the month using the time zone of the server.
Write format # When writing the value, you have the option to either use a Date object or provide a string in the yyyy-MM format.
record.field('nextHolidays').val(new Date()); record.field('nextHolidays').val('2016-07'); If the provided value is not valid, the field will be silently set to null.
Wrapper method: format(pattern) # Formats the month into a string. If a format pattern is provided, it will be used; otherwise, the format set in the default display options of the field will be used.
Parameters # Name Type Required Description pattern string no The pattern parameter specifies the format for formatting the month. Please refer to the documentation for display options to understand the available format options.
If no pattern is provided, the default display options of the field will be used. Returns # string - The formatted month.
Exceptions # badRequest
If pattern is invalid
Samples # // formats month using 'MM-yyyy' pattern var contact = sys.data.findOne('contacts', {email:'apetersonay@guardian.co.uk'}); log('holidays: '+contact.field('nextHolidays').format('MM-yyyy')); // formats month using default display options var contact = sys.data.findOne('contacts', {email:'apetersonay@guardian.co.uk'}); log('holidays: '+contact.field('nextHolidays').format()); Export/Import # Export format # The export format is yyyy-MM, regardless of the display options configured for that field.
&quot;yearMonthField1&quot;,&quot;yearMonthField2&quot; &quot;02-10&quot;,&quot;05-24&quot; Import Format # The import format is yyyy-MM, regardless of the display options configured for that field.
&quot;yearMonthField1&quot;,&quot;yearMonthField2&quot; &quot;02-10&quot;,&quot;05-24&quot; Queries # For more information, please refer to the Query Language Documentation.
Available operators # Operator Supported equals yes notEquals yes empty yes notEmpty yes like no greater yes greaterOrEquals yes less yes lessOrEquals yes between yes currentUserField no Query formats # You should pass a string with the format yyyy-DD. For example:
JS Query MapJS Query BuilderREST API // finds contacts with holidays in 2017-07 var records_sample = sys.data.find('contacts', {&#39;nextHolidays&#39;: &#39;2017-07&#39;}); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds contacts with holidays in 2017-07 var query_sample = sys.data.createQuery('contacts') .field(&#39;nextHolidays&#39;).equals(&#39;2017-07&#39;) var records_sample = sys.data.find(query_sample); log('total: '+records_sample.count()); while (records_sample.hasNext()) { log(records_sample.next().label()); } // finds contacts with holidays in 2017-07 GET /data/contacts?nextHolidays=2017-07 When utilizing the query builder, you have can use a Date object.
query.field('nextHolidays').equals(new Date()); Aggregate queries # Please refer to the Aggregate Queries Documentation for more detailed information.
Available operators # Operator Supported sum no avg no first yes last yes min yes max yes UI queries # Please refer to the UI Queries Documentation for more detailed information.
Matching of values # Property Description Matching operator equals
UI queries will attempt to match using the format specified in the default display options of the field. Available operators # Operator Supported Many values yes Greater no Greater or equals no Less yes Less or equals yes Between yes `}),e.add({id:217,href:"/dev-reference/",title:"Developer's reference",description:"Prologue Doks.",content:""}),e.add({id:218,href:"/extensions/migrations/",title:"Extending the platform",description:"Prologue Doks.",content:""}),e.add({id:219,href:"/getting-started/getting/",title:"Getting started",description:"Prologue Doks.",content:""}),e.add({id:220,href:"/platform-ref/",title:"Platform reference",description:"Prologue Doks.",content:""}),e.add({id:221,href:"/",title:"Modern Documentation Theme",description:"Doks is a Hugo theme for building secure, fast, and SEO-ready documentation websites, which you can easily update and customize.",content:" What is Slingr? Sign up free Start Learning Slingr channel "}),e.add({id:222,href:"/categories/",title:"Categories",description:"",content:""}),e.add({id:223,href:"/contributors/",title:"Contributors",description:"",content:""}),e.add({id:224,href:"/tags/",title:"Tags",description:"",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()
